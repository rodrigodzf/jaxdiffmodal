[
  {
    "objectID": "num_utils.html#modal-pruning",
    "href": "num_utils.html#modal-pruning",
    "title": "Numerical utilities",
    "section": "Modal pruning",
    "text": "Modal pruning\n\n\npolarisation\n\n polarisation (interpolated_eigenvectors, eigenvectors, h)\n\nThe Modal Assurance Criterion (MAC) between two eigenvectors (mode shapes) \\(\\Phi_i\\) and \\(\\Phi_j\\) is:\n\\[\n\\mathrm{MAC}(\\Phi_i,\\Phi_j) =\n\\frac{|\\Phi_i^{T}\\,\\Phi_j|^{2}}\n    {\\left(\\Phi_i^{T}\\,\\Phi_i\\right)\\,\\left(\\Phi_j^{T}\\,\\Phi_j\\right)}.\n\\]\nMAC measures the degree of similarity (or consistency) between the two mode shapes. A value of 1 indicates identical shapes (up to a scalar), while a value near 0 indicates they are nearly orthogonal.\n\n\n\neigenMAC\n\n eigenMAC (ref_eigenvectors, ref_nx, ref_ny, eigenvectors, eigenvalues,\n           nx, ny, n_modes, Lx, Ly, h)\n\nComputes the Modal Assurance Criterion (MAC) between reference eigenvectors and given eigenvectors.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nref_eigenvectors\nndarray\nReference eigenvectors (reshaped for interpolation).\n\n\nref_nx\nint\nNumber of reference grid points along the x-axis.\n\n\nref_ny\nint\nNumber of reference grid points along the y-axis.\n\n\neigenvectors\nndarray\nEigenvectors to compare against the reference.\n\n\neigenvalues\nndarray\nCorresponding eigenvalues of the eigenvectors.\n\n\nnx\nint\nNumber of grid points along the x-axis for interpolation.\n\n\nny\nint\nNumber of grid points along the y-axis for interpolation.\n\n\nn_modes\nint\nNumber of modes to compare.\n\n\nLx\nfloat\nLength of the domain along the x-axis.\n\n\nLy\nfloat\nLength of the domain along the y-axis.\n\n\nh\n\n\n\n\nReturns\nndarray\nReordered eigenvectors after MAC computation.",
    "crumbs": [
      "Numerical utilities"
    ]
  },
  {
    "objectID": "num_utils.html#biharmonic-decomposition",
    "href": "num_utils.html#biharmonic-decomposition",
    "title": "Numerical utilities",
    "section": "Biharmonic decomposition",
    "text": "Biharmonic decomposition\nComputes the eigenvalue decomposition of the biharmonic operator for the plate:\n\\[\n\\Delta \\Delta \\Phi_p(x, y)=\\frac{\\rho h}{D} \\lambda_p^2 \\Phi_p(x, y) .\n\\]\n\\(\\rho\\), \\(h\\) and \\(D\\) are density, tickness and bending stiffness of the plate, respectively.\n\n\nbiharmonic_eigendecomposition\n\n biharmonic_eigendecomposition (params:vkplatejax.ftm.PlateParameters,\n                                n_modes:int, bcs:numpy.ndarray, nx:int,\n                                ny:int, h:float,\n                                normalise_eigenvectors=True)\n\n*Computes the eigenvalue decomposition of the biharmonic operator for a plate with the given parameters and boundary conditions.\nAdditionally it sorts the eigenvalues and eigenvectors in ascending order, and normalises the eigenvectors if requested.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\nPlateParameters\n\nThe parameters of the plate.\n\n\nn_modes\nint\n\nThe number of modes to compute.\n\n\nbcs\nndarray\n\nThe boundary conditions of the plate.\n\n\nnx\nint\n\nThe number of points in the x direction.\n\n\nny\nint\n\nThe number of points in the y direction.\n\n\nh\nfloat\n\nThe spacing between points.\n\n\nnormalise_eigenvectors\nbool\nTrue\nWhether to normalise the eigenvectors.\n\n\nReturns\nTuple[np.ndarray, np.ndarray, np.ndarray]\n\nThe eigenvalues, eigenvectors and norms of the eigenvectors.\n\n\n\n\n\n\nmultiresolution_eigendecomposition\n\n multiresolution_eigendecomposition (params, n_modes, bcs, h, nx:int,\n                                     ny:int, levels:int=2)\n\n*Runs the biharmonic eigendecomposition and eigenvector alignment on multiple grid resolutions.\nParameters params: Parameters object containing domain lengths (e.g. params.lx and params.ly). n_modes: Number of eigenmodes to compute. bcs: Boundary conditions. h: Initial grid spacing. nx, ny: Initial grid dimensions. levels: Total number of resolutions to run (default 2). The first level is the coarse grid, and each subsequent level uses h/2 and double the grid points to cover the same domain.\nReturns swapped_eigenvectors, swapped_eigenvalues from the last refinement.*",
    "crumbs": [
      "Numerical utilities"
    ]
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "to_db\n\n to_db (x)\n\n\n\n\nimpulse_response\n\n impulse_response (b:jax.Array, a:jax.Array, n=4410)\n\nCompute the impulse response of a discrete time system\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nb\nArray\n\nnumerators of the discrete transfer function\n\n\na\nArray\n\ndenominators of the discrete transfer function\n\n\nn\nint\n4410\n\n\n\nReturns\njnp.ndarray\n\nThe impulse response of the system, with shape (n_modes, n)\n\n\n\n\n\n\neigenMAC\n\n eigenMAC (ref_eigenvectors, ref_nx, ref_ny, eigenvectors, eigenvalues,\n           nx, ny, n_modes, Lx, Ly)\n\n*Computes the Modal Assurance Criterion (MAC) between reference eigenvectors and given eigenvectors.\nParameters: ref_eigenvectors : ndarray Reference eigenvectors (reshaped for interpolation). ref_nx : int Number of reference grid points along the x-axis. ref_ny : int Number of reference grid points along the y-axis. eigenvectors : ndarray Eigenvectors to compare against the reference. eigenvalues : ndarray Corresponding eigenvalues of the eigenvectors. nx : int Number of grid points along the x-axis for interpolation. ny : int Number of grid points along the y-axis for interpolation. n_modes : int Number of modes to compare. Lx : float Length of the domain along the x-axis. Ly : float Length of the domain along the y-axis.\nReturns: eigenvectors_swapped : ndarray Reordered eigenvectors after MAC computation. eigenvalues_swapped : ndarray Reordered eigenvalues after MAC computation.*",
    "crumbs": [
      "Utils"
    ]
  },
  {
    "objectID": "sv.html",
    "href": "sv.html",
    "title": "Stormer-verlet integrators",
    "section": "",
    "text": "The stormer-verlet is a centered difference scheme used to approximate derivatives. In the present case we use it for approximating the second and first derivatives of an oscillator defined by the following differential equation:\n\\[\n\\ddot{q} + c \\dot{q} + k q = f(t)\n\\]\nThe finite difference operators are defined as:\n\\[\n\\begin{align}\n\\delta_t q &= \\frac{q^{n+1} - q^{n-1}}{2 h} \\\\\n\\delta_{tt} q &= \\frac{q^{n+1} - 2 q^n + q^{n-1}}{h^2}\n\\end{align}\n\\]\nfor the first derivative and the second derivative respectively. The difference equation for the oscillator is then:\n\\[\n\\delta_{tt} q + c \\delta_t q + k q = f(t)\n\\]\nafter expanding and some algebraic manipulation to isolate \\(q^{n+1}\\) we get:\n\\[\n\\bigl(\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\bigr)\\,q^{n+1} +\n\\bigl(-\\tfrac{2}{h^2} + k\\bigr) q^n +\n\\bigl(\\tfrac{1}{h^2} - \\tfrac{c}{2h}\\bigr)\\,q^{n-1} =\nf(t^n).\n\\]\n\\[\n\\boxed{\nq^{n+1} = \\frac{2 h^2}{2 + c h}\n\\Bigl[\nf(t^n) + \\Bigl(\\tfrac{2}{h^2} - k\\Bigr) q^n +\n\\Bigl(-\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\Bigr) q^{n-1}\n\\Bigr].\n}\n\\]\nTo make it more readable we can define the following constants:\n\\[\n\\begin{align}\na &= \\frac{2 h^2}{2 + c h} \\\\\nb &= \\frac{2}{h^2} - k \\\\\nc &= -\\frac{1}{h^2} + \\frac{c}{2h}\n\\end{align}\n\\]\nso that the equation becomes:\n\\[\n\\boxed{\nq^{n+1} = a \\Bigl[ f(t^n) + b q^n + c q^{n-1} \\Bigr].\n}\n\\]\nSince we have \\(h^2\\) in the denominator we can multiply the whole equation by \\(h^2\\) to get rid of it. Then the constants become:\n\\[\n\\begin{align}\na &= \\frac{2}{2 + c h} \\\\\nb &= 2 - k h^2 \\\\\nc &= -1 + \\frac{c h}{2}\n\\end{align}\n\\]\nNote that we also need to multiply the forcing term and the eventual non-linear terms by \\(h^2\\). Since we also divide all \\(k\\) and \\(c\\) by \\(\\rho\\) we can define a new constant \\(g = \\frac{h^2}{\\rho}\\) so that the equation becomes:\n\n\nC_vector\n\n C_vector (h, damping)\n\nNote this include the minus side caused by puting this term on the right hand side of the equation. Also this is already multiplied \\(h^2\\)\n\n\n\n\nDetails\n\n\n\n\nh\ntemporal grid spacing (scalar)\n\n\ndamping\ndamping term (vector)\n\n\n\n\n\n\nB_vector\n\n B_vector (h, stiffness)\n\nNote this include the minus side caused by puting this term on the right hand side of the equation. Also this is already multiplied \\(h^2\\)\n\n\n\n\nDetails\n\n\n\n\nh\ntemporal grid spacing (scalar)\n\n\nstiffness\nstiffness term (vector)\n\n\n\n\n\n\nA_inv_vector\n\n A_inv_vector (h, damping)\n\nAlso this is already multiplied \\(h^2\\)\n\n\n\n\nDetails\n\n\n\n\nh\ntemporal grid spacing (scalar)\n\n\ndamping\ndamping term (vector)\n\n\n\n\n\nStormer-verlet for the tension modulated case\n\\[\nD \\Delta \\Delta w + \\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w}- T_0 \\Delta w = f_{ext} - T_{nl} \\Delta w\n\\]\nwe can rearrange the terms to isolate have it in the form:\n\\[\n\\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w} + (D \\Delta \\Delta - T_0 \\Delta) w = f_{ext} - T_{nl} \\Delta w\n\\]\nBy applying the SLT transformation to get rid of the spatial derivatives we get:\n\\[\n\\rho \\ddot{q} + \\left(d_1 + d_3 \\lambda \\right)\\dot{q} + (D \\lambda^2 - T_0 \\lambda) q = f_{ext} - \\bar{T}_{nl} \\lambda q\n\\]\nnow by applying the previously defined differece operators we get:\n$$ q^{n+1} = a .\n$$\nwhere the constants are:\n\\[\n\\begin{align}\na &= g\\left(\\frac{2}{2 + d_1 + d_3 \\lambda h}\\right) \\\\\nb &= g\\left(2 -  D \\lambda^2 - T_0 \\lambda h^2\\right) \\\\\nc &= g\\left(-1 +  \\frac{d_1 + d_3 \\lambda h}{2}\\right)\n\\end{align}\n\\]\nwe know that \\(\\bar{T}_{N L}(q)=\\frac{1}{2} \\frac{E A}{L} \\sum_\\eta \\frac{\\lambda_\\eta q_\\eta^2(t)}{\\left\\|K_\\eta\\right\\|_2^2}\\) from Avanzini and Trautmann.\n\n\n\nsolve_sv_berger_jax_scan\n\n solve_sv_berger_jax_scan (A_inv:jax.Array, B:jax.Array, C:jax.Array,\n                           modal_excitation:jax.Array,\n                           lambda_mu:jax.Array, factors:jax.Array,\n                           g:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nA_inv\nArray\n\n\n\nB\nArray\n\n\n\nC\nArray\n\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\nlambda_mu\nArray\n\n\n\nfactors\nArray\n\n\n\ng\nfloat\nfactor for the input\n\n\n\n\n# # | export\n\n\n# @jax.jit\n# def solve_sv_vk_jax_scan(\n#     A_inv: jnp.ndarray,\n#     B: jnp.ndarray,\n#     C: jnp.ndarray,\n#     modal_excitation: jnp.ndarray,  # (T, n_modes)\n#     Hv: jnp.ndarray,\n#     zetafourth: jnp.ndarray,\n#     C_NL: float,\n#     g: float,  # factor for the input\n# ):\n#     n_modes = A_inv.shape[0]\n#     q = jnp.zeros((n_modes,))  # Modal displacement vector at n (n_modes, 1)\n#     q_prev = jnp.zeros((n_modes,))  # Modal displacement vector at n-1\n\n#     # precompute Hv divided by the eigenvalues to make it a bit faster\n#     Hva = Hv / (2.0 * zetafourth)\n\n#     def advance_state(\n#         state: jnp.ndarray,  # inital state\n#         x: jnp.ndarray,  # input\n#     ) -&gt; tuple[jnp.ndarray, jnp.ndarray]:  # carry, output\n#         # unpack state\n#         q_prev, q = state\n\n#         nl = C_NL * einops.einsum(\n#             Hva,\n#             Hv,\n#             q,\n#             q,\n#             q,\n#             \"m i j, k l j, i, k, l -&gt; m\",\n#         )\n#         # compute the next state\n#         q_next = A_inv * (B * q + C * q_prev - g * nl + g * x)\n\n#         # return the next state and the output\n#         return (q, q_next), q_next\n\n#     state, final = jax.lax.scan(\n#         advance_state,\n#         (q_prev, q),\n#         modal_excitation,  # (T, n_modes)\n#         unroll=8,\n#     )\n#     return state, final\n\n\n\n\nsolve_sv_vk_jax_scan\n\n solve_sv_vk_jax_scan (A_inv:jax.Array, B:jax.Array, C:jax.Array,\n                       modal_excitation:jax.Array, Hv:jax.Array, g:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nA_inv\nArray\n\n\n\nB\nArray\n\n\n\nC\nArray\n\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\nHv\nArray\n\n\n\ng\nfloat\nfactor for the input",
    "crumbs": [
      "Stormer-verlet integrators"
    ]
  },
  {
    "objectID": "excitations.html",
    "href": "excitations.html",
    "title": "Excitation functions",
    "section": "",
    "text": "import matplotlib.pyplot as plt\n\n\n\ncreate_1d_raised_cosine\n\n create_1d_raised_cosine (duration:float, start_time:float,\n                          end_time:float, amplitude:float,\n                          sample_rate:float)\n\nCreate a 1D raised cosine excitation with time parameters in seconds.\n\n\n\n\nType\nDetails\n\n\n\n\nduration\nfloat\nTotal duration of the excitation (in seconds).\n\n\nstart_time\nfloat\nStart time of the excitation (in seconds).\n\n\nend_time\nfloat\nEnd time of the excitation (in seconds).\n\n\namplitude\nfloat\nAmplitude of the excitation.\n\n\nsample_rate\nfloat\nSample rate (samples per second).\n\n\nReturns\nndarray\nThe excitation signal.\n\n\n\n\nrc = create_1d_raised_cosine(\n    1,\n    0.01,\n    0.05,\n    1,\n    44100,\n)\n\nplt.plot(rc)\n\n\n\n\n\n\n\n\n\n\n\ncreate_raised_cosine\n\n create_raised_cosine (Nx, Ny, h, ctr, epsilon, wid)\n\n*Create a raised cosine function on a 2D grid.\nParameters: Nx (int): Number of grid points in the x-direction. Ny (int): Number of grid points in the y-direction. h (float): Grid spacing. ctr (tuple): Center of the raised cosine (x, y). epsilon (float): Scaling parameter. wid (float): Width of the cosine.\nReturns: np.ndarray: Flattened raised cosine array.*\n\nfrom matplotlib import pyplot as plt\n\n\n# Example usage\nNx, Ny = 25, 21  # Grid dimensions\nh = 0.0438  # Grid spacing\nctr = (0.5, 0.5)  # Center of the raised cosine\nepsilon = 1.2000  # Scaling parameter\nwid = 0.3  # Width of the cosine\n\nrc, X, Y, dist, distx, disty = create_raised_cosine(\n    Nx,\n    Ny,\n    h,\n    ctr,\n    epsilon,\n    wid,\n)\n\nplt.imshow(rc, cmap=\"gray\", origin=\"lower\")\n\n\n\n\n\n\n\n\n\n\n\ncreate_pluck_modal\n\n create_pluck_modal (lambdas:numpy.ndarray, pluck_position:float=0.28,\n                     initial_deflection:float=0.03,\n                     string_length:float=1.0)\n\nCreate a pluck excitation for a string with a given length and pluck position. The pluck is modeled in the modal domain.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlambdas\nndarray\n\neigenvalues of the Laplacian operator\n\n\npluck_position\nfloat\n0.28\nposition of pluck on the string in meters\n\n\ninitial_deflection\nfloat\n0.03\ninitial deflection of the string in meters\n\n\nstring_length\nfloat\n1.0\ntotal length of the string in meters\n\n\nReturns\nndarray\n\nThe pluck excitation in the modal domain.",
    "crumbs": [
      "Excitation functions"
    ]
  },
  {
    "objectID": "coupling.html",
    "href": "coupling.html",
    "title": "Coupling functions",
    "section": "",
    "text": "assemble_K_and_M (Npsi, Lx, Ly)\n\n\n\n\n\n\n build_I4 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int4(m,p,L).\n\n\n\n\n\n build_I2 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int2(m,p,L).\n\n\n\n\n\n build_I1 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int1(m,p,L).\n\n\n\n\n\n int2_mat (N, L)\n\nBuilds the N x N matrix whose (m,p) entry is int2(m,p,L). Mirrors the logic of the original Matlab int2_mat function exactly, but we can do it more simply by calling int2 in a loop.\n\n\n\n\n\n int2 (m, p, L)\n\nFunction int2(m,p,L). Piecewise definition from the Matlab code.\n\n\n\n\n\n int1 (m, p, L)\n\nFunction int1(m,p,L). Piecewise definition from the Matlab code.\n\n\n\n\n\n int4 (m, p, L)\n\nIntegral of Xd(m,x)Xd(p,x) from 0 to L, where X is the clamped-plate function and d denotes derivative in x. Piecewise definition follows the original Matlab code exactly.*\n\n\n\n\n\n airy_stress_coefficients (n_psi, vals, vecs)\n\nCompute the Airy stress function coefficients from the eigenvalues and eigenvectors",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "href": "coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "title": "Coupling functions",
    "section": "",
    "text": "assemble_K_and_M (Npsi, Lx, Ly)\n\n\n\n\n\n\n build_I4 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int4(m,p,L).\n\n\n\n\n\n build_I2 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int2(m,p,L).\n\n\n\n\n\n build_I1 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int1(m,p,L).\n\n\n\n\n\n int2_mat (N, L)\n\nBuilds the N x N matrix whose (m,p) entry is int2(m,p,L). Mirrors the logic of the original Matlab int2_mat function exactly, but we can do it more simply by calling int2 in a loop.\n\n\n\n\n\n int2 (m, p, L)\n\nFunction int2(m,p,L). Piecewise definition from the Matlab code.\n\n\n\n\n\n int1 (m, p, L)\n\nFunction int1(m,p,L). Piecewise definition from the Matlab code.\n\n\n\n\n\n int4 (m, p, L)\n\nIntegral of Xd(m,x)Xd(p,x) from 0 to L, where X is the clamped-plate function and d denotes derivative in x. Piecewise definition follows the original Matlab code exactly.*\n\n\n\n\n\n airy_stress_coefficients (n_psi, vals, vecs)\n\nCompute the Airy stress function coefficients from the eigenvalues and eigenvectors",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "href": "coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "title": "Coupling functions",
    "section": "Basis used to build the mass and stiffness matrices",
    "text": "Basis used to build the mass and stiffness matrices\n\n\nbasis\n\n basis (m, n, x, y, Lx, Ly)\n\nEvaluate the full 2D basis function for indices (m, n) at point (x, y). This is simply X_m(x)Y_n(y).*",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "href": "coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "Partial integrals to calculate the coupling matrix",
    "text": "Partial integrals to calculate the coupling matrix\n\n\ni13_mat\n\n i13_mat (Npsi, Nphi, L)\n\n\n\n\ni12_mat\n\n i12_mat (Npsi, Nphi, L)\n\n\n\n\ni11_mat\n\n i11_mat (Npsi, Nphi, L)\n\n\n\n\ni10_mat\n\n i10_mat (Npsi, Nphi, L)\n\n\n\n\ni9_mat\n\n i9_mat (Npsi, Nphi, L)\n\n\n\n\ni5_mat\n\n i5_mat (Npsi, Nphi, L)\n\n\n\n\ni4_mat\n\n i4_mat (Npsi, Nphi, L)\n\nAuxiliary integral for the computation of the coupling coefficient H.\n\n\n\ni3_mat\n\n i3_mat (Npsi, Nphi, L)\n\nAuxiliary integral for the computation of the coupling coefficient H.\n\n\n\ni2_mat\n\n i2_mat (Npsi, Nphi, L)\n\n\n\n\ni1_mat\n\n i1_mat (Npsi, Nphi, L)",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#functions-to-put-together-the-coupling-matrix",
    "href": "coupling.html#functions-to-put-together-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "functions to put together the coupling matrix",
    "text": "functions to put together the coupling matrix\n\n\ng6\n\n g6 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng5\n\n g5 (Npsi, Nphi, S, kx, cache)\n\n\n\n\ng4\n\n g4 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng3\n\n g3 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng2\n\n g2 (Npsi, Nphi, S, kx, cache)\n\n\n\n\ng1\n\n g1 (Npsi, Nphi, S, kx, cache)\n\n\n\n\nbuild_s_matrix\n\n build_s_matrix (Npsi, Nphi, partials, idx_array, factor_mode)\n\nSummation of partial integrals in a 3D array with a factor.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nNpsi\n\n\n\n\nNphi\n\n\n\n\npartials\n\n\n\n\nidx_array\n\n\n\n\nfactor_mode\n\n\n\n\nReturns\nnp.ndarray of shape (Npsi, Nphi, Nphi)\nThe 3D tensor after summation and factor application.\n\n\n\n\n\n\ncompute_partial_integrals\n\n compute_partial_integrals (Npsi, Nphi, Lx, Ly)\n\nPrecompute and store all partial-integral matrices needed. Returns them in a dictionary or a custom object.\n\n\n\nH_tensor_rectangular\n\n H_tensor_rectangular (coeff0, coeff1, coeff2, Nphi, Npsi, Lx, Ly, kx, ky)\n\nCompute the H tensor for rectangular plates.\n\n\n\ncompute_coupling_matrix\n\n compute_coupling_matrix (n_psi, n_phi, lx, ly, kx_indices, ky_indices)",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "vkplatejax",
    "section": "",
    "text": "This code is based on the matlab implementation of the Von Karman plate model found here.\nTo run the time integration of the Von Karman plate model using JAX, the coupling coefficients and the eigenmodes of the plate are precomputed using the matlab implementation.\nExample matrices can be downloaded with the following command:",
    "crumbs": [
      "vkplatejax"
    ]
  },
  {
    "objectID": "index.html#installation-for-development",
    "href": "index.html#installation-for-development",
    "title": "vkplatejax",
    "section": "Installation for Development",
    "text": "Installation for Development\nIt is strongly recommended to use the uv package manager to install the environment and dependencies.\nuv sync --all-extras\notherwise you can create a virtual environment and install the dependencies manually:\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e .",
    "crumbs": [
      "vkplatejax"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "vkplatejax",
    "section": "How to use",
    "text": "How to use\nOnce everything is installed, you can run the vkplate_opt.ipynb notebook.",
    "crumbs": [
      "vkplatejax"
    ]
  },
  {
    "objectID": "ftm.html",
    "href": "ftm.html",
    "title": "Funtional Transformation Method Utilities",
    "section": "",
    "text": "This notebook contains a set of utility functions for the functional transformation method.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#parameters",
    "href": "ftm.html#parameters",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nn_max_modes_x: int The number of modes in the x direction. n_max_modes_y: int The number of modes in the y direction. l1: float The width of the plate. l2: float The height of the plate.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#returns",
    "href": "ftm.html#returns",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\nwn_x: np.ndarray The wavenumbers in the x direction. wn_y: np.ndarray The wavenumbers in the y direction*\n\nimport matplotlib.pyplot as plt\n\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nCompute the modes of the drumhead.\nThe modes of the drumhead are given by the Bessel function times the sine/cosine of the angle....\n  else: warn(msg)\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nCompute the modes of the drumhead.\nThe modes of the drumhead are given by the Bessel function times the sine/cosine of the angle....\n  else: warn(msg)\n\n\ndrumhead_eigenfunctions\n\n drumhead_eigenfunctions (wavenumbers:numpy.ndarray, r:numpy.ndarray,\n                          theta:numpy.ndarray)\n\n*Compute the modes of the drumhead. The modes of the drumhead are given by the Bessel function times the sine/cosine of the angle.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#parameters-1",
    "href": "ftm.html#parameters-1",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nwavenumbers: np.ndarray The wavenumbers for the drumhead. r: np.ndarray Radial grid points. theta: np.ndarray Angular grid points.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#returns-1",
    "href": "ftm.html#returns-1",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\nmodes: np.ndarray The eigenfunctions for the drumhead.*\n\n\n\n\nType\nDetails\n\n\n\n\nwavenumbers\nndarray\n(n_max_modes, m_max_modes)\n\n\nr\nndarray\n(n_gridpoints_r)\n\n\ntheta\nndarray\n(n_gridpoints_theta)\n\n\nReturns\nndarray\n\n\n\n\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nCompute the eigenvalues of the drumhead.\nThe eigenvalues of the drumhead are given by the square of the wavenumbers....\n  else: warn(msg)\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nCompute the eigenvalues of the drumhead.\nThe eigenvalues of the drumhead are given by the square of the wavenumbers....\n  else: warn(msg)\n\n\ndrumhead_eigenvalues\n\n drumhead_eigenvalues (wavenumbers:numpy.ndarray)\n\n*Compute the eigenvalues of the drumhead. The eigenvalues of the drumhead are given by the square of the wavenumbers.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#parameters-2",
    "href": "ftm.html#parameters-2",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nwavenumbers: np.ndarray The wavenumbers for the drumhead. squared: bool If True, return the squared eigenvalues.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#returns-2",
    "href": "ftm.html#returns-2",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\neigenvalues: np.ndarray The eigenvalues of the drumhead.*\n\n\n\n\nType\nDetails\n\n\n\n\nwavenumbers\nndarray\n(n_max_modes, m_max_modes)\n\n\n\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nCompute the wavenumbers of the drumhead.\n...\n  else: warn(msg)\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nCompute the wavenumbers of the drumhead.\n...\n  else: warn(msg)\n\n\ndrumhead_wavenumbers\n\n drumhead_wavenumbers (n_max_modes:int, m_max_modes:int, radius:float)\n\n*Compute the wavenumbers of the drumhead.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#parameters-3",
    "href": "ftm.html#parameters-3",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nn_max_modes: int The number of angular modes. m_max_modes: int The number of radial modes. radius: float The radius of the drumhead.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "ftm.html#returns-3",
    "href": "ftm.html#returns-3",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\nwavenumbers: np.ndarray The wavenumbers for the drumhead.*\n\n\ndblintegral\n\n dblintegral (integrand, x, y, method='simpson')\n\nCompute the double integral of a function K over the domain x and y.\n\n# Example usage\nn_max_modes = 25\nm_max_modes = 25\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert K_inv.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\nassert K_fwd.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\n\\[\nK_{n,m}(r, \\varphi) = \\cos (n \\varphi) J_n\\left(\\mu_{n, m} \\frac{r}{R}\\right)\n\\]\nwhere \\(J_n\\) is the Bessel function of the first kind of order \\(n\\), and \\(\\mu_{n, m}\\) is the \\(m\\)-th root of the \\(n\\)-th order Bessel function of the first kind.\n\nn_max_modes_x = 6\nn_max_modes_y = 6\nn_gridpoints_x = 20\nn_gridpoints_y = 20\nlength_x = 1.08\nlength_y = 1.08\ngrid_x = np.linspace(0, length_x, n_gridpoints_x)\ngrid_y = np.linspace(0, length_y, n_gridpoints_y)\n\n# slow version\n# Define the range for n and m\nn_values = np.arange(1, n_max_modes_x + 1)\nm_values = np.arange(1, n_max_modes_y + 1)\n\n# Define the range for x and y\nx_values = np.linspace(0, length_x, n_gridpoints_x)\ny_values = np.linspace(0, length_y, n_gridpoints_y)\n\n# Initialize the 4D array to store the results\nK = np.zeros((len(n_values), len(m_values), len(x_values), len(y_values)))\nLambda = np.zeros((len(n_values), len(m_values)))\n# Compute the values\nfor i, n in enumerate(n_values):\n    for j, m in enumerate(m_values):\n        Lambda[i, j] = np.pi**2 * ((n / length_x) ** 2 + (m / length_y) ** 2)\n        for k, x in enumerate(x_values):\n            for l, y in enumerate(y_values):\n                K[i, j, k, l] = np.sin(n * np.pi * x / length_x) * np.sin(\n                    m * np.pi * y / length_y\n                )\n\n\nwnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, length_x, length_y)\nassert np.allclose(plate_eigenfunctions(wnx, wny, grid_x, grid_y), K)\nassert np.allclose(plate_eigenvalues(wnx, wny), Lambda)\n\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:\n  else: warn(msg)\n/home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\n\n\ninverse_STL\n\n inverse_STL (K:numpy.ndarray, u_bar:numpy.ndarray, length:float)\n\nCompute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes, n_gridpoints)\n\n\nu_bar\nndarray\n(n_modes, n_samples) or (n_modes,)\n\n\nlength\nfloat\nlength of the string\n\n\nReturns\nndarray\n\n\n\n\n\n\n\nforward_STL\n\n forward_STL (K:numpy.ndarray, u:numpy.ndarray, dx:float)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes, n_gridpoints)\n\n\nu\nndarray\n(n_gridpoints, n_samples) or (n_gridpoints,)\n\n\ndx\nfloat\ngrid spacing\n\n\nReturns\nndarray\nThe transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n\n\n\n\n\n\ninverse_STL_2d\n\n inverse_STL_2d (K:numpy.ndarray, u_bar:numpy.ndarray, l1:float, l2:float)\n\nCompute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu_bar\nndarray\n(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n\n\nl1\nfloat\nlength in x\n\n\nl2\nfloat\nlength in y\n\n\nReturns\nndarray\nThe reconstructed signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n\n\n\n\n\n\nforward_STL_2d\n\n forward_STL_2d (K:numpy.ndarray, u:numpy.ndarray, x:float, y:float,\n                 use_simpson:bool=False)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nK\nndarray\n\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu\nndarray\n\n(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n\n\nx\nfloat\n\ngrid spacing\n\n\ny\nfloat\n\ngrid spacing\n\n\nuse_simpson\nbool\nFalse\n\n\n\nReturns\nndarray\n\nThe transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n\n\n\n\n\n\nevaluate_rectangular_eigenfunctions\n\n evaluate_rectangular_eigenfunctions (mn_indices:numpy.ndarray,\n                                      position:numpy.ndarray,\n                                      params:__main__.PlateParameters)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmn_indices\nndarray\n(n_modes, 2) selected mode indices\n\n\nposition\nndarray\n(2,) position to evaluate the eigenfunctions\n\n\nparams\nPlateParameters\n\n\n\nReturns\nndarray\n(n_modes,) mode gains of selected modes at the given position\n\n\n\n\nlength_x = 1.08\nlength_y = 0.8\nn_max_modes_x = 25\nn_max_modes_y = 25\nn_gridpoints_x = 100\nn_gridpoints_y = 100\n\nx = np.linspace(0, length_x, n_gridpoints_x)\ny = np.linspace(0, length_y, n_gridpoints_y)\n\nwnx, wny = plate_wavenumbers(\n    n_max_modes_x,\n    n_max_modes_y,\n    length_x,\n    length_y,\n)\nK = plate_eigenfunctions(wnx, wny, x, y)\n\ng = 0.5 * K[2, 2] + 0.5 * K[3, 3]\n\nbar_g = forward_STL_2d(K, g, x, y, use_simpson=True)\ng_reconstructed = inverse_STL_2d(K, bar_g, length_x, length_y)\n\nassert np.allclose(g, g_reconstructed, atol=1e-2)\n\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\n\nax[0].imshow(g, origin=\"lower\", aspect=\"auto\")\nax[0].set_title(\"Original excitation\")\nax[1].imshow(g_reconstructed, origin=\"lower\", aspect=\"auto\")\nax[1].set_title(\"Reconstructed excitation\")\n\n\n\n\ninverse_STL_drumhead\n\n inverse_STL_drumhead (K_inv:numpy.ndarray, u_bar:numpy.ndarray)\n\nCompute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK_inv\nndarray\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu_bar\nndarray\n(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n\n\nReturns\nndarray\n\n\n\n\n\n\n\nforward_STL_drumhead\n\n forward_STL_drumhead (K:numpy.ndarray, u:numpy.ndarray, r:numpy.ndarray,\n                       theta:numpy.ndarray, use_simpson:bool=False)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule or Simpson’s rule.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nK\nndarray\n\n(n_modes_r, n_modes_theta, n_gridpoints_r, n_gridpoints_theta)\n\n\nu\nndarray\n\n(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n\n\nr\nndarray\n\nradial grid\n\n\ntheta\nndarray\n\nangular grid\n\n\nuse_simpson\nbool\nFalse\n\n\n\nReturns\nndarray\n\n\n\n\n\n\n# Example usage\nn_max_modes = 10\nm_max_modes = 10\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert np.allclose(\n    K_fwd.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\nassert np.allclose(\n    K_inv.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\n\n# Create an example g array to test the transforms\ng = K_fwd[3, 3]\n\nbar_g = forward_STL_drumhead(K_fwd, g, r, theta, use_simpson=False)\ng_reconstructed = inverse_STL_drumhead(K_inv, bar_g)\n\n# Verify if g can be reconstructed\nassert np.allclose(g, g_reconstructed, atol=1e-2)\nprint(g.min(), g.max())\nprint(g_reconstructed.min(), g_reconstructed.max())\n\n# Plot using pcolormesh\nfig, ax = plt.subplots(\n    1,\n    2,\n    subplot_kw={\"projection\": \"polar\"},\n    figsize=(10, 5),\n)\nc = ax[0].pcolormesh(theta, r, g, shading=\"auto\", cmap=\"viridis\")\nc = ax[1].pcolormesh(theta, r, g_reconstructed, shading=\"auto\", cmap=\"viridis\")\n\n\n\n\nstiffness_term\n\n stiffness_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)\n\n\n\n\ndamping_term_simple\n\n damping_term_simple (lambda_mu:jax.Array, factor:float=0.001)\n\n\n\n\ndamping_term\n\n damping_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)\n\n\n\n\neigenvalues_from_pde\n\n eigenvalues_from_pde (pars:__main__.PhysicalParameters,\n                       lambda_mu:jax.Array)\n\nCompute the positive imaginary side of the eigenvalues of the continuous-time system from the PDE parameters.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npars\nPhysicalParameters\nThe physical parameters of the system.\n\n\nlambda_mu\nArray\nThe eigenvalues of the decompostion of the Laplacian operator.\n\n\nReturns\nArray\nThe eigenvalues of the continuous-time system.\n\n\n\n\nfrom IPython.display import Audio\n\n\nn_max_modes = 50\nsr = 44100\ndt = 1 / sr\nfinal_time = 1.0\nn_samples = int(final_time / dt)\np_params = StringParameters()\nwn = string_eigenvalues_sqrt(n_max_modes, p_params.length)\neigvals = eigenvalues_from_pde(p_params, wn)\n\nprint(eigvals.imag.min() / (2 * np.pi))\n\neigvals_d = np.exp(eigvals * dt)\n\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\ndisplay(Audio(states.sum(0), rate=sr))\n\n\n\n\neigenvalues_from_plate_pde\n\n eigenvalues_from_plate_pde (platepars:__main__.PlateParameters,\n                             wnx:numpy.ndarray, wny:numpy.ndarray)\n\nCompute the positive imaginary side of the eigenvalues of the continuous-time system from the PDE parameters of the rectangular plate. From 5.96 of Digital Sound Synthesis using the FTM, and Eq. 8 of TENSION MODULATED NONLINEAR 2D MODELS FOR DIGITAL SOUND SYNTHESIS WITH THE FUNCTIONAL TRANSFORMATION METHOD.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nplatepars\nPlateParameters\n\n\n\nwnx\nndarray\nwavenumbers x (n_max_modes_x,)\n\n\nwny\nndarray\nwavenumbers y (n_max_modes_y,)\n\n\nReturns\nndarray\nThe eigenvalues of the continuous-time system.\n\n\n\n\nn_max_modes_x = 20\nn_max_modes_y = 20\nsr = 44100\ndt = 1 / sr\nfinal_time = 6.0\nn_samples = int(final_time / dt)\n\np_params = PlateParameters()\nwnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.l1, p_params.l2)\neigvals = eigenvalues_from_plate_pde(p_params, wnx, wny).reshape(-1)\n\nprint(eigvals.imag.min() / (2 * np.pi))\neigvals_d = np.exp(eigvals * dt)\n\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\ndisplay(Audio(states.sum(0), rate=sr))\n\n\n\n\neigenvalues_from_drumhead_pde\n\n eigenvalues_from_drumhead_pde\n                                (drumhead_pars:__main__.CircularDrumHeadPa\n                                rameters, Lambda_nm:numpy.ndarray)\n\nCompute the positive imaginary side of the eigenvalues of the continuous-time system from the PDE parameters of the rectangular plate. From 5.96 of Digital Sound Synthesis using the FTM, and Eq. 8 of TENSION MODULATED NONLINEAR 2D MODELS FOR DIGITAL SOUND SYNTHESIS WITH THE FUNCTIONAL TRANSFORMATION METHOD.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndrumhead_pars\nCircularDrumHeadParameters\n\n\n\nLambda_nm\nndarray\n(n_max_modes_r, m_max_modes_theta)\n\n\nReturns\nndarray\nThe eigenvalues of the continuous-time system.\n\n\n\n\nn_max_modes_x = 20\nn_max_modes_y = 20\nsr = 44100\ndt = 1 / sr\nfinal_time = 2.0\nn_samples = int(final_time / dt)\np_params = CircularDrumHeadParameters.avanzini()\n\nv = drumhead_eigenvalues(\n    drumhead_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.r0)\n)\neigvals = eigenvalues_from_drumhead_pde(p_params, v).reshape(-1)\n\n# import matplotlib.pyplot as plt\nprint(eigvals.imag.min() / (2 * np.pi))\nprint(eigvals.imag.max() / (2 * np.pi))\n# plt.plot(eigvals)\n\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\n# fig, ax = plt.subplots(1, 1, figsize=(10, 5))\n# ax.plot(states[0])\ndisplay(Audio(states[0], rate=sr))\n\n\n\n\nsample_parallel_tf\n\n sample_parallel_tf (num:numpy.ndarray, den:numpy.ndarray, dt:float,\n                     method:str='impulse')\n\nSample a parallel transfer function using the impulse invariant method.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnum\nndarray\n\n(n_modes,)\n\n\nden\nndarray\n\n(n_modes,)\n\n\ndt\nfloat\n\n\n\n\nmethod\nstr\nimpulse\n\n\n\nReturns\nnp.ndarray\n\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_continuous_2\n\n tf_initial_conditions_continuous_2 (D:float, density:float, d1:float,\n                                     d3:float, Ts0:float,\n                                     lambda_mu:&lt;function array&gt;)\n\nConpute the continuous-time initial condition transfer function. This is an alternative to the function tf_initial_conditions_continuous that eigenvalues of the PDE as input.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nD\nfloat\nThe bending stiffness of the string or plate.\n\n\ndensity\nfloat\nThe area or surface density of the string or plate.\n\n\nd1\nfloat\nThe linear damping coefficient, or frequency-independent damping.\n\n\nd3\nfloat\nThe cubic damping coefficient, or frequency-dependent damping.\n\n\nTs0\nfloat\nThe initial tension of the string or plate.\n\n\nlambda_mu\narray\nThe eigenvalues from the decomposition of the Laplacian operator.\n\n\nReturns\ntuple\nThe numerator and denominator of the transfer function.\n\n\n\n\n\n\ntf_excitation_discrete\n\n tf_excitation_discrete (eigenvalues:numpy.ndarray, density:float,\n                         dt:float)\n\nCompute the discrete-time excitation transfer function of a system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndensity\nfloat\nsurface or area density\n\n\ndt\nfloat\ntime step\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_excitation_continuous\n\n tf_excitation_continuous (eigenvalues:numpy.ndarray, density:float)\n\nCompute the continuous excitation transfer function.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndensity\nfloat\nsurface or area density\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_discrete\n\n tf_initial_conditions_discrete (eigenvalues:numpy.ndarray, dt:float)\n\nCompute the discrete-time initial conditions transfer function of a system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndt\nfloat\ntime step\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_continuous\n\n tf_initial_conditions_continuous (eigenvalues:numpy.ndarray)\n\nCompute the continuos “initial-conditions” transfer function from the eigenvalues of the system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\nb, a = tf_excitation_discrete(eigvals, p_params.surface_density, dt)\nb_ic, a_ic = tf_initial_conditions_discrete(eigvals, dt)\n\n# manual discretization\neigenvalues_d = np.exp(eigvals * dt)\n\n# for the excitation tf\nb1 = (\n    np.exp(eigvals.real * dt)\n    * np.sin(eigvals.imag * dt)\n    / eigvals.imag\n    / p_params.surface_density\n)\n\n# for the initial conditions tf\n# here we ignore initial velocity\nr = np.exp(eigvals.real * dt)\nb1_ic = r * np.sin(eigvals.imag * dt) / eigvals.imag * -eigvals.real - r * np.cos(\n    eigvals.imag * dt\n)\n\na1 = -2 * np.exp(eigvals.real * dt) * np.cos(eigvals.imag * dt)\na2 = np.exp(2 * eigvals.real * dt)\nb_manual = np.stack([np.zeros_like(b1), b1, np.zeros_like(b1)], axis=-1) * dt\na_manual = np.stack([np.ones_like(a1), a1, a2], axis=-1)\n\nb_ic_manual = np.stack([np.ones_like(b1_ic), b1_ic], axis=-1) * dt\n\nprint(b[0])\nprint(b_manual[0])\nprint(b_ic[0] * sr)\nprint(b_ic_manual[0] * sr)\nassert np.allclose(b[:, 1], b_manual[:, 1])\nassert np.allclose(a, a_manual)\nassert np.allclose(b_ic[:, :2], b_ic_manual[:, :2])\n\n\n\n\ntf_freqs\n\n tf_freqs (b:jax.Array, a:jax.Array, s:jax.Array)\n\nCompute the frequency response of a transfer function.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nb\nArray\nnumerator (n_modes, 2)\n\n\na\nArray\ndenominator (n_modes, 3)\n\n\ns\nArray\nfrequency (n_freqs,)\n\n\nReturns\nArray\nThe frequency response of the transfer function.",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "losses.html",
    "href": "losses.html",
    "title": "Losses",
    "section": "",
    "text": "import matplotlib.pyplot as plt\n\n\n\nwasserstein_1d\n\n wasserstein_1d (u_values, v_values, u_weights=None, v_weights=None, p=1,\n                 require_sort=True)\n\n*Computes the 1 dimensional OT loss [15] between two (batched) empirical distributions\n.. math: OT_{loss} = _0^1 |cdf_u^{-1}(q) - cdf_v{-1}(q)|p dq\nIt is formally the p-Wasserstein distance raised to the power p. We do so in a vectorized way by first building the individual quantile functions then integrating them.\nThis function should be preferred to emd_1d whenever the backend is different to numpy, and when gradients over either sample positions or weights are required.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nu_values\n\n\n\n\n\nv_values\n\n\n\n\n\nu_weights\nNoneType\nNone\n\n\n\nv_weights\nNoneType\nNone\n\n\n\np\nint\n1\n\n\n\nrequire_sort\nbool\nTrue\n\n\n\nReturns\ncost: float/array-like, shape (…)\n\nthe batched EMD\n\n\n\n\n\n\nquantile_function\n\n quantile_function (qs, cws, xs)\n\nComputes the quantile function of an empirical distribution\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nqs\n\n\n\n\ncws\n\n\n\n\nxs\n\n\n\n\nReturns\nq: array-like, shape (…, n)\nThe quantiles of the distribution\n\n\n\n\n\n\ncompute_mag\n\n compute_mag (x:jax.Array)\n\n\n\n\n\nType\nDetails\n\n\n\n\nx\nArray\n(b, t)\n\n\nReturns\nArray\n\n\n\n\n\n\n\nspectral_wasserstein\n\n spectral_wasserstein (x, y, squared=True, is_mag=False)\n\n\n\n\nlog_mag_loss\n\n log_mag_loss (pred:jax.Array, target:jax.Array, eps:float=1e-10,\n               distance:str='l1')\n\nSpectral log magtinude loss but for a fft of a signal See Arik et al., 2018\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npred\nArray\n\ncomplex valued fft of the signal\n\n\ntarget\nArray\n\ncomplex valued fft of the signal\n\n\neps\nfloat\n1e-10\n\n\n\ndistance\nstr\nl1\n\n\n\n\n\n\n\nlog_mag\n\n log_mag (x:jax.Array, eps:float=1e-10)\n\n\nphase = 0.0\nomegas = jax.random.uniform(jax.random.PRNGKey(0), shape=(10,)) * 100\nmag = 1.0\n\n\ndef osc_bank(t, omegas):\n    return mag * jnp.sin(omegas[..., None] * jnp.pi * 2 * t[None] + phase)\n\n\nt = jnp.linspace(0, 1, 1000)\ngt_osc_values = osc_bank(t, omegas)\nprint(gt_osc_values.shape)\n\n(10, 1000)\n\n\n\na = jax.vmap(spectral_wasserstein)(gt_osc_values, gt_osc_values)\nprint(a)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\ndef loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n    x_fft = compute_mag(gt_osc_values)\n    y_fft = compute_mag(pred_osc_values)\n    l2_mag_loss = jnp.mean((x_fft - y_fft) ** 2)\n    return l2_mag_loss\n\n\ndef ot_loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n\n    ot_loss = jnp.mean(\n        jax.vmap(spectral_wasserstein)(gt_osc_values, pred_osc_values),\n    )\n    return ot_loss\n\n\nx_fft = compute_mag(gt_osc_values) ** 2\nplt.plot(x_fft[:5].T)\n\n\n\n\n\n\n\n\n\nranges = jnp.linspace(-50, 50, 100)\nomegas_scan = omegas + ranges[:, None]\n\n# print(omegas_scan.shape)\nloss, grad = jax.vmap(jax.value_and_grad(loss_fn))(omegas_scan)\nloss_ot, grad_ot = jax.vmap(jax.value_and_grad(ot_loss_fn))(omegas_scan)\n\nprint(loss.shape, loss.dtype)\nprint(loss_ot.shape, loss_ot.dtype)\n# loss_mean = jnp.mean(loss, axis=1)\n# loss_ot_mean = jnp.mean(loss_ot, axis=-1)\n# print(loss_mean.shape)\nplt.plot(ranges, loss)\nplt.plot(ranges, loss_ot)\n\n(100,) float32\n(100,) float32\n\n\n\n\n\n\n\n\n\n\n\n\nspectral_convergence_loss\n\n spectral_convergence_loss (pred:jax.Array, target:jax.Array)\n\nSpectral convergence loss but for a fft of a signal See Arik et al., 2018\n\n\n\n\nType\nDetails\n\n\n\n\npred\nArray\ncomplex valued fft of the signal\n\n\ntarget\nArray\ncomplex valued fft of the signal",
    "crumbs": [
      "Losses"
    ]
  }
]