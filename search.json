[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "jaxdiffmodal",
    "section": "",
    "text": "Fast, differentiable, and GPU-accelerated simulation framework for modelling the dynamics of strings, membranes, and plates using modal methods implemented in JAX.\n\n\n\nDifferentiable implementation using JAX\nSimulates linear and nonlinear models:\n\nTension-modulated string (Kirchhoff–Carrier)\nTension-modulated membrane (Berger model)\nvon Kármán nonlinear plate\n\nFast GPU-accelerated time integration\nDesigned for real-time synthesis, inverse modelling, and dataset generation\nIncludes example notebooks to reproduce results from the paper\n\n\n\n\nIt is recommended to use the uv package manager to install the environment and dependencies.\nuv sync --all-extras\notherwise you can create a virtual environment and install the dependencies manually:\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e .\n\n\n\nThe nbs/examples directory includes:\n\nSynthetic and real-world inverse modelling experiments for strings and plates\nOptimisation of nonlinear parameters and coupling tensors\nScripts to reproduce figures from the paper\n\nThe benchmark directory includes comparisons against: - An optimised C++ implementation using Eigen and BLAS - A JIT-compiled PyTorch implementation (GPU) - A MATLAB baseline\n\nWe plan to add more benchmarks, examples, and real-time synthesis demos in future updates.\n\n\n\n\n\nMode processing adapted from VKPlate\nPlate mode computation using magpie-python\nCoupling coefficient implementation based on VKGong",
    "crumbs": [
      "jaxdiffmodal"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "jaxdiffmodal",
    "section": "",
    "text": "Differentiable implementation using JAX\nSimulates linear and nonlinear models:\n\nTension-modulated string (Kirchhoff–Carrier)\nTension-modulated membrane (Berger model)\nvon Kármán nonlinear plate\n\nFast GPU-accelerated time integration\nDesigned for real-time synthesis, inverse modelling, and dataset generation\nIncludes example notebooks to reproduce results from the paper",
    "crumbs": [
      "jaxdiffmodal"
    ]
  },
  {
    "objectID": "index.html#installation-for-development",
    "href": "index.html#installation-for-development",
    "title": "jaxdiffmodal",
    "section": "",
    "text": "It is recommended to use the uv package manager to install the environment and dependencies.\nuv sync --all-extras\notherwise you can create a virtual environment and install the dependencies manually:\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e .",
    "crumbs": [
      "jaxdiffmodal"
    ]
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "jaxdiffmodal",
    "section": "",
    "text": "The nbs/examples directory includes:\n\nSynthetic and real-world inverse modelling experiments for strings and plates\nOptimisation of nonlinear parameters and coupling tensors\nScripts to reproduce figures from the paper\n\nThe benchmark directory includes comparisons against: - An optimised C++ implementation using Eigen and BLAS - A JIT-compiled PyTorch implementation (GPU) - A MATLAB baseline\n\nWe plan to add more benchmarks, examples, and real-time synthesis demos in future updates.",
    "crumbs": [
      "jaxdiffmodal"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "jaxdiffmodal",
    "section": "",
    "text": "Mode processing adapted from VKPlate\nPlate mode computation using magpie-python\nCoupling coefficient implementation based on VKGong",
    "crumbs": [
      "jaxdiffmodal"
    ]
  },
  {
    "objectID": "api/losses.html",
    "href": "api/losses.html",
    "title": "Losses",
    "section": "",
    "text": "A collection of losses including:\n\nSpectral log magnitude loss\nSpectral convergence loss\nWasserstein loss\n\n\nimport matplotlib.pyplot as plt\n\n\n\nwasserstein_1d\n\n wasserstein_1d (u_values, v_values, u_weights=None, v_weights=None, p=1,\n                 require_sort=True)\n\n*This is a port of the wasserstein_1d function from POT in JAX. Computes the 1 dimensional OT loss [15] between two (batched) empirical distributions\n.. math: OT_{loss} = _0^1 |cdf_u^{-1}(q) - cdf_v{-1}(q)|p dq\nIt is formally the p-Wasserstein distance raised to the power p. We do so in a vectorized way by first building the individual quantile functions then integrating them.\nThis function should be preferred to emd_1d whenever the backend is different to numpy, and when gradients over either sample positions or weights are required.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nu_values\n\n\n\n\n\nv_values\n\n\n\n\n\nu_weights\nNoneType\nNone\n\n\n\nv_weights\nNoneType\nNone\n\n\n\np\nint\n1\n\n\n\nrequire_sort\nbool\nTrue\n\n\n\nReturns\ncost: float/array-like, shape (…)\n\nthe batched EMD\n\n\n\n\n\n\nquantile_function\n\n quantile_function (qs, cws, xs)\n\nComputes the quantile function of an empirical distribution\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nqs\n\n\n\n\ncws\n\n\n\n\nxs\n\n\n\n\nReturns\nq: array-like, shape (…, n)\nThe quantiles of the distribution\n\n\n\n\n\n\ncompute_mag\n\n compute_mag (x:jax.Array)\n\n\n\n\n\nType\nDetails\n\n\n\n\nx\nArray\n(b, t)\n\n\nReturns\nArray\n\n\n\n\n\n\n\nspectral_wasserstein\n\n spectral_wasserstein (x, y, squared=True, is_mag=False)\n\n\n\n\nlog_mag_loss\n\n log_mag_loss (pred:jax.Array, target:jax.Array, eps:float=1e-10,\n               distance:str='l1')\n\nSpectral log magtinude loss but for a fft of a signal See Arik et al., 2018\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npred\nArray\n\ncomplex valued fft of the signal\n\n\ntarget\nArray\n\ncomplex valued fft of the signal\n\n\neps\nfloat\n1e-10\n\n\n\ndistance\nstr\nl1\n\n\n\n\n\n\n\nlog_mag\n\n log_mag (x:jax.Array, eps:float=1e-10)\n\n\nphase = 0.0\nomegas = jax.random.uniform(jax.random.PRNGKey(0), shape=(10,)) * 100\nmag = 0.99\n\n\ndef osc_bank(t, omegas):\n    return mag * jnp.sin(omegas[..., None] * jnp.pi * 2 * t[None] + phase)\n\n\nt = jnp.linspace(0, 1, 1000)\ngt_osc_values = osc_bank(t, omegas)\n# print(gt_osc_values)\nprint(gt_osc_values.shape)\n\n(10, 1000)\n\n\n\na = jax.vmap(spectral_wasserstein)(gt_osc_values, gt_osc_values)\nprint(a)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\ndef loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n    x_fft = compute_mag(gt_osc_values)\n    y_fft = compute_mag(pred_osc_values)\n    l2_mag_loss = jnp.mean((x_fft - y_fft) ** 2)\n    return l2_mag_loss\n\n\ndef ot_loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n\n    ot_loss = jnp.mean(\n        jax.vmap(spectral_wasserstein)(gt_osc_values, pred_osc_values),\n    )\n    return ot_loss\n\n\nx_fft = compute_mag(gt_osc_values) ** 2\nplt.plot(x_fft[:5].T)\n\n\n\n\n\n\n\n\n\nranges = jnp.linspace(-50, 50, 100)\nomegas_scan = omegas + ranges[:, None]\n\n# print(omegas_scan.shape)\nloss, grad = jax.vmap(jax.value_and_grad(loss_fn))(omegas_scan)\nloss_ot, grad_ot = jax.vmap(jax.value_and_grad(ot_loss_fn))(omegas_scan)\n\nprint(loss.shape, loss.dtype)\nprint(loss_ot.shape, loss_ot.dtype)\nplt.plot(ranges, loss_ot)\n\n(100,) float32\n(100,) float32\n\n\n\n\n\n\n\n\n\n\nomegas_gt = jax.random.uniform(jax.random.PRNGKey(0), shape=(10,)) * 1000\nomegas_pred = omegas_gt * 1\n\npred_osc_values = osc_bank(t, omegas_pred).mean(axis=0)\ngt_osc_values = osc_bank(t, omegas_gt)\n\nx_mag = compute_mag(gt_osc_values.mean(axis=0))\ny_mag = compute_mag(pred_osc_values)\n\nplt.semilogx(x_mag)\nplt.semilogx(y_mag)\n\n\n\n\n\n\n\n\n\n\n\nspectral_convergence_loss\n\n spectral_convergence_loss (pred:jax.Array, target:jax.Array)\n\nSpectral convergence loss but for a fft of a signal See Arik et al., 2018\n\n\n\n\nType\nDetails\n\n\n\n\npred\nArray\nmagnitude of the fft of the predicted signal\n\n\ntarget\nArray\nmagnitude of the fft of the target signal",
    "crumbs": [
      "API",
      "Losses"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters",
    "href": "api/lpc.html#parameters",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: np.ndarray The input signal. p: int The order of the LPC. method: str The method to compute the LPC. Either “autocorrelation” or “covariance”.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#returns",
    "href": "api/lpc.html#returns",
    "title": "LPC",
    "section": "Returns:",
    "text": "Returns:\nnp.ndarray The LPC coefficients. int The gain (or the square root of the energy) of the residual signal.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nndarray\n\n(time,)\n\n\np\nint\n\norder\n\n\nmethod\nstr\nautocorrelation\nmethod for the lpc computation\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\nReturns\nTuple\n\nadditional arguments for the method\n\n\n\n\n\njitted_linear_solve\n\n jitted_linear_solve (x, p)\n\n\n\n\njitted_lstsq\n\n jitted_lstsq (x, p)\n\n\nx = np.random.randn(100)\n\np = 4\na_autocorr, g_autocorr = lpc_cpu_solve(x, p, method=\"autocorrelation\", biased=False)\na_covar, g_covar = lpc_cpu_solve(x, p, method=\"covariance\")\n\nprint(a_autocorr, g_autocorr)\nprint(a_covar, g_covar)\n\n[-0.03891267  0.05897309 -0.11110881 -0.10518435] 8.848879174571616\n[-0.05351606  0.04524858 -0.09969181 -0.10755192] 8.666443074154966\n\n\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nComputes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n---------- in \nComputes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\n\n\nlinear_prediction\n\n linear_prediction (x:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.numbe\n                    r,bool,int,float,complex], a:Union[jax.Array,numpy.nda\n                    rray,numpy.bool,numpy.number,bool,int,float,complex])\n\n*Computes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters-1",
    "href": "api/lpc.html#parameters-1",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: ArrayLike The signal used to compute the linear prediction a: ArrayLike The coefficients of the linear prediction*\n\n\n\n\nType\nDetails\n\n\n\n\nx\nUnion\n(T)\n\n\na\nUnion\n(p)\n\n\nReturns\nUnion\n\n\n\n\n\n\nlinear_prediction_np\n\n linear_prediction_np (x:numpy.ndarray, a:numpy.ndarray)\n\n*Computes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters-2",
    "href": "api/lpc.html#parameters-2",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: ArrayLike The signal used to compute the linear prediction a: ArrayLike The coefficients of the linear prediction*\n\n\n\n\nType\nDetails\n\n\n\n\nx\nndarray\n(T,)\n\n\na\nndarray\n(p,)\n\n\nReturns\nndarray\n\n\n\n\n\nrng = np.random.default_rng(42)\nx = rng.normal(0, 1, 100)\na = rng.normal(0, 1, 4)\n\nlp_np = linear_prediction_np(x, a)\nlp_jax = linear_prediction(x, a)\n\nassert np.allclose(lp_np, lp_jax)\n\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nComputes the inverse filter of a signal x using the coefficients a.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n---------- in \nComputes the inverse filter of a signal x using the coefficients a.\n...\n  else: warn(msg)\n\n\ninverse_filter_np\n\n inverse_filter_np (x:numpy.ndarray, a:numpy.ndarray)\n\n*Computes the inverse filter of a signal x using the coefficients a.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters-3",
    "href": "api/lpc.html#parameters-3",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: ArrayLike The signal used to compute the inverse filter a: ArrayLike The coefficients of the linear prediction*\n\n\n\n\nType\nDetails\n\n\n\n\nx\nndarray\n(T,)\n\n\na\nndarray\n(p,)\n\n\nReturns\nndarray\n\n\n\n\n\n\ncoeffs_and_residual\n\n coeffs_and_residual (y:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.num\n                      ber,bool,int,float,complex], p:int, **kwargs)\n\nUtility function to compute the LPC coefficients and the residual.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ny\nUnion\ninput signal (time,)\n\n\np\nint\nnumber of coefficients\n\n\nkwargs\nVAR_KEYWORD\n\n\n\nReturns\nTuple\ncoefficients (p+1) and residual and gain\n\n\n\n\nrng = np.random.default_rng(42)\nx = rng.normal(size=1000)\npole = np.array([0.999 * np.exp(1j * np.pi / 4)])\npoles = np.concatenate([pole, np.conj(pole)])\nb, a = scipy.signal.zpk2tf([], poles, 1)\ny = scipy.signal.lfilter(b, a, x)\n\np = 10\na_autocorr, e_hat_autocorr, _ = coeffs_and_residual(x, p, method=\"autocorrelation\")\na_covar, e_hat_covar, _ = coeffs_and_residual(x, p, method=\"covariance\")",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/time_integrators.html",
    "href": "api/time_integrators.html",
    "title": "Time integrators",
    "section": "",
    "text": "A collection of efficient time integration methods for the damped oscillator with optional nonlinearities and initial conditions or excitation inputs.",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/time_integrators.html#stormer-verlet",
    "href": "api/time_integrators.html#stormer-verlet",
    "title": "Time integrators",
    "section": "Stormer-verlet",
    "text": "Stormer-verlet\nThe stormer-verlet is a centered difference scheme used to approximate derivatives. In the present case we use it for approximating the second and first derivatives of an oscillator defined by the following differential equation:\n\\[\n\\ddot{q} + c \\dot{q} + k q = f(t)\n\\]\nThe finite difference operators are defined as:\n\\[\n\\begin{align}\n\\delta_t q &= \\frac{q^{n+1} - q^{n-1}}{2 h} \\\\\n\\delta_{tt} q &= \\frac{q^{n+1} - 2 q^n + q^{n-1}}{h^2}\n\\end{align}\n\\]\nfor the first derivative and the second derivative respectively. The difference equation for the oscillator is then:\n\\[\n\\delta_{tt} q + c \\delta_t q + k q = f(t)\n\\]\nafter expanding and some algebraic manipulation to isolate \\(q^{n+1}\\) we get:\n\\[\n\\bigl(\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\bigr)\\,q^{n+1} +\n\\bigl(-\\tfrac{2}{h^2} + k\\bigr) q^n +\n\\bigl(\\tfrac{1}{h^2} - \\tfrac{c}{2h}\\bigr)\\,q^{n-1} =\nf(t^n).\n\\]\n\\[\n\\boxed{\nq^{n+1} = \\frac{2 h^2}{2 + c h}\n\\Bigl[\nf(t^n) + \\Bigl(\\tfrac{2}{h^2} - k\\Bigr) q^n +\n\\Bigl(-\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\Bigr) q^{n-1}\n\\Bigr].\n}\n\\]\nTo make it more readable we can define the following constants:\n\\[\n\\begin{align}\na &= \\frac{2 h^2}{2 + c h} \\\\\nb &= \\frac{2}{h^2} - k \\\\\nc &= -\\frac{1}{h^2} + \\frac{c}{2h}\n\\end{align}\n\\]\n\n\nmake_tm_nl_fn\n\n make_tm_nl_fn (lambda_mu, factors)\n\nReturns a function that computes nl given q.\n\n\n\nmake_vk_nl_fn\n\n make_vk_nl_fn (H)\n\nReturns a function that computes nl given q.\n\n\n\nmake_identity_nl_fn\n\n make_identity_nl_fn ()\n\n\n\n\nstring_tau_with_density\n\n string_tau_with_density (string_params)\n\n\n\n\nplate_tau_with_density\n\n plate_tau_with_density (plate_params)\n\n\n\n\nsecond_order_step\n\n second_order_step (u0:jax.Array, v0:jax.Array, dt:float,\n                    gamma2_mu:jax.Array, omega_mu_squared:jax.Array)\n\nOne step of 2nd-order Taylor expansion for damped oscillator. Returns: (u1, v1)\n\n\n\n\nType\nDetails\n\n\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\ntime step\n\n\ngamma2_mu\nArray\ndamping (n_modes,)\n\n\nomega_mu_squared\nArray\nfrequency (n_modes,)\n\n\n\n\n\n\nrk4_step\n\n rk4_step (u0:jax.Array, v0:jax.Array, dt:float, gamma2_mu:jax.Array,\n           omega_mu_squared:jax.Array)\n\nOne step of RK4 for the second-order damped oscillator. Returns: (u1, v1)\n\n\n\n\nType\nDetails\n\n\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\ntime step\n\n\ngamma2_mu\nArray\ndamping (n_modes,)\n\n\nomega_mu_squared\nArray\nfrequency (n_modes,)\n\n\n\n\n\n\nsolve_sv_initial_conditions\n\n solve_sv_initial_conditions (gamma2_mu, omega_mu_squared, u0:jax.Array,\n                              v0:jax.Array, dt:float, n_steps:int,\n                              nl_fn:collections.abc.Callable)\n\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n(n_modes,)\n\n\nomega_mu_squared\n\n(n_modes,)\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\n\n\n\nn_steps\nint\n\n\n\nnl_fn\nCallable\n\n\n\n\n\n\n\nsolve_sv_excitation\n\n solve_sv_excitation (gamma2_mu, omega_mu_squared,\n                      modal_excitation:jax.Array, dt:float,\n                      nl_fn:collections.abc.Callable)\n\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n(n_modes,)\n\n\nomega_mu_squared\n\n(n_modes,)\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\ndt\nfloat\n\n\n\nnl_fn\nCallable\n\n\n\n\n\n\n\nsolve_sv_vk_jax_scan\n\n solve_sv_vk_jax_scan (A_inv:jax.Array, B:jax.Array, C:jax.Array,\n                       modal_excitation:jax.Array,\n                       nl_fn:collections.abc.Callable)\n\n\n\n\n\nType\nDetails\n\n\n\n\nA_inv\nArray\n\n\n\nB\nArray\n\n\n\nC\nArray\n\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\nnl_fn\nCallable",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/time_integrators.html#discretised-transfer-function-method",
    "href": "api/time_integrators.html#discretised-transfer-function-method",
    "title": "Time integrators",
    "section": "Discretised transfer function method",
    "text": "Discretised transfer function method\n\n\nsolve_tf_initial_conditions\n\n solve_tf_initial_conditions (gamma2_mu, omega_mu_squared, u0:jax.Array,\n                              v0:jax.Array, dt:float, n_steps:int,\n                              nl_fn:collections.abc.Callable)\n\nSolve using transfer-function (TF) based recurrence.\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n\n\n\nomega_mu_squared\n\n\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\n\n\n\nn_steps\nint\n\n\n\nnl_fn\nCallable\n\n\n\n\n\n\n\nsolve_tf_excitation\n\n solve_tf_excitation (gamma2_mu, omega_mu_squared,\n                      modal_excitation:jax.Array, dt:float,\n                      nl_fn:collections.abc.Callable)\n\nSolve using transfer-function (TF) based recurrence.\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n\n\n\nomega_mu_squared\n\n\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\ndt\nfloat\n\n\n\nnl_fn\nCallable",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/time_integrators.html#sinusoidal-solve",
    "href": "api/time_integrators.html#sinusoidal-solve",
    "title": "Time integrators",
    "section": "Sinusoidal solve",
    "text": "Sinusoidal solve\nSolve the system of ODEs using complex exponentials\nThe system of ODEs is given by:\n\\[\n\\ddot{q} + 2 \\gamma \\dot{q} + \\omega^2 q = 0\n\\]\nwhere \\(\\gamma\\) is the damping coefficient and \\(\\omega\\) is the frequency. The damped frequencies are given by:\n\\[\n\\tilde{\\omega} = \\omega \\sqrt{1 - \\gamma^2} = \\sqrt{\\omega^2 - \\gamma^2}\n\\] The eigenvalues after the dispersion relation are then \\[\ns_\\pm = -\\gamma \\pm i \\tilde{\\omega}\n\\]\nand discrete time eigenvalues (poles) are \\[\nz_\\pm = e^{s_\\pm \\Delta t} = e^{-\\gamma \\Delta t} e^{\\pm i \\tilde{\\omega} \\Delta t}\n\\]\n\n\nsolve_sinusoidal\n\n solve_sinusoidal (gamma2_mu, omega_mu_squared, ic, n_steps, dt)\n\nSolve the system of ODEs using complex exponentials NB: this assumes the ic is only for positions and that the initial velocities are 0\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\njnp.ndarray\nDamping coefficients\n\n\nomega_mu_squared\njnp.ndarray\nSquared frequencies\n\n\nic\njnp.ndarray\nInitial conditions\n\n\nn_steps\nint\nNumber of steps\n\n\ndt\nfloat\nTime step\n\n\nReturns\njnp.ndarray\nModal solution\n\n\n\n\n\n\nsolve_sinusoidal_excitation\n\n solve_sinusoidal_excitation (gamma2_mu, omega_mu_squared,\n                              modal_excitation:jax.Array, dt:float)\n\nSolve the modal system with sinusoidal response for external excitation using parallel scan.\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\njnp.ndarray\nDamping coefficients (n_modes,)\n\n\nomega_mu_squared\njnp.ndarray\nSquared frequencies (n_modes,)\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\ndt\nfloat\nTime step\n\n\nReturns\njnp.ndarray\nModal solution (T, n_modes)\n\n\n\n\n\n\nsolve_tf_ic\n\n solve_tf_ic (gamma2_mu, omega_mu_squared, ic, n_steps, dt, nl_fn)",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/coupling.html",
    "href": "api/coupling.html",
    "title": "Coupling functions",
    "section": "",
    "text": "Function to compute the coupling matrix. Most of the code is a port (with some modifications) of the Matlab code from VKGong",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "href": "api/coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "title": "Coupling functions",
    "section": "Integrals for building the mass and stifness matrices",
    "text": "Integrals for building the mass and stifness matrices\n\n\nassemble_K_and_M\n\n assemble_K_and_M (Npsi, Lx, Ly)\n\n\n\n\nbuild_I4\n\n build_I4 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int4(m,p,L).\n\n\n\nbuild_I2\n\n build_I2 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int2(m,p,L).\n\n\n\nbuild_I1\n\n build_I1 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int1(m,p,L).\n\n\n\nint2_mat\n\n int2_mat (N, L)\n\nBuilds the N x N matrix whose (m,p) entry is int2(m,p,L). Mirrors the logic of the original Matlab int2_mat function exactly, but we can do it more simply by calling int2 in a loop.\n\n\n\nint2\n\n int2 (m, p, L)\n\nFunction int2(m,p,L). Piecewise definition from the Matlab code.\n\n\n\nint1\n\n int1 (m, p, L)\n\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nFirst mode number\n\n\np\nint\nSecond mode number\n\n\nL\nfloat\nLength of the domain\n\n\nReturns\nfloat\nValue of the integral\n\n\n\n\n\n\nint4\n\n int4 (m:int, p:int, L:float)\n\nCompute the integral of Xd(m,x)Xd(p,x) from 0 to L, where X is the clamped-plate function and d denotes derivative in x.\nThe integral is computed for different cases based on the mode numbers m and p.*\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nFirst mode number\n\n\np\nint\nSecond mode number\n\n\nL\nfloat\nLength of the domain\n\n\nReturns\nfloat\nValue of the integral\n\n\n\n\n\n\nairy_stress_coefficients\n\n airy_stress_coefficients (n_psi, vals, vecs)\n\nCompute the Airy stress function coefficients from the eigenvalues and eigenvectors",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "href": "api/coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "title": "Coupling functions",
    "section": "Basis used to build the mass and stiffness matrices",
    "text": "Basis used to build the mass and stiffness matrices\n\n\nbasis\n\n basis (m:int, n:int, x:float|numpy.ndarray, y:float|numpy.ndarray,\n        Lx:float, Ly:float)\n\n*Evaluate the full 2D basis function for indices (m, n) at point (x, y).\nThe basis function is defined as:\n.. math:: _{mn}(x,y) = X_m(x)Y_n(y)\nwhere X_m and Y_n are the 1D basis functions in x and y directions.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nMode number in x direction\n\n\nn\nint\nMode number in y direction\n\n\nx\nfloat | numpy.ndarray\nx coordinate(s) where to evaluate\n\n\ny\nfloat | numpy.ndarray\ny coordinate(s) where to evaluate\n\n\nLx\nfloat\nLength in x direction\n\n\nLy\nfloat\nLength in y direction\n\n\nReturns\nfloat | numpy.ndarray\nValue of the basis function at (x,y)",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "href": "api/coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "Partial integrals to calculate the coupling matrix",
    "text": "Partial integrals to calculate the coupling matrix\n\n\ni13_mat\n\n i13_mat (Npsi, Nphi, L)\n\n\n\n\ni12_mat\n\n i12_mat (Npsi, Nphi, L)\n\n\n\n\ni11_mat\n\n i11_mat (Npsi, Nphi, L)\n\n\n\n\ni10_mat\n\n i10_mat (Npsi, Nphi, L)\n\n\n\n\ni9_mat\n\n i9_mat (Npsi, Nphi, L)\n\n\n\n\ni5_mat\n\n i5_mat (Npsi, Nphi, L)\n\n\n\n\ni4_mat\n\n i4_mat (Npsi, Nphi, L)\n\nAuxiliary integral for the computation of the coupling coefficient H.\n\n\n\ni3_mat\n\n i3_mat (Npsi, Nphi, L)\n\nAuxiliary integral for the computation of the coupling coefficient H.\n\n\n\ni2_mat\n\n i2_mat (Npsi, Nphi, L)\n\n\n\n\ni1_mat\n\n i1_mat (Npsi, Nphi, L)",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#functions-to-put-together-the-coupling-matrix",
    "href": "api/coupling.html#functions-to-put-together-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "functions to put together the coupling matrix",
    "text": "functions to put together the coupling matrix\n\n\ng6\n\n g6 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng5\n\n g5 (Npsi, Nphi, S, kx, cache)\n\n\n\n\ng4\n\n g4 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng3\n\n g3 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng2\n\n g2 (Npsi, Nphi, S, kx, cache)\n\n\n\n\ng1\n\n g1 (Npsi, Nphi, S, kx, cache)\n\n\n\n\nbuild_s_matrix\n\n build_s_matrix (Npsi, Nphi, partials, idx_array, factor_mode)\n\nSummation of partial integrals in a 3D array with a factor.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nNpsi\n\n\n\n\nNphi\n\n\n\n\npartials\n\n\n\n\nidx_array\n\n\n\n\nfactor_mode\n\n\n\n\nReturns\nnp.ndarray of shape (Npsi, Nphi, Nphi)\nThe 3D tensor after summation and factor application.\n\n\n\n\n\n\ncompute_partial_integrals\n\n compute_partial_integrals (Npsi, Nphi, Lx, Ly)\n\nPrecompute and store all partial-integral matrices needed. Returns them in a dictionary or a custom object.\n\n\n\nH_tensor_rectangular\n\n H_tensor_rectangular (coeff0, coeff1, coeff2, Nphi, Npsi, Lx, Ly, kx, ky)\n\nCompute the H tensor for rectangular plates.\n\n\n\ncompute_coupling_matrix\n\n compute_coupling_matrix (n_psi, n_phi, lx, ly, kx_indices, ky_indices)",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "This section contains practical examples demonstrating how to use jaxdiffmodal for various physical modeling scenarios. You’ll find examples covering:\n\nSimulations of strings, membranes, and plates in both linear and non-linear cases\nParameter optimization using JAX’s automatic differentiation\n\nEach example includes explanations, code snippets, and visualizations.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\n\nDescription\n\n\n\n\n\n\n\n\nFitting a real plucked guitar string\n\n\n\n\n\n\n\n\n\nFitting to a real (thick) plate\n\n\n\n\n\n\n\n\n\nOptimising the parameters of the Von Karman plate\n\n\n\n\n\n\n\n\n\nOptimising the coupling coefficients of the Von Karman plate model\n\n\n\n\n\n\n\n\n\nLinear models\n\n\n\n\n\n\n\n\n\nNon-linear models\n\n\n\n\n\n\n\n\n\nOptimisation\n\n\n\n\n\n\n\n\n\nSimulations\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "examples/simulations/index.html",
    "href": "examples/simulations/index.html",
    "title": "Simulations",
    "section": "",
    "text": "We can simulate strings, membranes, and plates in different ways. However, for most cases the steps are similar:\n\nDefine the parameters of the simulation\nGet the eigenpairs\nDiscretize\nSimulate\n\nWe will go through these steps for a string, a membrane, and a plate, for the linear and non-linear cases.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\n\nDescription\n\n\n\n\n\n\n\n\nLinear models\n\n\n\n\n\n\n\n\n\nNon-linear models\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Examples",
      "Simulations"
    ]
  },
  {
    "objectID": "examples/optimisation/optimise_vkplate.html",
    "href": "examples/optimisation/optimise_vkplate.html",
    "title": "Optimising the parameters of the Von Karman plate",
    "section": "",
    "text": "In this notebook we optimise the bending stiffness of a Von Karman plate using backpropagation through time.\nFirst, we generate a target simulation of the plate. We define the parameters of the plate and the excitation.\nCode\nn_modes = 20\nsampling_rate = 44100\nsampling_period = 1 / sampling_rate\nh = 0.004  # grid spacing in the lowest resolution\nnx = 50  # number of grid points in the x direction in the lowest resolution\nny = 75  # number of grid points in the y direction in the lowest resolution\nlevels = 2  # number of grid refinements to perform\namplitude = 0.5\nparams = PlateParameters(\n    E=2e12,\n    nu=0.3,\n    rho=7850,\n    h=5e-4,\n    l1=0.2,\n    l2=0.3,\n    Ts0=100,\n)\nforce_position = (0.05, 0.05)\nreadout_position = (0.1, 0.1)\nCode\n# boundary conditions for the transverse modes\nbcs_phi = np.array(\n    [\n        [1e15, 0],\n        [1e15, 0],\n        [1e15, 0],\n        [1e15, 0],\n    ]\n)\n# boundary conditions for the in-plane modes\nbcs_psi = np.array(\n    [\n        [1e15, 1e15],\n        [1e15, 1e15],\n        [1e15, 1e15],\n        [1e15, 1e15],\n    ]\n)\n\npsi, zeta_mu_squared, nx_final, ny_final, h_final, psi_norms = (\n    multiresolution_eigendecomposition(\n        params,\n        n_modes,\n        bcs_psi,\n        h,\n        nx,\n        ny,\n        levels=2,\n    )\n)\n\nphi, lambda_mu_squared, nx_final, ny_final, h_final, phi_norms = (\n    multiresolution_eigendecomposition(\n        params,\n        n_modes,\n        bcs_phi,\n        h,\n        nx,\n        ny,\n        levels=2,\n    )\n)\n\nH = compute_coupling_matrix_numerical(\n    psi,\n    phi,\n    h_final,\n    nx_final,\n    ny_final,\n)\ne = params.E / (2 * params.rho)\nH = H * np.sqrt(e)\nlambda_mu = jnp.sqrt(lambda_mu_squared)\n\n\nRefining grid to h = 0.002, nx = 100, ny = 150\nRefining grid to h = 0.002, nx = 100, ny = 150\nCode\n# generate a 1d raised cosine excitation\nrc = create_1d_raised_cosine(\n    duration=1.0,\n    start_time=0.001,\n    end_time=0.003,\n    amplitude=amplitude,\n    sample_rate=44100,\n)\n\nphi_reshaped = np.reshape(\n    phi,\n    shape=(ny_final + 1, nx_final + 1, n_modes),\n    order=\"F\",\n)\n\nmode_gains_at_pos = phi_reshaped[\n    int(force_position[1] * ny_final),\n    int(force_position[0] * nx_final),\n    :,\n]\n\nmode_gains_at_readout = phi_reshaped[\n    int(readout_position[1] * ny_final),\n    int(readout_position[0] * nx_final),\n    :,\n]\n# the modal excitation needs to be scaled by A_inv and divided by the density\nmode_gains_at_pos_normalised = mode_gains_at_pos / params.density\nmodal_excitation_normalised_short = rc[: 4410 * 3, None] * mode_gains_at_pos_normalised\nmodal_excitation_normalised_long = rc[:44100, None] * mode_gains_at_pos_normalised",
    "crumbs": [
      "Examples",
      "Optimisation",
      "Optimising the parameters of the Von Karman plate"
    ]
  },
  {
    "objectID": "examples/optimisation/optimise_vkplate.html#loss-landscape",
    "href": "examples/optimisation/optimise_vkplate.html#loss-landscape",
    "title": "Optimising the parameters of the Von Karman plate",
    "section": "Loss landscape",
    "text": "Loss landscape\nLet’s take a small detour to explore how the loss function varies with respect to a single parameter. First define the loss function.\n\n\nCode\ndef combined_loss_fn(\n    pars,\n    lm_loss_weight=1.0,\n    ot_loss_weight=1.0,\n    sc_loss_weight=1.0,\n    time_loss_weight=1.0,\n):\n    out_pos = simulate_vkplate(pars, modal_excitation_normalised_short)\n\n    out_pos_fft_mag = jnp.abs(stft(out_pos)) * out_pos_gt_fft_mag_scale\n\n    log_diff = safe_log(out_pos_gt_fft_mag + 1e-10) - safe_log(out_pos_fft_mag + 1e-10)\n    lm_loss = jnp.mean(jnp.abs(log_diff))\n\n    ot_loss = jnp.mean(\n        jax.vmap(spectral_wasserstein, in_axes=(0, 0, None, None))(\n            out_pos_fft_mag,\n            out_pos_gt_fft_mag,\n            True,\n            True,\n        )\n    )\n    time_loss = jnp.mean(jnp.square(out_pos - out_pos_gt))\n    sc_loss = spectral_convergence_loss(\n        out_pos_fft_mag,\n        out_pos_gt_fft_mag,\n    )\n\n    combined_loss = (\n        lm_loss * lm_loss_weight\n        + ot_loss * ot_loss_weight\n        + sc_loss * sc_loss_weight\n        + time_loss * time_loss_weight\n    )\n    return combined_loss, (lm_loss, ot_loss, sc_loss, time_loss)\n\n\nPlot the loss landscape for the bending stiffness\n\n\nCode\ndef compute_losses_for_stiffness(\n    bending_stiffness,\n    loss_fn,\n):\n    pars = {\n        \"bending_stiffness\": bending_stiffness,\n        \"Ts0\": params.Ts0 / params.density,\n    }\n    return loss_fn(pars)\n\n\nbending_stiffness_normalised_range = jnp.linspace(\n    gt_pars[\"bending_stiffness\"] - 4.5,\n    gt_pars[\"bending_stiffness\"] + 4.5,\n    100,\n)\n\nlosses_combined, (losses_lm, losses_ot, losses_sc, losses_time) = jax.vmap(\n    partial(\n        compute_losses_for_stiffness,\n        loss_fn=combined_loss_fn,\n    )\n)(bending_stiffness_normalised_range)",
    "crumbs": [
      "Examples",
      "Optimisation",
      "Optimising the parameters of the Von Karman plate"
    ]
  },
  {
    "objectID": "examples/optimisation/optimise_vkplate.html#optimise-the-bending-stiffness",
    "href": "examples/optimisation/optimise_vkplate.html#optimise-the-bending-stiffness",
    "title": "Optimising the parameters of the Von Karman plate",
    "section": "Optimise the bending stiffness",
    "text": "Optimise the bending stiffness\nNow we optimise the bending stiffness. Starting from an initial value of 10.0\n\n\n\n\n\n\n\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Initial\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\nOptimisation loop. This might take a while to run, depending on how long is the sequence we want to optimise over and the number of iterations. Here we optimise over a 0.3 second sequence (13230 samples), which is on the longer side for this sort of optimisation.\n\n\nCode\nlearning_rate = 2e-1\niterations = 1000\nscheduler = optax.cosine_onecycle_schedule(\n    transition_steps=iterations,\n    peak_value=learning_rate,\n)\noptimiser = optax.adam(learning_rate=scheduler)\n\nstate = optimiser.init(pars)\nvalue_and_grad = jax.value_and_grad(\n    partial(\n        combined_loss_fn,\n        lm_loss_weight=0.0,\n        ot_loss_weight=1.0,\n        sc_loss_weight=0.001,\n        time_loss_weight=0.0,\n    ),\n    has_aux=True,\n)\n\n\n@jax.jit\ndef train_step(pars, state):\n    (loss, _), grads = value_and_grad(pars)\n    updates, state = optimiser.update(grads, state, pars)\n    pars = optax.apply_updates(pars, updates)\n    return pars, state, loss\n\n\nbar = tqdm(range(iterations))\nfor i in bar:\n    pars, state, loss = train_step(pars, state)\n    bar.set_description(\n        f\"Loss: {loss:.3f}, bending stiffness: {pars['bending_stiffness']:.4f}, ground truth: {gt_pars['bending_stiffness']:.4f}\",\n    )\n\n\n  0%|          | 0/1000 [00:00&lt;?, ?it/s]2025-04-04 12:06:51.270375: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng28{k2=1,k3=0} for conv %cudnn-conv.4 = (f32[1,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[1,1024,15277]{2,1,0} %bitcast.12099, f32[1,1024,1024]{2,1,0} %bitcast.12104), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 12:06:51.550709: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 1.280406645s\nTrying algorithm eng28{k2=1,k3=0} for conv %cudnn-conv.4 = (f32[1,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[1,1024,15277]{2,1,0} %bitcast.12099, f32[1,1024,1024]{2,1,0} %bitcast.12104), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\nLoss: 0.000, bending stiffness: 5.8328, ground truth: 5.8328: 100%|██████████| 1000/1000 [03:49&lt;00:00,  4.36it/s]\n\n\n\n\n\n\n\n\n\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Optimised\n        \n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Optimisation",
      "Optimising the parameters of the Von Karman plate"
    ]
  },
  {
    "objectID": "examples/optimisation/optimise_vkplate.html#multistart-parallel-optimisation",
    "href": "examples/optimisation/optimise_vkplate.html#multistart-parallel-optimisation",
    "title": "Optimising the parameters of the Von Karman plate",
    "section": "Multistart parallel optimisation",
    "text": "Multistart parallel optimisation\nWe can also optimise over a larger range of initial bending stiffness values, using parallel multiple starts in parallel. Here we use 50 random initial values between 2 and 50. NB: with longer sequences, this will take longer to run also because the XLA compilation will take longer to find an appropriate implementation because of the STFT.\n\n\nCode\nvalue_and_grad = jax.value_and_grad(\n    partial(\n        combined_loss_fn,\n        lm_loss_weight=0.0,\n        ot_loss_weight=1.0,\n        sc_loss_weight=0.001,\n        time_loss_weight=0.0,\n    ),\n    has_aux=True,\n)\n\n\ndef losses_and_grads_for_single_stiffness(bending_stiffness):\n    pars = {\n        \"bending_stiffness\": bending_stiffness,\n        \"Ts0\": params.Ts0 / params.density,\n    }\n\n    (loss, _), grads = value_and_grad(pars)\n\n    # return loss and gradient for bending stiffness only\n    return loss, grads[\"bending_stiffness\"]\n\n\ncompute_vec_loss_grad = jax.vmap(losses_and_grads_for_single_stiffness)\n\n# Generate starting points\nnum_starts = 50\nstart_points = jnp.linspace(2.0, 50.0, num_starts)\n\nlearning_rate = 1e-2\niterations = 100\nscheduler = optax.cosine_onecycle_schedule(\n    transition_steps=iterations,\n    peak_value=learning_rate,\n)\noptimiser = optax.chain(\n    optax.clip_by_global_norm(1.0),\n    optax.adam(learning_rate=scheduler),\n)\nopt_state = optimiser.init(start_points)\n\n\n@jax.jit\ndef train_step(pars, state):\n    losses, grads = compute_vec_loss_grad(pars)\n    updates, state = optimiser.update(grads, state, pars)\n    pars = optax.apply_updates(pars, updates)\n    return pars, state, losses\n\n\nbar = tqdm(range(iterations))\nfor i in bar:\n    start_points, opt_state, losses = train_step(start_points, opt_state)\n\n    best_idx = jnp.argmin(losses)\n    best_loss = losses[best_idx]\n    best_param = start_points[best_idx]\n    bar.set_description(f\"Best loss: {best_loss:.6f}, Best param: {best_param:.6f}\")\n\n# Get final results\nfinal_losses, _ = compute_vec_loss_grad(start_points)\nbest_idx = jnp.argmin(final_losses)\nbest_param = start_points[best_idx]\nbest_loss = final_losses[best_idx]\n\nprint(f\"Best bending stiffness found: {best_param:.6f}\")\nprint(f\"Ground truth: {gt_pars['bending_stiffness']:.6f}\")\nprint(f\"Best loss: {best_loss:.6f}\")\n\n\n  0%|          | 0/100 [00:00&lt;?, ?it/s]2025-04-04 11:57:23.800760: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng55{k2=8,k13=1,k14=3,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:27.647765: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 4.84707795s\nTrying algorithm eng55{k2=8,k13=1,k14=3,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:28.648244: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng56{k2=8,k12=-1,k13=1,k14=3,k15=0,k17=512,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:32.474092: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 4.826270609s\nTrying algorithm eng56{k2=8,k12=-1,k13=1,k14=3,k15=0,k17=512,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:33.474217: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng54{k2=5,k12=-1,k13=1,k14=2,k15=0,k17=512,k18=1,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:40.681969: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 8.207817642s\nTrying algorithm eng54{k2=5,k12=-1,k13=1,k14=2,k15=0,k17=512,k18=1,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:41.682097: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng53{k2=5,k13=1,k14=2,k18=1,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:48.827023: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 8.144989253s\nTrying algorithm eng53{k2=5,k13=1,k14=2,k18=1,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:49.827151: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng54{k2=1,k12=-1,k13=0,k14=3,k15=0,k17=256,k18=1,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:56.732148: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 7.905064559s\nTrying algorithm eng54{k2=1,k12=-1,k13=0,k14=3,k15=0,k17=256,k18=1,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:57:57.732277: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng28{k2=3,k3=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:09.450809: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 12.718606294s\nTrying algorithm eng28{k2=3,k3=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:10.450932: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng41{k2=0,k12=-1,k13=2,k14=3,k15=0,k17=512,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:25.186257: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 15.735370362s\nTrying algorithm eng41{k2=0,k12=-1,k13=2,k14=3,k15=0,k17=512,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:26.186537: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng35{k2=5,k5=2,k14=6} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:37.667011: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 12.480538189s\nTrying algorithm eng35{k2=5,k5=2,k14=6} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:38.667145: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng48{k2=2,k6=2,k13=1,k14=0,k22=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:54.286052: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 16.618976657s\nTrying algorithm eng48{k2=2,k6=2,k13=1,k14=0,k22=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:58:55.286177: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng48{k2=15,k6=2,k13=1,k14=0,k22=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:59:15.215454: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 20.92933587s\nTrying algorithm eng48{k2=15,k6=2,k13=1,k14=0,k22=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:59:16.215570: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng56{k2=6,k12=-1,k13=0,k14=1,k15=0,k17=342,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:59:48.464969: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 33.249455776s\nTrying algorithm eng56{k2=6,k12=-1,k13=0,k14=1,k15=0,k17=342,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 11:59:49.465108: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng55{k2=3,k13=2,k14=2,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 12:00:04.464957: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 15.999924232s\nTrying algorithm eng55{k2=3,k13=2,k14=2,k18=1,k22=0,k23=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 12:00:05.465090: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng28{k2=0,k3=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 12:00:41.373249: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 36.908233659s\nTrying algorithm eng28{k2=0,k3=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 12:00:42.373385: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng28{k2=1,k3=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 12:01:41.780386: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 1m0.407078507s\nTrying algorithm eng28{k2=1,k3=0} for conv %cudnn-conv.4 = (f32[50,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[50,1024,15277]{2,1,0} %bitcast.12196, f32[1,1024,1024]{2,1,0} %bitcast.12201), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_100446/1261401191.py\" source_line=38}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\nBest loss: 0.000006, Best param: 5.832441: 100%|██████████| 100/100 [07:57&lt;00:00,  4.78s/it] \n\n\nBest bending stiffness found: 5.832441\nGround truth: 5.832808\nBest loss: 0.000005",
    "crumbs": [
      "Examples",
      "Optimisation",
      "Optimising the parameters of the Von Karman plate"
    ]
  },
  {
    "objectID": "examples/optimisation/index.html",
    "href": "examples/optimisation/index.html",
    "title": "Optimisation",
    "section": "",
    "text": "Here we show some examples of optimisation problems.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\n\nDescription\n\n\n\n\n\n\n\n\nFitting a real plucked guitar string\n\n\n\n\n\n\n\n\n\nFitting to a real (thick) plate\n\n\n\n\n\n\n\n\n\nOptimising the parameters of the Von Karman plate\n\n\n\n\n\n\n\n\n\nOptimising the coupling coefficients of the Von Karman plate model\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Examples",
      "Optimisation"
    ]
  },
  {
    "objectID": "examples/optimisation/optimise_string.html",
    "href": "examples/optimisation/optimise_string.html",
    "title": "Fitting a real plucked guitar string",
    "section": "",
    "text": "This notebook shows how to fit the physical parameters of a guitar string to a real recording.\nLoad a recording of a plucked guitar string.\n\n\nCode\nstiff_string_real, file_sr = sf.read(\"audio/G53-50205-1111-00019.wav\")\n\nif file_sr != sample_rate:\n    print(f\"Resampling from {file_sr} to {sample_rate}\")\n    stiff_string_real = soxr.resample(\n        stiff_string_real,\n        in_rate=file_sr,\n        out_rate=sample_rate,\n    )\n\nprint(\"The sample rate is\", sample_rate)\n\nduration = 1.0\noffset = int(0.00 * file_sr)\nstop = int(1 * file_sr)\nstiff_string_real = stiff_string_real[offset : offset + stop]\nu_stiff_string_rfft = np.fft.rfft(stiff_string_real)\n\n\nThe sample rate is 44100\n\n\nFit the real data using LPC to get an spectral envelope.\n\n\nCode\na_lpc_cpu_solve_autocorr, g_lpc_solve_autocorr = lpc_cpu_solve(\n    stiff_string_real,\n    512,\n    method=\"autocorrelation\",\n    biased=False,\n)\n\n\nw, h = freqz(\n    b=g_lpc_solve_autocorr,\n    a=np.concatenate([[1], a_lpc_cpu_solve_autocorr]),\n    worN=u_stiff_string_rfft.shape[0],\n    fs=sample_rate,\n)\n\n\n# impulse response\nH = g_lpc_solve_autocorr / np.fft.rfft(\n    np.concatenate([[1], a_lpc_cpu_solve_autocorr]),\n    n=sample_rate,\n)\ny = np.fft.irfft(H, n=sample_rate)\ny_rfft = np.abs(np.fft.rfft(y))\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\nax.semilogx(w, to_db(np.abs(u_stiff_string_rfft)), label=\"RFFT\")\nax.semilogx(w, to_db(np.abs(h)), label=\"LPC spectral envelope\", ls=\"--\")\nax.grid(\"both\")\nax.legend()\n\ndisplay_audio_with_title(stiff_string_real, sample_rate, \"Original\")\ndisplay_audio_with_title(y, sample_rate, \"LPC fit\")\n\n\n\n    \n        Original\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        LPC fit\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n\n\n\n\n\n\nSample the envelope using the bark scale.\n\n\nCode\nhz_range = np.array([50, 15000])\nmelrange = hz2bark(hz_range)\nworN = bark2hz(np.linspace(melrange[0], melrange[1], 20_000))\n\nw, h = freqz(\n    g_lpc_solve_autocorr,\n    a=np.concatenate([[1], a_lpc_cpu_solve_autocorr]),\n    worN=worN,\n    fs=sample_rate,\n)\n\nh = jnp.abs(h) / jnp.max(jnp.abs(h))\n\n\nDefine the initial parameters and constraints.\n\n\nCode\nn_modes = 64\nrng = np.random.default_rng(654)\npars = {\n    \"bending_stiffness\": rng.normal(scale=1e-3),\n    \"gamma_mu\": rng.uniform(size=(n_modes)),\n    \"zero_radii\": rng.normal(size=(n_modes)).astype(np.float32),\n    \"zero_angles\": rng.normal(size=(n_modes)).astype(np.float32),\n    \"Ts0\": rng.normal(scale=1e-3),\n    \"length\": 0.65,\n    \"z0\": rng.normal(size=(n_modes, 1)).astype(np.float32),\n    \"gain\": rng.normal(scale=1e-4),\n}\n\n\ndef get_z0(params):\n    return jax.nn.sigmoid(params[\"z0\"])\n\n\ndef get_gamma_mu(params):\n    return -jax.nn.relu(params[\"gamma_mu\"])\n    # return -jnp.exp(params[\"gamma_mu\"])\n\n\ndef get_radii(params):\n    return jax.nn.sigmoid(params[\"radii\"])\n\n\ndef get_Ts0(params):\n    return jax.nn.sigmoid(params[\"Ts0\"]) * 50_000\n\n\ndef get_gain(params):\n    return jax.nn.sigmoid(params[\"gain\"]) * 0.001\n\n\ndef get_length(params):\n    return jax.nn.sigmoid(params[\"length\"])\n\n\ndef get_bending_stiffness(params):\n    return jax.nn.sigmoid(params[\"bending_stiffness\"]) * 10\n\n\ndef get_zero_radii(params):\n    return jax.nn.sigmoid(params[\"zero_radii\"])\n\n\ndef get_zero_angles(params):\n    return jax.nn.sigmoid(params[\"zero_angles\"])\n\n\ndef get_zeros(pars):\n    return jax.nn.sigmoid(pars[\"zero_radii\"]) * jnp.exp(\n        2j * np.pi * jax.nn.sigmoid(pars[\"zero_angles\"])\n    )\n\n\nSimulate the string using the initial parameters.\n\n\nCode\ndef tf_modified(\n    pars,\n    lambda_mu,\n    dt,\n):\n    omega_mu_squared = (\n        get_bending_stiffness(pars) * lambda_mu**2 + get_Ts0(pars) * lambda_mu\n    )\n    gamma_mu = get_gamma_mu(pars)\n    omega_mu = jnp.sqrt(omega_mu_squared - gamma_mu**2)\n\n    # discretise\n    radius = jnp.exp(gamma_mu * dt)\n    real = radius * jnp.cos(omega_mu * dt)\n\n    zeros = get_zeros(pars)\n    b1 = -2.0 * zeros.real\n    b2 = zeros.real**2 + zeros.imag**2\n\n    a1 = -2.0 * real\n    a2 = radius**2\n\n    ones = jnp.ones_like(lambda_mu)\n\n    b = jnp.stack([ones, b1, b2], axis=-1)\n    a = jnp.stack([ones, a1, a2], axis=-1)\n    return b, a\n\n\ndef simulate_string(pars):\n    lambdas = string_eigenvalues(n_modes, length=get_length(pars))\n    b, a = tf_modified(pars, lambdas, dt)\n    b = b * get_z0(pars) * get_gain(pars)\n    h = tf_freqz(b, a, worN, sample_rate)\n    pred_freq_response = jnp.mean(jnp.abs(h), axis=0)\n    return pred_freq_response, b, a\n\n\ninitial_freq_response, b, a = simulate_string(pars)\nu_stiff_string_rfft = np.fft.rfft(stiff_string_real)\nfft_freqs = np.fft.rfftfreq(len(stiff_string_real), dt)\n\ntarget_freq_resp = h\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\n\nax.semilogx(\n    worN,\n    to_db(target_freq_resp),\n    label=\"Target\",\n)\nax.semilogx(\n    worN,\n    to_db(initial_freq_response),\n    label=\"Initial\",\n    ls=\"--\",\n)\nax.grid(which=\"both\")\n_ = ax.legend()\n\nx = jnp.zeros(shape=(sample_rate), dtype=jnp.float32)\nx = x.at[0].set(1.0)\nmean_sol_pred = iir_filter_parallel(b, a, x).mean(axis=1)\n\ndisplay_audio_with_title(y, sample_rate, \"Target\")\ndisplay_audio_with_title(mean_sol_pred, sample_rate, \"Initial\")\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Initial\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n\n\n\n\n\n\nOptimise the parameters using gradient descent.\n\n\nCode\niterations = 20_000\nlearning_rate = 3e-2\nscheduler = optax.cosine_onecycle_schedule(\n    transition_steps=iterations,\n    peak_value=learning_rate,\n)\noptimiser = optax.chain(\n    optax.clip_by_global_norm(2.0),\n    optax.adam(learning_rate=scheduler),\n)\nstate = optimiser.init(pars)\n\n\ndef loss_fn(pars):\n    pred_freq_resp, b, a = simulate_string(pars)\n\n    log_diff = safe_log(pred_freq_resp) - safe_log(target_freq_resp)\n    log_l1_loss = jnp.mean(\n        jnp.abs(\n            log_diff,\n        ),\n    )\n    sc_loss = spectral_convergence_loss(\n        pred_freq_resp,\n        target_freq_resp,\n    )\n    ot_loss = jnp.mean(\n        spectral_wasserstein(\n            pred_freq_resp,\n            target_freq_resp,\n            is_mag=True,\n        )\n    )\n\n    return log_l1_loss * 0.1 + sc_loss + ot_loss\n\n\n@jax.jit\ndef train_step(pars, state):\n    loss, grads = jax.value_and_grad(loss_fn)(pars)\n    updates, state = optimiser.update(grads, state, pars)\n    pars = optax.apply_updates(pars, updates)\n    return pars, state, loss\n\n\nbar = tqdm(range(iterations))\nfor i in bar:\n    pars, state, loss = train_step(pars, state)\n    bar.set_description(\n        f\"Loss: {loss:.3f}, length: {get_length(pars):.3f}, Ts0: {get_Ts0(pars):.3f}, bending stiffness: {get_bending_stiffness(pars):.3f}\"\n    )\n\n\nLoss: 0.176, length: 0.676, Ts0: 40033.289, bending stiffness: 0.384: 100%|██████████| 20000/20000 [00:34&lt;00:00, 585.55it/s] \n\n\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Optimised\n        \n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Optimisation",
      "Fitting a real plucked guitar string"
    ]
  },
  {
    "objectID": "examples/optimisation/optimise_vkplate_h.html",
    "href": "examples/optimisation/optimise_vkplate_h.html",
    "title": "Optimising the coupling coefficients of the Von Karman plate model",
    "section": "",
    "text": "We can also optimise the non-linearity part of the plate model, that is the coupling coefficients.\nAgain, we generate a target simulation of the plate. We define the parameters of the plate and the excitation.\n\n\nCode\nn_modes = 20\nsampling_rate = 44100\nsampling_period = 1 / sampling_rate\nh = 0.004  # grid spacing in the lowest resolution\nnx = 50  # number of grid points in the x direction in the lowest resolution\nny = 75  # number of grid points in the y direction in the lowest resolution\nlevels = 2  # number of grid refinements to perform\namplitude = 0.5\nparams = PlateParameters(\n    E=2e12,\n    nu=0.3,\n    rho=7850,\n    h=5e-4,\n    l1=0.2,\n    l2=0.3,\n    Ts0=100,\n)\nforce_position = (0.05, 0.05)\nreadout_position = (0.1, 0.1)\n\n\n\n\nCode\n# boundary conditions for the transverse modes\nbcs_phi = np.array(\n    [\n        [1e15, 0],\n        [1e15, 0],\n        [1e15, 0],\n        [1e15, 0],\n    ]\n)\n# boundary conditions for the in-plane modes\nbcs_psi = np.array(\n    [\n        [1e15, 1e15],\n        [1e15, 1e15],\n        [1e15, 1e15],\n        [1e15, 1e15],\n    ]\n)\n\npsi, zeta_mu_squared, nx_final, ny_final, h_final, psi_norms = (\n    multiresolution_eigendecomposition(\n        params,\n        n_modes,\n        bcs_psi,\n        h,\n        nx,\n        ny,\n        levels=2,\n    )\n)\n\nphi, lambda_mu_squared, nx_final, ny_final, h_final, phi_norms = (\n    multiresolution_eigendecomposition(\n        params,\n        n_modes,\n        bcs_phi,\n        h,\n        nx,\n        ny,\n        levels=2,\n    )\n)\n\nH = compute_coupling_matrix_numerical(\n    psi,\n    phi,\n    h_final,\n    nx_final,\n    ny_final,\n)\ne = params.E / (2 * params.rho)\nH = H * np.sqrt(e)\nlambda_mu = jnp.sqrt(lambda_mu_squared)\n\n\nRefining grid to h = 0.002, nx = 100, ny = 150\nRefining grid to h = 0.002, nx = 100, ny = 150\n\n\n\n\nCode\n# generate a 1d raised cosine excitation\nrc = create_1d_raised_cosine(\n    duration=1.0,\n    start_time=0.001,\n    end_time=0.003,\n    amplitude=amplitude,\n    sample_rate=44100,\n)\n\nphi_reshaped = np.reshape(\n    phi,\n    shape=(ny_final + 1, nx_final + 1, n_modes),\n    order=\"F\",\n)\n\nmode_gains_at_pos = phi_reshaped[\n    int(force_position[1] * ny_final),\n    int(force_position[0] * nx_final),\n    :,\n]\n\nmode_gains_at_readout = phi_reshaped[\n    int(readout_position[1] * ny_final),\n    int(readout_position[0] * nx_final),\n    :,\n]\n# the modal excitation needs to be scaled by A_inv and divided by the density\nmode_gains_at_pos_normalised = mode_gains_at_pos / params.density\nmodal_excitation_normalised_short = rc[: 4410 * 3, None] * mode_gains_at_pos_normalised\nmodal_excitation_normalised_long = rc[:44100, None] * mode_gains_at_pos_normalised\n\n\nPlot the intial simulation\n\n\n\n\n\n\n\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Initial\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\nOptimisation loop\n\n\nCode\nlearning_rate = 5e-1\niterations = 2000\nscheduler = optax.cosine_onecycle_schedule(\n    transition_steps=iterations,\n    peak_value=learning_rate,\n)\noptimiser = optax.adam(learning_rate=scheduler)\nstate = optimiser.init(pars)\n\n\ndef loss_fn(pars):\n    out_pos = simulate_vkplate(pars, modal_excitation_normalised_short)\n    out_pos_fft_mag = jnp.abs(stft(out_pos)) * out_pos_gt_fft_mag_scale\n\n    ot_loss = jnp.mean(\n        jax.vmap(spectral_wasserstein, in_axes=(0, 0, None, None))(\n            out_pos_fft_mag,\n            out_pos_gt_fft_mag,\n            True,\n            True,\n        )\n    )\n    sc_loss = spectral_convergence_loss(\n        out_pos_fft_mag,\n        out_pos_gt_fft_mag,\n    )\n\n    return sc_loss + ot_loss\n\n\n@jax.jit\ndef train_step(pars, state):\n    loss, grads = jax.value_and_grad(loss_fn)(pars)\n    updates, state = optimiser.update(grads, state, pars)\n    pars = optax.apply_updates(pars, updates)\n    return pars, state, loss\n\n\nbar = tqdm(range(iterations))\nfor i in bar:\n    pars, state, loss = train_step(pars, state)\n    bar.set_description(f\"Loss: {loss:.3f}\")\n\n\n  0%|          | 0/2000 [00:00&lt;?, ?it/s]2025-04-04 12:25:52.319377: E external/xla/xla/service/slow_operation_alarm.cc:73] Trying algorithm eng28{k2=1,k3=0} for conv %cudnn-conv.4 = (f32[1,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[1,1024,15277]{2,1,0} %bitcast.10872, f32[1,1024,1024]{2,1,0} %bitcast.10877), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_116305/1382163847.py\" source_line=28}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\n2025-04-04 12:25:52.603298: E external/xla/xla/service/slow_operation_alarm.cc:140] The operation took 1.284018802s\nTrying algorithm eng28{k2=1,k3=0} for conv %cudnn-conv.4 = (f32[1,1,14254]{2,1,0}, u8[0]{0}) custom-call(f32[1,1024,15277]{2,1,0} %bitcast.10872, f32[1,1024,1024]{2,1,0} %bitcast.10877), window={size=1024}, dim_labels=bf0_oi0-&gt;bf0, custom_call_target=\"__cudnn$convForward\", metadata={op_name=\"jit(train_step)/jit(main)/conv_general_dilated\" source_file=\"/tmp/ipykernel_116305/1382163847.py\" source_line=28}, backend_config={\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[],\"cudnn_conv_backend_config\":{\"conv_result_scale\":1,\"activation_mode\":\"kNone\",\"side_input_scale\":0,\"leakyrelu_alpha\":0},\"force_earliest_schedule\":false} is taking a while...\nLoss: 0.090: 100%|██████████| 2000/2000 [06:50&lt;00:00,  4.88it/s]\n\n\n\n\n\n\n\n\n\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Optimised\n        \n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Optimisation",
      "Optimising the coupling coefficients of the Von Karman plate model"
    ]
  },
  {
    "objectID": "examples/optimisation/optimise_plate.html",
    "href": "examples/optimisation/optimise_plate.html",
    "title": "Fitting to a real (thick) plate",
    "section": "",
    "text": "This notebook shows how to fit the physical parameters of a plate to a real recording.\nLoad a recording of a struck plate and preprocess it\n\n\nCode\nstiff_string_real, file_sr = sf.read(\"audio/single.wav\")\nif file_sr != sample_rate:\n    print(f\"Resampling from {file_sr} to {sample_rate}\")\n    stiff_string_real = soxr.resample(\n        stiff_string_real,\n        in_rate=file_sr,\n        out_rate=sample_rate,\n    )\n\nprint(\"The sample rate is\", sample_rate)\n\nscale = 1\nduration = 2.0\noffset = int(0.00 * sample_rate)\nstop = int(1 * sample_rate)\n# ensure the audio has exactly the same length\nstiff_string_real = stiff_string_real[offset : offset + stop]\n\n# high pass filter the audio\nb, a = butter(N=4, Wn=800, btype=\"high\", fs=sample_rate)\nstiff_string_real = lfilter(b, a, stiff_string_real)\n\n# get the rfft of the real audio\nu_stiff_string_rfft = np.fft.rfft(stiff_string_real)\n\n# get the spectral envelope\na_lpc_cpu_solve_autocorr, g_lpc_solve_autocorr = lpc_cpu_solve(\n    stiff_string_real,\n    128,\n    method=\"autocorrelation\",\n    biased=False,\n)\n\nw, h = freqz(\n    b=g_lpc_solve_autocorr,\n    a=np.concatenate([[1], a_lpc_cpu_solve_autocorr]),\n    worN=u_stiff_string_rfft.shape[0],\n    fs=sample_rate,\n)\n\n# impulse response\nH = g_lpc_solve_autocorr / np.fft.rfft(\n    np.concatenate([[1], a_lpc_cpu_solve_autocorr]),\n    n=sample_rate,\n)\ny = np.fft.irfft(H, n=sample_rate)\ny_rfft = np.abs(np.fft.rfft(y))\n\nt = np.linspace(0, duration, len(stiff_string_real))\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\nax.set_title(\"RFFT and spectral envelope\")\nax.semilogx(to_db(np.abs(u_stiff_string_rfft)), label=\"RFFT\")\nax.semilogx(w, to_db(np.abs(h)), label=\"LPC spectral envelope\", ls=\"--\")\nax.grid(\"both\")\nax.legend()\nfig.tight_layout()\n\ndisplay_audio_with_title(stiff_string_real, sample_rate, \"Original\")\ndisplay_audio_with_title(y, sample_rate, \"LPC fit and filtered\")\n\n\nResampling from 48000 to 44100\nThe sample rate is 44100\n\n\n\n    \n        Original\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        LPC fit and filtered\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n\n\n\n\n\n\nSample the envelope using the bark scale.\n\n\nCode\nhz_range = np.array([200, 20000])\nbarkrange = hz2bark(hz_range)\nworN = bark2hz(np.linspace(barkrange[0], barkrange[1], 20000))\n\nw, h = freqz(\n    g_lpc_solve_autocorr,\n    a=np.concatenate([[1], a_lpc_cpu_solve_autocorr]),\n    worN=worN,\n    fs=sample_rate,\n)\ntarget_freq_resp = jnp.abs(h) / jnp.max(jnp.abs(h))\n\n\nDefine the initial parameters and constraints.\n\n\nCode\nRANGE_BENDING_STIFFNESS = 15000\n\nrng = np.random.default_rng(654)\npars = {\n    \"bending_stiffness\": rng.normal(),\n    \"gamma_mu\": jnp.linspace(5, 15, n_modes),\n    \"d1\": rng.normal(),\n    \"d3\": rng.normal(),\n    \"Ts0\": rng.normal(),\n    \"l1\": rng.normal(),\n    \"l2\": rng.normal(),\n    \"z0\": rng.normal(size=(n_modes, 1)).astype(np.float32),\n    \"gain\": rng.normal(scale=1e-3),\n    \"zero_radii\": rng.normal(size=(n_modes)).astype(np.float32),\n    \"zero_angles\": rng.normal(size=(n_modes)).astype(np.float32),\n}\n\n\ndef get_bending_stiffness(params):\n    return jax.nn.sigmoid(params[\"bending_stiffness\"]) * RANGE_BENDING_STIFFNESS\n\n\ndef get_l1(params):\n    return jax.nn.sigmoid(params[\"l1\"])\n\n\ndef get_l2(params):\n    return jax.nn.sigmoid(params[\"l2\"])\n\n\ndef get_z0(params):\n    return params[\"z0\"]\n\n\ndef get_gamma_mu(params):\n    return -jax.nn.relu(params[\"gamma_mu\"])\n    # return -jnp.exp(params[\"gamma_mu\"])\n\n\ndef get_Ts0(params):\n    return 0.0\n\n\ndef get_gain(params):\n    return params[\"gain\"]\n\n\ndef get_zeros(pars):\n    return jax.nn.sigmoid(pars[\"zero_radii\"]) * jnp.exp(\n        2j * np.pi * jax.nn.sigmoid(pars[\"zero_angles\"])\n    )\n\n\nSimulate the plate using the initial parameters.\n\n\nCode\ndef tf_modified(\n    pars,\n    lambda_mu,\n    dt,\n):\n    omega_mu_squared = (\n        get_bending_stiffness(pars) * lambda_mu**2 + get_Ts0(pars) * lambda_mu\n    )\n    gamma_mu = get_gamma_mu(pars)\n    omega_mu = jnp.sqrt(omega_mu_squared - gamma_mu**2)\n\n    # discretise\n    radius = jnp.exp(gamma_mu * dt)\n    real = radius * jnp.cos(omega_mu * dt)\n\n    zeros = get_zeros(pars)\n    b1 = -2.0 * zeros.real\n    b2 = zeros.real**2 + zeros.imag**2\n\n    a1 = -2.0 * real\n    a2 = radius**2\n\n    ones = jnp.ones_like(lambda_mu)\n\n    b = jnp.stack([ones, b1, b2], axis=-1)\n    a = jnp.stack([ones, a1, a2], axis=-1)\n    return b, a\n\n\ndef simulate_membrane(pars):\n    wnx, wny = plate_wavenumbers(\n        n_max_modes_x,\n        n_max_modes_y,\n        get_l1(pars),\n        get_l2(pars),\n    )\n    lambda_mu = plate_eigenvalues(wnx, wny).reshape(-1)\n    lambda_mu = lambda_mu.reshape(-1).sort()[:n_modes]\n\n    b, a = tf_modified(pars, lambda_mu, dt)\n    b = b * get_z0(pars) * get_gain(pars)\n    h = tf_freqz(b, a, worN, sample_rate)\n    pred_freq_resp = jnp.mean(jnp.abs(h), axis=0)\n    return pred_freq_resp, b, a\n\n\ninitial_freq_resp, b, a = simulate_membrane(pars)\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\nax.semilogx(\n    worN,\n    to_db(target_freq_resp),\n    label=\"Target\",\n)\nax.semilogx(\n    worN,\n    to_db(initial_freq_resp),\n    label=\"Initial\",\n    ls=\"--\",\n)\nax.grid(which=\"both\")\n_ = ax.legend()\n\n\nx = jnp.zeros(shape=(sample_rate), dtype=jnp.float32)\nx = x.at[0].set(1.0)\npred_imp_resp = iir_filter_parallel(b, a, x).mean(axis=1)\n\ndisplay_audio_with_title(y, sample_rate, \"Target\")\ndisplay_audio_with_title(pred_imp_resp, sample_rate, \"Initial\")\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Initial\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n\n\n\n\n\n\nOptimise the parameters using gradient descent.\n\n\nCode\niterations = 30_000\nlearning_rate = 1e-2\nscheduler = optax.cosine_onecycle_schedule(\n    transition_steps=iterations,\n    peak_value=learning_rate,\n)\noptimiser = optax.chain(\n    optax.clip_by_global_norm(2.0),\n    optax.adam(learning_rate=scheduler),\n)\nstate = optimiser.init(pars)\n\n\n@jax.jit\ndef train_step(pars, state):\n    def loss_fn(pars):\n        pred_freq_resp, b, a = simulate_membrane(pars)\n\n        log_pred_freq_resp = safe_log(pred_freq_resp)\n        log_target_freq_resp = safe_log(target_freq_resp)\n\n        lin_diff = pred_freq_resp - target_freq_resp\n        log_diff = log_pred_freq_resp - log_target_freq_resp\n\n        lin_l2_loss = jnp.mean(\n            jnp.square(\n                lin_diff,\n            ),\n        )\n        log_l1_loss = jnp.mean(\n            jnp.abs(\n                log_diff,\n            ),\n        )\n        sc_loss = spectral_convergence_loss(\n            log_pred_freq_resp,\n            log_target_freq_resp,\n        )\n        ot_loss = jnp.mean(\n            spectral_wasserstein(\n                pred_freq_resp,\n                target_freq_resp,\n                squared=True,\n                is_mag=True,\n            )\n        )\n\n        return lin_l2_loss + log_l1_loss * 0.1 + sc_loss + ot_loss * 0.001\n\n    loss, grads = jax.value_and_grad(loss_fn)(pars)\n\n    updates, state = optimiser.update(grads, state, pars)\n    pars = optax.apply_updates(pars, updates)\n    return pars, state, loss\n\n\nbar = tqdm(range(iterations))\nfor i in bar:\n    pars, state, loss = train_step(pars, state)\n    bar.set_description(\n        f\"Loss: {loss:.3f}, bending_stiffness: {get_bending_stiffness(pars):.3f}, l1: {get_l1(pars):.3f}, l2: {get_l2(pars):.3f}\"\n    )\n\n\nLoss: 0.158, bending_stiffness: 3998.537, l1: 0.738, l2: 0.357: 100%|██████████| 30000/30000 [00:47&lt;00:00, 632.80it/s]\n\n\n\n\n\n    \n        Target\n        \n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n    \n    \n\n\n\n    \n        Optimised\n        \n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Optimisation",
      "Fitting to a real (thick) plate"
    ]
  },
  {
    "objectID": "examples/simulations/linear.html",
    "href": "examples/simulations/linear.html",
    "title": "Linear models",
    "section": "",
    "text": "For the linear models we want to solve the following equation:\n\\[\\begin{equation}\n\\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w} + (D \\Delta \\Delta - T_0 \\Delta) w = f_{\\text{ext}},\n\\end{equation}\\]\nwhich in modal coordinates \\(q_{\\mu}\\) results in uncoupled damped harmonic oscillators:\n\\[\\begin{equation}\n\\ddot{q}_{\\mu} + 2\\gamma_{\\mu}\\dot{q}_{\\mu} + \\omega_{\\mu}^2 q_{\\mu} = \\bar{f}_{\\text{ext},\\mu},\n\\end{equation}\\]\nwhere the coefficients are given by:\n\\[\\begin{align}\n\\omega_{\\mu}^2 &= \\frac{D\\lambda_{\\mu}^2 - T_0\\lambda_{\\mu}}{\\rho},\\\\\n\\gamma_{\\mu} &= \\frac{d_1 + d_3\\lambda_{\\mu}}{2\\rho}.\n\\end{align}\\]\n\nString\nSome parameters for the string\n\n\nCode\nn_modes = 50\nn_steps = 44100\nsample_rate = 44100\ndt = 1.0 / sample_rate\nexcitation_position = 0.2\nreadout_position = 0.5\ninitial_deflection = 0.03\nn_gridpoints = 101  # number of gridpoints for evaluating the eigenfunctions\nstring_params = StringParameters()\n\n\nGetting the eigenpairs\n\n\nCode\nlambda_mu = string_eigenvalues(n_modes, string_params.length)\nwn = np.sqrt(lambda_mu)\ngrid = np.linspace(0, string_params.length, n_gridpoints)\nK = string_eigenfunctions(wn, grid)\n\n\nGet the initial conditions or the excitation\n\nu0_modal = create_pluck_modal(\n    lambda_mu,\n    pluck_position=excitation_position,\n    initial_deflection=initial_deflection,\n    string_length=string_params.length,\n)\nu0 = inverse_STL(K, u0_modal, string_params.length)\nfig, ax = plt.subplots(1, 1, figsize=(6, 2))\nax.plot(grid, u0)\nax.set_xlabel(\"Position (m)\")\nax.set_ylabel(\"Deflection (m)\")\nax.set_title(\"Initial deflection of the string\")\nax.grid(True)\n\n\n\n\n\n\n\n\nGet \\(\\gamma_{\\mu}\\) and \\(\\omega_{\\mu}\\) and integrate in time from the initial conditions defined above. This should be very fast, even for a large number of modes.\n\ngamma2_mu = damping_term(\n    string_params,\n    lambda_mu,\n)\nomega_mu_squared = stiffness_term(\n    string_params,\n    lambda_mu,\n)\n\nmodal_sol = solve_sinusoidal(\n    gamma2_mu,\n    omega_mu_squared,\n    u0_modal,\n    n_steps,\n    dt,\n)\n\nTransform the modal solution back to the physical space using the precomputed eigenfunctions, or evaluate at a single point.\n\nmu = np.arange(1, n_modes + 1)  # mode indices\n\nreadout_weights = evaluate_string_eigenfunctions(\n    mu,\n    readout_position,\n    string_params,\n)\n\n# at a single point\nu_readout = readout_weights @ modal_sol\n\n# at all points\nsol = inverse_STL(K, modal_sol, string_params.length)\n\nSingle point:\n\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\n\n\n\n\n\n\nAll points:\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\n\nPlate\nWe do a very similar thing for plates. First define the parameters\n\n\nCode\nn_modes_x = 8\nn_modes_y = 8\nn_modes = n_modes_x * n_modes_y\nn_steps = 44100\nsample_rate = 44100\ndt = 1.0 / sample_rate\nexcitation_duration = 1.0  # seconds\nexcitation_amplitude = 1.0\nforce_position = (0.05, 0.05)\nreadout_position = (0.1, 0.1)\nplate_params = PlateParameters(\n    Ts0=0,\n    d1=4e-3,\n    d3=3e-2,\n)\n\n\nGet the eigenpairs\n\n\nCode\nwnx, wny = plate_wavenumbers(\n    n_modes_x,\n    n_modes_y,\n    plate_params.l1,\n    plate_params.l2,\n)\nlambda_mu_2d = plate_eigenvalues(wnx, wny)\nn_gridpoints_x = 101\nn_gridpoints_y = 151\nx = np.linspace(0, plate_params.l1, n_gridpoints_x)\ny = np.linspace(0, plate_params.l2, n_gridpoints_y)\nK = plate_eigenfunctions(wnx, wny, x, y)\n\n# Sort the eigenvalues and get the indices\nindices = np.argsort(lambda_mu_2d.ravel())\nky_indices, kx_indices = np.unravel_index(indices, lambda_mu_2d.shape)\nky_indices, kx_indices = ky_indices + 1, kx_indices + 1\nselected_indices = np.stack([kx_indices, ky_indices], axis=-1)\nlambda_mu = np.sort(lambda_mu_2d.reshape(-1))\n\n\nThis time we will use an excitation force instead on initial conditions. We define the force as a 1D raised cosine at a single point on the plate.\n\n\nCode\nrc = create_1d_raised_cosine(\n    duration=excitation_duration,\n    start_time=0.010,\n    end_time=0.012,\n    amplitude=excitation_amplitude,\n    sample_rate=sample_rate,\n)\n\nweights_at_ex = (\n    evaluate_rectangular_eigenfunctions(\n        selected_indices,\n        force_position,\n        params=plate_params,\n    )\n    / plate_params.density\n)\n\nweights_at_readout = evaluate_rectangular_eigenfunctions(\n    selected_indices,\n    readout_position,\n    params=plate_params,\n)\n\nmodal_excitation = np.outer(rc, weights_at_ex)\n\n\nGet \\(\\gamma_{\\mu}\\) and \\(\\omega_{\\mu}\\) and integrate in time using the excitation force.\n\n\nCode\ngamma2_mu = damping_term(\n    plate_params,\n    lambda_mu,\n)\nomega_mu_squared = stiffness_term(\n    plate_params,\n    lambda_mu,\n)\n\n\ndef nl_fn(modal_sol):\n    return 0.0\n\n\n_, modal_sol = solve_tf_excitation(\n    gamma2_mu,\n    omega_mu_squared,\n    modal_excitation,\n    dt,\n    nl_fn=nl_fn,\n)\n\n\nGet the solution in physical space\n\n\n\n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Simulations",
      "Linear models"
    ]
  },
  {
    "objectID": "examples/simulations/non-linear.html",
    "href": "examples/simulations/non-linear.html",
    "title": "Non-linear models",
    "section": "",
    "text": "The non-linear models are also similar to simulate. We add a non-linear to the equation:\n\\[\\begin{equation}\n\\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w} + (D \\Delta \\Delta - T_0 \\Delta) w = f_{\\text{ext}} - f_{\\text{nl}},\n\\end{equation}\\]\nwhere \\(f_{\\text{nl}}\\) is the non-linear term. Again we get damped harmonic oscillators:\n\\[\\begin{equation}\n\\ddot{q}_{\\mu} + 2\\gamma_{\\mu}\\dot{q}_{\\mu} + \\omega_{\\mu}^2 q_{\\mu} = \\bar{f}_{\\text{ext},\\mu} - \\bar{f}_{\\text{nl},\\mu},\n\\end{equation}\\]\nwhere \\(\\bar{f}_{\\text{nl},\\mu}\\) is the non-linear term in modal space. This term differs depending on the type of non-linearity and whether we are simulating a string, membrane or plate.",
    "crumbs": [
      "Examples",
      "Simulations",
      "Non-linear models"
    ]
  },
  {
    "objectID": "examples/simulations/non-linear.html#tension-modulated-string",
    "href": "examples/simulations/non-linear.html#tension-modulated-string",
    "title": "Non-linear models",
    "section": "Tension modulated string",
    "text": "Tension modulated string\nFor tension-modulated strings the non-linear term expanded in modal coordinates is given by:\n\\[\\begin{equation}\n\\bar{f}_{nl} = \\tau \\sum_{\\mu} \\frac{\\lambda_{\\mu} q_{\\mu}^2}{||\\Phi_{\\mu}||^2},\n\\end{equation}\\]\nwhere \\(\\tau\\) is:\n\\[\\begin{equation}\n\\tau = \\frac{E A}{2 L}\n\\end{equation}\\]\nFirst, we set up the parameters for the string.\n\nn_modes = 50\nn_steps = 44100\nsample_rate = 44100\ndt = 1.0 / sample_rate\nexcitation_position = 0.2\nreadout_position = 0.5\ninitial_deflection = 0.04\nn_gridpoints = 101  # number of gridpoints for evaluating the eigenfunctions\nstring_params = StringParameters()\n\nGet the eigenpairs and the initial condition\n\n\nCode\nlambda_mu = string_eigenvalues(n_modes, string_params.length)\nwn = np.sqrt(lambda_mu)\ngrid = np.linspace(0, string_params.length, n_gridpoints)\nK = string_eigenfunctions(wn, grid)\n\n\nu0_modal = create_pluck_modal(\n    lambda_mu,\n    pluck_position=excitation_position,\n    initial_deflection=initial_deflection,\n    string_length=string_params.length,\n)\nu0 = inverse_STL(K, u0_modal, string_params.length)\nfig, ax = plt.subplots(1, 1, figsize=(6, 2))\nax.plot(grid, u0)\nax.set_xlabel(\"Position (m)\")\nax.set_ylabel(\"Deflection (m)\")\nax.set_title(\"Initial deflection of the string\")\nax.grid(True)\n\n\n\n\n\n\n\n\n\nDefine the non-linear term and integrate in time\n\n\nCode\ngamma2_mu = damping_term(string_params, lambda_mu)\nomega_mu_squared = stiffness_term(string_params, lambda_mu)\n\nstring_tau = string_tau_with_density(string_params)\nstring_norm = string_params.length / 2\n\n# include the norm and lambda_mu to make it more compact\nstring_tau = string_tau * lambda_mu / string_norm\n\nnl_fn = make_tm_nl_fn(lambda_mu, string_tau)\n_, modal_sol = solve_tf_initial_conditions(\n    gamma2_mu,\n    omega_mu_squared,\n    u0=u0_modal,\n    v0=jnp.zeros_like(u0_modal),\n    dt=dt,\n    n_steps=n_steps,\n    nl_fn=nl_fn,\n)\n\n# transpose to have modes in the first dimension\nmodal_sol = modal_sol.T\n\nprint(modal_sol.shape)\n\n\n(50, 44100)\n\n\n\n\nCode\nmu = np.arange(1, n_modes + 1)  # mode indices\n\nreadout_weights = evaluate_string_eigenfunctions(\n    mu,\n    readout_position,\n    string_params,\n)\n\n# at a single point\nu_readout = readout_weights @ modal_sol\n\n# at all points\nsol = inverse_STL(K, modal_sol, string_params.length)\n\ndisplay(Audio(u_readout, rate=sample_rate))\nfig, ax = plt.subplots(1, 1, figsize=(6, 2))\nax.plot(u_readout)\nax.set_xlabel(\"Sample\")\nax.set_ylabel(\"Deflection (m)\")\nax.set_title(\"Deflection of the string at a single point\")\nax.set_xlim(-2, sample_rate // 10)\nax.grid(True)\n\n\n\n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Simulations",
      "Non-linear models"
    ]
  },
  {
    "objectID": "examples/simulations/non-linear.html#tension-modulated-plate",
    "href": "examples/simulations/non-linear.html#tension-modulated-plate",
    "title": "Non-linear models",
    "section": "Tension modulated plate",
    "text": "Tension modulated plate\nThe tension-modulated plate works just like the string we saw earlier, same non-linear term, but with a different \\(\\tau\\) value:\n\\[\n\\tau = \\frac{E h}{2 L_x L_y (1 - \\nu^2)}\n\\]\nDefine the parameters for the plate\n\n\nCode\nn_modes_x = 15\nn_modes_y = 15\nn_modes = n_modes_x * n_modes_y\nn_steps = 44100\nsample_rate = 44100\ndt = 1.0 / sample_rate\nexcitation_duration = 1.0  # seconds\nexcitation_amplitude = 40\nforce_position = (0.05, 0.05)\nreadout_position = (0.1, 0.1)\nplate_params = PlateParameters(\n    Ts0=0.0,\n    d1=1e-4,\n    d3=1e-2,\n)\n\n\nGet the eigenpairs and the excitation\n\n\nCode\nwnx, wny = plate_wavenumbers(\n    n_modes_x,\n    n_modes_y,\n    plate_params.l1,\n    plate_params.l2,\n)\nlambda_mu_2d = plate_eigenvalues(wnx, wny)\nn_gridpoints_x = 101\nn_gridpoints_y = 151\nx = np.linspace(0, plate_params.l1, n_gridpoints_x)\ny = np.linspace(0, plate_params.l2, n_gridpoints_y)\nK = plate_eigenfunctions(wnx, wny, x, y)\n\n# Sort the eigenvalues and get the indices\nindices = np.argsort(lambda_mu_2d.ravel())\nky_indices, kx_indices = np.unravel_index(indices, lambda_mu_2d.shape)\nky_indices, kx_indices = ky_indices + 1, kx_indices + 1\nselected_indices = np.stack([kx_indices, ky_indices], axis=-1)\nlambda_mu = np.sort(lambda_mu_2d.reshape(-1))\n\nrc = create_1d_raised_cosine(\n    duration=excitation_duration,\n    start_time=0.010,\n    end_time=0.012,\n    amplitude=excitation_amplitude,\n    sample_rate=sample_rate,\n)\n\nweights_at_ex = (\n    evaluate_rectangular_eigenfunctions(\n        selected_indices,\n        force_position,\n        params=plate_params,\n    )\n    / plate_params.density\n)\n\nweights_at_readout = evaluate_rectangular_eigenfunctions(\n    selected_indices,\n    readout_position,\n    params=plate_params,\n)\n\nmodal_excitation = np.outer(rc, weights_at_ex)\n\n\nDefine the non-linear term and integrate in time\n\n\nCode\ngamma2_mu = damping_term(\n    plate_params,\n    lambda_mu,\n)\nomega_mu_squared = stiffness_term(\n    plate_params,\n    lambda_mu,\n)\n\nplate_tau = (plate_params.E * plate_params.h) / (\n    2 * plate_params.l1 * plate_params.l2 * (1 - plate_params.nu**2)\n)\nplate_tau = plate_tau / plate_params.density\nplate_norm = 0.25 * plate_params.l1 * plate_params.l2\n\nplate_tau = plate_tau * lambda_mu / plate_norm\n\nnl_fn = make_tm_nl_fn(lambda_mu, plate_tau)\n\n_, modal_sol = solve_tf_excitation(\n    gamma2_mu,\n    omega_mu_squared,\n    modal_excitation,\n    dt,\n    nl_fn=nl_fn,\n)\n\nmodal_sol = modal_sol.T\n\n\n\n\n\n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Simulations",
      "Non-linear models"
    ]
  },
  {
    "objectID": "examples/simulations/non-linear.html#von-karman-plate",
    "href": "examples/simulations/non-linear.html#von-karman-plate",
    "title": "Non-linear models",
    "section": "Von Karman plate",
    "text": "Von Karman plate\nIn the Von Karman plate we have a different non-linear term:\n\\[\\begin{equation}\n\\bar{f}_{nl} = \\frac{E S_w}{2 \\rho} \\sum_{p, q, r}^n \\frac{H_{q, r}^n C_{p, n}^s}{\\zeta_n^4} q_p q_q q_r,\n\\end{equation}\\]\nWe will use the same parameters as in the tension-modulated plate above but now we need the coupling coefficients (assuming simply supported boundary conditions). Calculating the coupling coefficients can take a while, so we will only use 10 in-plane modes and all transverse modes. We will also set \\(S_w = ||\\Phi||^2\\) and increase the excitation amplitude to make the coupling effect more noticeable\nIntegrate in time. This is fast however with more modes it will take longer. In any case, this will take longer than the tension-modulated plate.\n\n\nCode\ngamma2_mu = damping_term(\n    plate_params,\n    lambda_mu,\n)\nomega_mu_squared = stiffness_term(\n    plate_params,\n    lambda_mu,\n)\n\nnl_fn = make_vk_nl_fn(H1_scaled)\n\n_, modal_sol = solve_tf_excitation(\n    gamma2_mu,\n    omega_mu_squared,\n    modal_excitation * amplitude_scaling,\n    dt,\n    nl_fn=nl_fn,\n)\n\nmodal_sol = modal_sol.T\n\n\n\n\n\n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Simulations",
      "Non-linear models"
    ]
  },
  {
    "objectID": "api/features.html",
    "href": "api/features.html",
    "title": "Features",
    "section": "",
    "text": "This is an implementation of the CQT1992v2 from nnAudio in JAX.\n\n\ncqt_transform\n\n cqt_transform (x, cqt_instance, output_format=None)\n\nJIT-compiled CQT transform function.\n\n\n\nCQT1992v2\n\n CQT1992v2 (sr=22050, hop_length=512, fmin=32.7, fmax=None, n_bins=84,\n            bins_per_octave=12, filter_scale=1, norm=1, window='hann',\n            center=True, pad_mode='reflect', trainable=False,\n            output_format='Magnitude')\n\nJAX implementation of CQT1992v2 from nnAudio.\n\n\n\nconv1d_efficient\n\n conv1d_efficient (x, kernel, stride=1)\n\nEfficient JAX implementation of 1D convolution using lax.conv_general_dilated.\n\n\n\ncreate_cqt_kernels\n\n create_cqt_kernels (Q, fs, fmin, n_bins=84, bins_per_octave=12, norm=1,\n                     window='hann', fmax=None, topbin_check=True, gamma=0)\n\nCreate CQT kernels in time domain.\n\n\n\nget_window_dispatch\n\n get_window_dispatch (window, N, fftbins=True)\n\nGet the window function.\n\n\n\nbroadcast_dim\n\n broadcast_dim (x)\n\nAuto broadcast input so that it can fit into a Conv1d.\n\n\n\nnextpow2\n\n nextpow2 (A)\n\nCalculate the next nearest number to the power of 2.",
    "crumbs": [
      "API",
      "Features"
    ]
  },
  {
    "objectID": "api/excitations.html",
    "href": "api/excitations.html",
    "title": "Excitation functions",
    "section": "",
    "text": "import matplotlib.pyplot as plt\n\n\n\ncreate_1d_raised_cosine\n\n create_1d_raised_cosine (duration:float, start_time:float,\n                          end_time:float, amplitude:float,\n                          sample_rate:float)\n\nCreate a 1D raised cosine excitation with time parameters in seconds.\n\n\n\n\nType\nDetails\n\n\n\n\nduration\nfloat\nTotal duration of the excitation (in seconds).\n\n\nstart_time\nfloat\nStart time of the excitation (in seconds).\n\n\nend_time\nfloat\nEnd time of the excitation (in seconds).\n\n\namplitude\nfloat\nAmplitude of the excitation.\n\n\nsample_rate\nfloat\nSample rate (samples per second).\n\n\nReturns\nndarray\nThe excitation signal.\n\n\n\n\nrc = create_1d_raised_cosine(\n    1,\n    0.01,\n    0.05,\n    1,\n    44100,\n)\n\nplt.plot(rc)\n\n\n\n\n\n\n\n\n\n\n\ncreate_raised_cosine\n\n create_raised_cosine (Nx, Ny, h, ctr, epsilon, wid)\n\n*Create a raised cosine function on a 2D grid.\nParameters: Nx (int): Number of grid points in the x-direction. Ny (int): Number of grid points in the y-direction. h (float): Grid spacing. ctr (tuple): Center of the raised cosine (x, y). epsilon (float): Scaling parameter. wid (float): Width of the cosine.\nReturns: np.ndarray: Flattened raised cosine array.*\n\nfrom matplotlib import pyplot as plt\n\n\n# Example usage\nNx, Ny = 25, 21  # Grid dimensions\nh = 0.0438  # Grid spacing\nctr = (0.5, 0.5)  # Center of the raised cosine\nepsilon = 1.2000  # Scaling parameter\nwid = 0.3  # Width of the cosine\n\nrc, X, Y, dist, distx, disty = create_raised_cosine(\n    Nx,\n    Ny,\n    h,\n    ctr,\n    epsilon,\n    wid,\n)\n\nplt.imshow(rc, cmap=\"gray\", origin=\"lower\")\n\n\n\n\n\n\n\n\n\n\n\ncreate_pluck_modal\n\n create_pluck_modal (lambdas:numpy.ndarray, pluck_position:float=0.28,\n                     initial_deflection:float=0.03,\n                     string_length:float=1.0)\n\nCreate a pluck excitation for a string with a given length and pluck position. The pluck is modeled in the modal domain.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlambdas\nndarray\n\neigenvalues of the Laplacian operator\n\n\npluck_position\nfloat\n0.28\nposition of pluck on the string in meters\n\n\ninitial_deflection\nfloat\n0.03\ninitial deflection of the string in meters\n\n\nstring_length\nfloat\n1.0\ntotal length of the string in meters\n\n\nReturns\nndarray\n\nThe pluck excitation in the modal domain.",
    "crumbs": [
      "API",
      "Excitation functions"
    ]
  },
  {
    "objectID": "api/ftm.html",
    "href": "api/ftm.html",
    "title": "Funtional Transformation Method Utilities",
    "section": "",
    "text": "This notebook contains a set of utility functions for the functional transformation method.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#parameters",
    "href": "api/ftm.html#parameters",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nwavenumbers: np.ndarray The wavenumbers for the drumhead. r: np.ndarray Radial grid points. theta: np.ndarray Angular grid points.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#returns",
    "href": "api/ftm.html#returns",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\nmodes: np.ndarray The eigenfunctions for the drumhead.*\n\n\n\n\nType\nDetails\n\n\n\n\nwavenumbers\nndarray\n(n_max_modes, m_max_modes)\n\n\nr\nndarray\n(n_gridpoints_r)\n\n\ntheta\nndarray\n(n_gridpoints_theta)\n\n\nReturns\nndarray\n\n\n\n\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nCompute the eigenvalues of the drumhead.\nThe eigenvalues of the drumhead are given by the square of the wavenumbers....\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nCompute the eigenvalues of the drumhead.\nThe eigenvalues of the drumhead are given by the square of the wavenumbers....\n  else: warn(msg)\n\n\ndrumhead_eigenvalues\n\n drumhead_eigenvalues (wavenumbers:numpy.ndarray)\n\n*Compute the eigenvalues of the drumhead. The eigenvalues of the drumhead are given by the square of the wavenumbers.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#parameters-1",
    "href": "api/ftm.html#parameters-1",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nwavenumbers: np.ndarray The wavenumbers for the drumhead. squared: bool If True, return the squared eigenvalues.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#returns-1",
    "href": "api/ftm.html#returns-1",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\neigenvalues: np.ndarray The eigenvalues of the drumhead.*\n\n\n\n\nType\nDetails\n\n\n\n\nwavenumbers\nndarray\n(n_max_modes, m_max_modes)\n\n\n\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nCompute the wavenumbers of the drumhead.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nCompute the wavenumbers of the drumhead.\n...\n  else: warn(msg)\n\n\ndrumhead_wavenumbers\n\n drumhead_wavenumbers (n_max_modes:int, m_max_modes:int, radius:float)\n\n*Compute the wavenumbers of the drumhead.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#parameters-2",
    "href": "api/ftm.html#parameters-2",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nn_max_modes: int The number of angular modes. m_max_modes: int The number of radial modes. radius: float The radius of the drumhead.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#returns-2",
    "href": "api/ftm.html#returns-2",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\nwavenumbers: np.ndarray The wavenumbers for the drumhead.*\n\n\ndblintegral\n\n dblintegral (integrand, x, y, method='simpson')\n\nCompute the double integral of a function K over the domain x and y.\n\n# Example usage\nn_max_modes = 25\nm_max_modes = 25\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert K_inv.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\nassert K_fwd.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\n\\[\nK_{n,m}(r, \\varphi) = \\cos (n \\varphi) J_n\\left(\\mu_{n, m} \\frac{r}{R}\\right)\n\\]\nwhere \\(J_n\\) is the Bessel function of the first kind of order \\(n\\), and \\(\\mu_{n, m}\\) is the \\(m\\)-th root of the \\(n\\)-th order Bessel function of the first kind.\n\nwnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, length_x, length_y)\nassert np.allclose(plate_eigenfunctions(wnx, wny, grid_x, grid_y), K)\nassert np.allclose(plate_eigenvalues(wnx, wny), Lambda)\n\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\n\n\ninverse_STL\n\n inverse_STL (K:numpy.ndarray, u_bar:numpy.ndarray, length:float)\n\nCompute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes, n_gridpoints)\n\n\nu_bar\nndarray\n(n_modes, n_samples) or (n_modes,)\n\n\nlength\nfloat\nlength of the string\n\n\nReturns\nndarray\n\n\n\n\n\n\n\nforward_STL\n\n forward_STL (K:numpy.ndarray, u:numpy.ndarray, dx:float)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes, n_gridpoints)\n\n\nu\nndarray\n(n_gridpoints, n_samples) or (n_gridpoints,)\n\n\ndx\nfloat\ngrid spacing\n\n\nReturns\nndarray\nThe transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n\n\n\n\n\n\ninverse_STL_2d\n\n inverse_STL_2d (K:numpy.ndarray, u_bar:numpy.ndarray, l1:float, l2:float)\n\nCompute the inverse STL transform.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu_bar\nndarray\n(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n\n\nl1\nfloat\nlength in x\n\n\nl2\nfloat\nlength in y\n\n\nReturns\nndarray\nThe reconstructed signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n\n\n\n\n\n\nforward_STL_2d\n\n forward_STL_2d (K:numpy.ndarray, u:numpy.ndarray, x:float, y:float,\n                 use_simpson:bool=False)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nK\nndarray\n\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu\nndarray\n\n(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n\n\nx\nfloat\n\ngrid spacing\n\n\ny\nfloat\n\ngrid spacing\n\n\nuse_simpson\nbool\nFalse\n\n\n\nReturns\nndarray\n\nThe transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n\n\n\n\n\n\nevaluate_rectangular_eigenfunctions\n\n evaluate_rectangular_eigenfunctions (mn_indices:numpy.ndarray,\n                                      position:numpy.ndarray,\n                                      params:__main__.PlateParameters)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmn_indices\nndarray\n(n_modes, 2) selected mode indices\n\n\nposition\nndarray\n(2,) position to evaluate the eigenfunctions\n\n\nparams\nPlateParameters\n\n\n\nReturns\nndarray\n(n_modes,) mode gains of selected modes at the given position\n\n\n\n\n\n\nevaluate_string_eigenfunctions\n\n evaluate_string_eigenfunctions (indices:numpy.ndarray,\n                                 position:numpy.ndarray,\n                                 params:__main__.StringParameters)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nindices\nndarray\n(n_modes,) selected mode indices\n\n\nposition\nndarray\n(1,) position to evaluate the eigenfunctions\n\n\nparams\nStringParameters\n\n\n\nReturns\nndarray\n(n_modes,) mode gains of selected modes at the given position\n\n\n\n\nlength_x = 1.08\nlength_y = 0.8\nn_max_modes_x = 25\nn_max_modes_y = 25\nn_gridpoints_x = 100\nn_gridpoints_y = 100\n\nx = np.linspace(0, length_x, n_gridpoints_x)\ny = np.linspace(0, length_y, n_gridpoints_y)\n\nwnx, wny = plate_wavenumbers(\n    n_max_modes_x,\n    n_max_modes_y,\n    length_x,\n    length_y,\n)\nK = plate_eigenfunctions(wnx, wny, x, y)\n\ng = 0.5 * K[2, 2] + 0.5 * K[3, 3]\n\nbar_g = forward_STL_2d(K, g, x, y, use_simpson=True)\ng_reconstructed = inverse_STL_2d(K, bar_g, length_x, length_y)\n\nassert np.allclose(g, g_reconstructed, atol=1e-2)\n\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\n\nax[0].imshow(g, origin=\"lower\", aspect=\"auto\")\nax[0].set_title(\"Original excitation\")\nax[1].imshow(g_reconstructed, origin=\"lower\", aspect=\"auto\")\nax[1].set_title(\"Reconstructed excitation\")\n\nText(0.5, 1.0, 'Reconstructed excitation')\n\n\n\n\n\n\n\n\n\n\n\n\ninverse_STL_drumhead\n\n inverse_STL_drumhead (K_inv:numpy.ndarray, u_bar:numpy.ndarray)\n\nCompute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK_inv\nndarray\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu_bar\nndarray\n(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n\n\nReturns\nndarray\n\n\n\n\n\n\n\nforward_STL_drumhead\n\n forward_STL_drumhead (K:numpy.ndarray, u:numpy.ndarray, r:numpy.ndarray,\n                       theta:numpy.ndarray, use_simpson:bool=False)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule or Simpson’s rule.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nK\nndarray\n\n(n_modes_r, n_modes_theta, n_gridpoints_r, n_gridpoints_theta)\n\n\nu\nndarray\n\n(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n\n\nr\nndarray\n\nradial grid\n\n\ntheta\nndarray\n\nangular grid\n\n\nuse_simpson\nbool\nFalse\n\n\n\nReturns\nndarray\n\n\n\n\n\n\n# Example usage\nn_max_modes = 10\nm_max_modes = 10\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert np.allclose(\n    K_fwd.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\nassert np.allclose(\n    K_inv.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\n\n# Create an example g array to test the transforms\ng = K_fwd[3, 3]\n\nbar_g = forward_STL_drumhead(K_fwd, g, r, theta, use_simpson=False)\ng_reconstructed = inverse_STL_drumhead(K_inv, bar_g)\n\n# Verify if g can be reconstructed\nassert np.allclose(g, g_reconstructed, atol=1e-2)\nprint(g.min(), g.max())\nprint(g_reconstructed.min(), g_reconstructed.max())\n\n# Plot using pcolormesh\nfig, ax = plt.subplots(\n    1,\n    2,\n    subplot_kw={\"projection\": \"polar\"},\n    figsize=(10, 5),\n)\nc = ax[0].pcolormesh(theta, r, g, shading=\"auto\", cmap=\"viridis\")\nc = ax[1].pcolormesh(theta, r, g_reconstructed, shading=\"auto\", cmap=\"viridis\")\n\n-0.4320502477222054 0.43401550352665574\n-0.4320519880367027 0.4340172517572766\n\n\n\n\n\n\n\n\n\n\n\n\nstiffness_term\n\n stiffness_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)\n\n\n\n\ndamping_term_simple\n\n damping_term_simple (lambda_mu:jax.Array, factor:float=0.001)\n\n\n\n\ndamping_term\n\n damping_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)\n\n\n\n\neigenvalues_from_pde\n\n eigenvalues_from_pde (pars:__main__.PhysicalParameters,\n                       lambda_mu:jax.Array)\n\nCompute the positive imaginary side of the eigenvalues of the continuous-time system from the PDE parameters.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npars\nPhysicalParameters\nThe physical parameters of the system.\n\n\nlambda_mu\nArray\nThe eigenvalues of the decompostion of the Laplacian operator.\n\n\nReturns\nArray\nThe eigenvalues of the continuous-time system.\n\n\n\nSome example use. Note that this is just a preview of how all the modes sound when excited at once. In a real setting they must be weighted with the eigenfunctions and the initial conditions or modal excitation.\n\nn_max_modes = 30\nsr = 44100\ndt = 1 / sr\nfinal_time = 1.0\nn_samples = int(final_time / dt)\np_params = StringParameters()\nlambda_mu = string_eigenvalues(n_max_modes, p_params.length)\neigvals = eigenvalues_from_pde(p_params, lambda_mu)\n\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\ndisplay(Audio(states.sum(0), rate=sr))\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\nsr = 44100\ndt = 1 / sr\nn_modes_x = 8\nn_modes_y = 8\nn_modes = n_modes_x * n_modes_y\nfinal_time = 6.0\nn_samples = int(final_time / dt)\n\np_params = PlateParameters()\nwnx, wny = plate_wavenumbers(\n    n_max_modes_x,\n    n_max_modes_y,\n    p_params.l1,\n    p_params.l2,\n)\nlambda_mu = plate_eigenvalues(wnx, wny)\nlambda_mu = np.sort(lambda_mu.reshape(-1))[:n_modes]\neigvals = eigenvalues_from_pde(p_params, lambda_mu)\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\ndisplay(Audio(states.sum(0), rate=sr))\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\nsr = 44100\ndt = 1 / sr\nn_modes_x = 8\nn_modes_y = 8\nn_modes = n_modes_x * n_modes_y\nfinal_time = 2.0\nn_samples = int(final_time / dt)\np_params = CircularDrumHeadParameters.avanzini()\n\nwn = drumhead_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.r0)\nlambda_mu = np.sort(drumhead_eigenvalues(wn).reshape(-1))[:n_modes]\neigvals = eigenvalues_from_pde(p_params, lambda_mu)\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\ndisplay(Audio(states[0], rate=sr))\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\n\n\nsample_parallel_tf\n\n sample_parallel_tf (num:numpy.ndarray, den:numpy.ndarray, dt:float,\n                     method:str='impulse')\n\nSample multiple transfer functions.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnum\nndarray\n\n(n_modes,)\n\n\nden\nndarray\n\n(n_modes,)\n\n\ndt\nfloat\n\n\n\n\nmethod\nstr\nimpulse\n\n\n\nReturns\nnp.ndarray\n\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_continuous_2\n\n tf_initial_conditions_continuous_2 (D:float, density:float, d1:float,\n                                     d3:float, Ts0:float,\n                                     lambda_mu:&lt;function array&gt;)\n\nConpute the continuous-time initial condition transfer function. This is an alternative to the function tf_initial_conditions_continuous that eigenvalues of the PDE as input.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nD\nfloat\nThe bending stiffness of the string or plate.\n\n\ndensity\nfloat\nThe area or surface density of the string or plate.\n\n\nd1\nfloat\nThe linear damping coefficient, or frequency-independent damping.\n\n\nd3\nfloat\nThe cubic damping coefficient, or frequency-dependent damping.\n\n\nTs0\nfloat\nThe initial tension of the string or plate.\n\n\nlambda_mu\narray\nThe eigenvalues from the decomposition of the Laplacian operator.\n\n\nReturns\ntuple\nThe numerator and denominator of the transfer function.\n\n\n\n\n\n\ntf_excitation_discrete\n\n tf_excitation_discrete (eigenvalues:numpy.ndarray, density:float,\n                         dt:float)\n\nCompute the discrete-time excitation transfer function of a system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndensity\nfloat\nsurface or area density\n\n\ndt\nfloat\ntime step\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_excitation_continuous\n\n tf_excitation_continuous (eigenvalues:numpy.ndarray, density:float)\n\nCompute the continuous excitation transfer function.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndensity\nfloat\nsurface or area density\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_discrete\n\n tf_initial_conditions_discrete (eigenvalues:numpy.ndarray, dt:float)\n\nCompute the discrete-time initial conditions transfer function of a system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndt\nfloat\ntime step\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_continuous\n\n tf_initial_conditions_continuous (eigenvalues:numpy.ndarray)\n\nCompute the continuos “initial-conditions” transfer function from the eigenvalues of the system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\nb, a = tf_excitation_discrete(eigvals, p_params.density, dt)\nb_ic, a_ic = tf_initial_conditions_discrete(eigvals, dt)\n\n# manual discretization\neigenvalues_d = np.exp(eigvals * dt)\n\n# for the excitation tf\nb1 = (\n    np.exp(eigvals.real * dt)\n    * np.sin(eigvals.imag * dt)\n    / eigvals.imag\n    / p_params.density\n)\n\n# for the initial conditions tf\n# here we ignore initial velocity\nr = np.exp(eigvals.real * dt)\nb1_ic = r * np.sin(eigvals.imag * dt) / eigvals.imag * -eigvals.real - r * np.cos(\n    eigvals.imag * dt\n)\n\na1 = -2 * np.exp(eigvals.real * dt) * np.cos(eigvals.imag * dt)\na2 = np.exp(2 * eigvals.real * dt)\nb_manual = np.stack([np.zeros_like(b1), b1, np.zeros_like(b1)], axis=-1) * dt\na_manual = np.stack([np.ones_like(a1), a1, a2], axis=-1)\n\nb_ic_manual = np.stack([np.ones_like(b1_ic), b1_ic], axis=-1) * dt\n\nprint(b[0])\nprint(b_manual[0])\nprint(b_ic[0] * sr)\nprint(b_ic_manual[0] * sr)\nassert np.allclose(b[:, 1], b_manual[:, 1])\nassert np.allclose(a, a_manual)\nassert np.allclose(b_ic[:, :2], b_ic_manual[:, :2])\n\n[0.00000000e+00 1.90416682e-09 1.11022302e-16]\n[0.00000000e+00 1.90416703e-09 0.00000000e+00]\n[ 1.00000000e+00 -9.99682425e-01  2.93765012e-11]\n[ 1.         -0.99968243]",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/utils.html",
    "href": "api/utils.html",
    "title": "Utils",
    "section": "",
    "text": "Utilities for visualisation and filtering.\n\n\nnext_root\n\n next_root (x)\n\n\n\n\nsafe_log\n\n safe_log (x, eps=1e-10)\n\n\n\n\nto_db\n\n to_db (x)\n\n\n\n\nimpulse_response\n\n impulse_response (b:jax.Array, a:jax.Array, n=4410)\n\nCompute the impulse response of a discrete time system\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nb\nArray\n\nnumerators of the discrete transfer function\n\n\na\nArray\n\ndenominators of the discrete transfer function\n\n\nn\nint\n4410\n\n\n\nReturns\njnp.ndarray\n\nThe impulse response of the system, with shape (n_modes, n)\n\n\n\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\n\n\niir_filter_parallel\n\n iir_filter_parallel (b, a, x)\n\nEfficient parallel IIR filter implementation using JAX.\n\n\n\n\nDetails\n\n\n\n\nb\nshape (n_modes, 3)\n\n\na\nshape (n_modes, 3)\n\n\nx\nshape (n_samples,)\n\n\n\n\n\n\nplot_poles_zeros\n\n plot_poles_zeros (p:numpy.ndarray, ax=None, xlim=(-1.1, 1.1), ylim=(-1.1,\n                   1.1), show_unit_circle=True, save_path=None, **kwargs)\n\n*Plot poles and zeros on a 2D complex plane with customizable axis limits.\nArgs: p (np.ndarray): Array of complex poles/zeros, will be flattened. ax (matplotlib.axes._subplots.AxesSubplot, optional): Pre-existing axis to plot on. xlim (tuple, optional): Limits for the x-axis (real part). ylim (tuple, optional): Limits for the y-axis (imaginary part). show_unit_circle (bool, optional): Whether to show the unit circle. save_path (str, optional): File path to save the plot. **kwargs: Additional keyword arguments passed to scatter plot.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\np\nndarray\n\nArray of zeros or poles (any shape)\n\n\nax\nNoneType\nNone\n\n\n\nxlim\ntuple\n(-1.1, 1.1)\nDefault x-axis limits\n\n\nylim\ntuple\n(-1.1, 1.1)\nDefault y-axis limits\n\n\nshow_unit_circle\nbool\nTrue\nOption to show the unit circle\n\n\nsave_path\nNoneType\nNone\nOptional file path to save the plot\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\n\n\nhz2bark\n\n hz2bark (f)\n\n\n\n\nbark2hz\n\n bark2hz (b)\n\n\n\n\nhz2mel\n\n hz2mel (h)\n\n\n\n\nmel2hz\n\n mel2hz (m)\n\n\n\n\ntf_freqs\n\n tf_freqs (b:jax.Array, a:jax.Array, s:jax.Array)\n\nSample the frequency response of a transfer functions.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nb\nArray\nnumerator (n_modes, 3)\n\n\na\nArray\ndenominator (n_modes, 3)\n\n\ns\nArray\nfrequency (n_freqs,)\n\n\nReturns\nArray\nThe frequency response of the transfer function.\n\n\n\n\n\n\ntf_freqz\n\n tf_freqz (b:jax.Array, a:jax.Array, worN:jax.Array, sample_rate:int)\n\nSample the frequency response of the transfer functions.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nb\nArray\nnumerator (n_modes, 3)\n\n\na\nArray\ndenominator (n_modes, 3)\n\n\nworN\nArray\nfrequencies (n_freqs,)\n\n\nsample_rate\nint\nThe sample rate in Hz of the transfer function\n\n\nReturns\njnp.ndarray\nThe frequency response of the transfer function\n\n\n\n\n\n\ncompute_spectrogram\n\n compute_spectrogram (signal:numpy.ndarray, sample_rate:int, n_fft:int,\n                      hop_length:int, max_freq:float=None,\n                      time_limit_s:float=0.5)\n\n\n\n\ndisplay_audio_with_title\n\n display_audio_with_title (audio_data, sample_rate, title)\n\nDisplay audio with a title next to it in a Jupyter notebook.",
    "crumbs": [
      "API",
      "Utils"
    ]
  },
  {
    "objectID": "api/num_utils.html",
    "href": "api/num_utils.html",
    "title": "Numerical utilities",
    "section": "",
    "text": "These are some numerical utilities to compute the modes for the von Kármán plate and to process the modes.\nThe modes for different boundary conditions are computed using the magpie-python package.\nThe processing of the modes is done using a port of the vkplate Matlab code.",
    "crumbs": [
      "API",
      "Numerical utilities"
    ]
  },
  {
    "objectID": "api/num_utils.html#modal-pruning",
    "href": "api/num_utils.html#modal-pruning",
    "title": "Numerical utilities",
    "section": "Modal pruning",
    "text": "Modal pruning\n\n\npolarisation\n\n polarisation (interpolated_eigenvectors, eigenvectors, h)\n\n\n\n\neigenMAC\n\n eigenMAC (ref_eigenvectors, ref_nx, ref_ny, eigenvectors, eigenvalues,\n           nx, ny, n_modes, Lx, Ly, h)\n\n*Computes the Modal Assurance Criterion (MAC) between reference eigenvectors and given eigenvectors.\nThe Modal Assurance Criterion (MAC) between two eigenvectors (mode shapes) \\(\\Phi_i\\) and \\(\\Phi_j\\) is:\n\\[\n\\mathrm{MAC}(\\Phi_i,\\Phi_j) =\n\\frac{|\\Phi_i^{T}\\,\\Phi_j|^{2}}\n    {\\left(\\Phi_i^{T}\\,\\Phi_i\\right)\\,\\left(\\Phi_j^{T}\\,\\Phi_j\\right)}.\n\\]\nMAC measures the degree of similarity (or consistency) between the two mode shapes. A value of 1 indicates identical shapes (up to a scalar), while a value near 0 indicates they are nearly orthogonal.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nref_eigenvectors\nndarray\nReference eigenvectors (reshaped for interpolation).\n\n\nref_nx\nint\nNumber of reference grid points along the x-axis.\n\n\nref_ny\nint\nNumber of reference grid points along the y-axis.\n\n\neigenvectors\nndarray\nEigenvectors to compare against the reference.\n\n\neigenvalues\nndarray\nCorresponding eigenvalues of the eigenvectors.\n\n\nnx\nint\nNumber of grid points along the x-axis for interpolation.\n\n\nny\nint\nNumber of grid points along the y-axis for interpolation.\n\n\nn_modes\nint\nNumber of modes to compare.\n\n\nLx\nfloat\nLength of the domain along the x-axis.\n\n\nLy\nfloat\nLength of the domain along the y-axis.\n\n\nh\n\n\n\n\nReturns\nndarray\nReordered eigenvectors after MAC computation.",
    "crumbs": [
      "API",
      "Numerical utilities"
    ]
  },
  {
    "objectID": "api/num_utils.html#biharmonic-decomposition",
    "href": "api/num_utils.html#biharmonic-decomposition",
    "title": "Numerical utilities",
    "section": "Biharmonic decomposition",
    "text": "Biharmonic decomposition\nComputes the eigenvalue decomposition of the biharmonic operator for the plate:\n\\[\n\\Delta \\Delta \\Phi_p(x, y)=\\frac{\\rho h}{D} \\lambda_p^2 \\Phi_p(x, y) .\n\\]\n\\(\\rho\\), \\(h\\) and \\(D\\) are density, tickness and bending stiffness of the plate, respectively.\n\n\nbiharmonic_eigendecomposition\n\n biharmonic_eigendecomposition (params:jaxdiffmodal.ftm.PlateParameters,\n                                n_modes:int, bcs:numpy.ndarray, nx:int,\n                                ny:int, h:float,\n                                normalise_eigenvectors=True)\n\n*Computes the eigenvalue decomposition of the biharmonic operator for a plate with the given parameters and boundary conditions.\nAdditionally it sorts the eigenvalues and eigenvectors in ascending order, and normalises the eigenvectors if requested.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\nPlateParameters\n\nThe parameters of the plate.\n\n\nn_modes\nint\n\nThe number of modes to compute.\n\n\nbcs\nndarray\n\nThe boundary conditions of the plate.\n\n\nnx\nint\n\nThe number of points in the x direction.\n\n\nny\nint\n\nThe number of points in the y direction.\n\n\nh\nfloat\n\nThe spacing between points.\n\n\nnormalise_eigenvectors\nbool\nTrue\nWhether to normalise the eigenvectors.\n\n\nReturns\nTuple[np.ndarray, np.ndarray, np.ndarray]\n\nThe eigenvalues, eigenvectors and norms of the eigenvectors.\n\n\n\n\n\n\nmultiresolution_eigendecomposition\n\n multiresolution_eigendecomposition\n                                     (params:jaxdiffmodal.ftm.PlateParamet\n                                     ers, n_modes:int, bcs:numpy.ndarray,\n                                     h:float, nx:int, ny:int,\n                                     levels:int=2)\n\nRuns the biharmonic eigendecomposition and eigenvector alignment on multiple grid resolutions.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\nPlateParameters\n\n\n\n\nn_modes\nint\n\nNumber of eigenmodes to compute.\n\n\nbcs\nndarray\n\nBoundary conditions.\n\n\nh\nfloat\n\nInitial grid spacing.\n\n\nnx\nint\n\nNumber of grid points in the x-direction.\n\n\nny\nint\n\nNumber of grid points in the y-direction.\n\n\nlevels\nint\n2\nTotal number of resolutions to run (default 2).The first level is the coarse grid, and each subsequent leveluses h/2 and double the grid points to cover the same domain.\n\n\nReturns\nswapped_eigenvectors, swapped_eigenvalues from the last refinement.",
    "crumbs": [
      "API",
      "Numerical utilities"
    ]
  }
]