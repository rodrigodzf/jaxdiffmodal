[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Getting Started",
    "section": "",
    "text": "This code is based on the matlab implementation of the Von Karman plate model found here and the analytical/Galerkin solution for the simply supported plate found here.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "index.html#installation-for-development",
    "href": "index.html#installation-for-development",
    "title": "Getting Started",
    "section": "Installation for Development",
    "text": "Installation for Development\nIt is strongly recommended to use the uv package manager to install the environment and dependencies.\nuv sync --all-extras\notherwise you can create a virtual environment and install the dependencies manually:\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e .",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Getting Started",
    "section": "How to use",
    "text": "How to use\nOnce everything is installed, you can run the vkplate_opt.ipynb notebook.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "api/losses.html",
    "href": "api/losses.html",
    "title": "Losses",
    "section": "",
    "text": "import matplotlib.pyplot as plt\n\n\n\nwasserstein_1d\n\n wasserstein_1d (u_values, v_values, u_weights=None, v_weights=None, p=1,\n                 require_sort=True)\n\n*Computes the 1 dimensional OT loss [15] between two (batched) empirical distributions\n.. math: OT_{loss} = _0^1 |cdf_u^{-1}(q) - cdf_v{-1}(q)|p dq\nIt is formally the p-Wasserstein distance raised to the power p. We do so in a vectorized way by first building the individual quantile functions then integrating them.\nThis function should be preferred to emd_1d whenever the backend is different to numpy, and when gradients over either sample positions or weights are required.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nu_values\n\n\n\n\n\nv_values\n\n\n\n\n\nu_weights\nNoneType\nNone\n\n\n\nv_weights\nNoneType\nNone\n\n\n\np\nint\n1\n\n\n\nrequire_sort\nbool\nTrue\n\n\n\nReturns\ncost: float/array-like, shape (…)\n\nthe batched EMD\n\n\n\n\n\n\nquantile_function\n\n quantile_function (qs, cws, xs)\n\nComputes the quantile function of an empirical distribution\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nqs\n\n\n\n\ncws\n\n\n\n\nxs\n\n\n\n\nReturns\nq: array-like, shape (…, n)\nThe quantiles of the distribution\n\n\n\n\n\n\ncompute_mag\n\n compute_mag (x:jax.Array)\n\n\n\n\n\nType\nDetails\n\n\n\n\nx\nArray\n(b, t)\n\n\nReturns\nArray\n\n\n\n\n\n\n\nspectral_wasserstein\n\n spectral_wasserstein (x, y, squared=True, is_mag=False)\n\n\n\n\nlog_mag_loss\n\n log_mag_loss (pred:jax.Array, target:jax.Array, eps:float=1e-10,\n               distance:str='l1')\n\nSpectral log magtinude loss but for a fft of a signal See Arik et al., 2018\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npred\nArray\n\ncomplex valued fft of the signal\n\n\ntarget\nArray\n\ncomplex valued fft of the signal\n\n\neps\nfloat\n1e-10\n\n\n\ndistance\nstr\nl1\n\n\n\n\n\n\n\nlog_mag\n\n log_mag (x:jax.Array, eps:float=1e-10)\n\n\nphase = 0.0\nomegas = jax.random.uniform(jax.random.PRNGKey(0), shape=(10,)) * 100\nmag = 0.99\n\n\ndef osc_bank(t, omegas):\n    return mag * jnp.sin(omegas[..., None] * jnp.pi * 2 * t[None] + phase)\n\n\nt = jnp.linspace(0, 1, 1000)\ngt_osc_values = osc_bank(t, omegas)\n# print(gt_osc_values)\nprint(gt_osc_values.shape)\n\n(10, 1000)\n\n\n\na = jax.vmap(spectral_wasserstein)(gt_osc_values, gt_osc_values)\nprint(a)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\ndef loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n    x_fft = compute_mag(gt_osc_values)\n    y_fft = compute_mag(pred_osc_values)\n    l2_mag_loss = jnp.mean((x_fft - y_fft) ** 2)\n    return l2_mag_loss\n\n\ndef ot_loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n\n    ot_loss = jnp.mean(\n        jax.vmap(spectral_wasserstein)(gt_osc_values, pred_osc_values),\n    )\n    return ot_loss\n\n\nx_fft = compute_mag(gt_osc_values) ** 2\nplt.plot(x_fft[:5].T)\n\n\n\n\n\n\n\n\n\nranges = jnp.linspace(-50, 50, 100)\nomegas_scan = omegas + ranges[:, None]\n\n# print(omegas_scan.shape)\nloss, grad = jax.vmap(jax.value_and_grad(loss_fn))(omegas_scan)\nloss_ot, grad_ot = jax.vmap(jax.value_and_grad(ot_loss_fn))(omegas_scan)\n\nprint(loss.shape, loss.dtype)\nprint(loss_ot.shape, loss_ot.dtype)\n# loss_mean = jnp.mean(loss, axis=1)\n# loss_ot_mean = jnp.mean(loss_ot, axis=-1)\n# print(loss_mean.shape)\n# plt.plot(ranges, loss)\nplt.plot(ranges, loss_ot)\n\n(100,) float32\n(100,) float32\n\n\n\n\n\n\n\n\n\n\nomegas_gt = jax.random.uniform(jax.random.PRNGKey(0), shape=(10,)) * 1000\nomegas_pred = omegas_gt * 1\n\npred_osc_values = osc_bank(t, omegas_pred).mean(axis=0)\ngt_osc_values = osc_bank(t, omegas_gt)\n\nx_mag = compute_mag(gt_osc_values.mean(axis=0))\ny_mag = compute_mag(pred_osc_values)\n\nplt.semilogx(x_mag)\nplt.semilogx(y_mag)\n\n\n\n\n\n\n\n\n\n# from ott.solvers.linear import solve_univariate\nfrom ott.solvers.linear.univariate import quantile_solver\nfrom ott.geometry.pointcloud import PointCloud\nfrom ott.problems.linear import linear_problem\nfrom ott.solvers.linear import sinkhorn\nfrom ott.solvers import linear\n\n\ndef wasserstein_1d_jax(\n    x,\n    y,\n):\n    geom = PointCloud(x, y)\n    # prob = linear_problem.LinearProblem(geom)\n    out = linear.solve(geom)\n    return out.reg_ot_cost\n\n\n# def wasserstein_1d_jax(\n#     x: jnp.ndarray,\n#     y: jnp.ndarray,\n#     a: jnp.ndarray | None = None,\n#     b: jnp.ndarray | None = None,\n# ):\n#     geom = PointCloud(x[..., None], y[..., None])\n#     prob = linear_problem.LinearProblem(geom, a=a, b=b)\n#     out = quantile_solver(prob)\n#     return jnp.average(out.ot_costs)\n\n\ndef sinkhorn_loss(\n    x,\n    y,\n    a,\n    b,\n    epsilon=1e-1,\n    threshold=1e-3,\n):\n    geom = PointCloud(x[..., None], y[..., None], epsilon=epsilon)\n\n    out = linear.solve(geom, a=a, b=b)\n    return out.reg_ot_cost\n\n    # prob = linear_problem.LinearProblem(geom, a=a, b=b)\n    # solver = sinkhorn.Sinkhorn(\n    #     threshold=threshold,\n    #     max_iterations=1000,\n    #     norm_error=2,\n    #     lse_mode=True,\n    # )\n    # out = solver(prob)\n    # out.reg_ot_cost\n    # return jnp.average(out.ot_costs)\n\n\nx_pos = jnp.linspace(0, 1, x_mag.shape[-1])\nstacked_x = jnp.stack([x_pos, x_mag], axis=-1)\nstacked_y = jnp.stack([x_pos, x_mag], axis=-1)\n\nprint(stacked_x.shape, stacked_y.shape)\n\not_costs_jax = wasserstein_1d_jax(stacked_x, stacked_y)\nprint(ot_costs_jax)\n\n(501, 2) (501, 2)\n0.017973557\n\n\n\nx_mag = x_mag / jnp.sum(x_mag)\ny_mag = y_mag / jnp.sum(y_mag)\nx_pos = jnp.linspace(0, 1, x_mag.shape[-1])\n\not_costs = wasserstein_1d(x_pos, x_pos, x_mag, y_mag)\nprint(ot_costs)\n\n0.0\n\n\n\nstacked = jnp.stack([x_pos, x_mag], axis=-1)\nprint(stacked.shape)\n# plt.scatter(stacked[:, 0], stacked[:, 1])\n\n(501, 2)\n\n\n\ndef loss_fn_ot(factor):\n    pred_osc_values = osc_bank(t, omegas_gt * factor)\n    # x_mag = compute_mag(gt_osc_values)\n    # y_mag = compute_mag(pred_osc_values)\n    # x_mag = x_mag / jnp.sum(x_mag)\n    # y_mag = y_mag / jnp.sum(y_mag)\n    # x_pos = jnp.linspace(0, 1, x_mag.shape[-1])\n    # ot_cost = wasserstein_1d(x_pos, x_pos, x_mag, y_mag)\n\n    ot_cost = jnp.mean(\n        jax.vmap(spectral_wasserstein)(gt_osc_values, pred_osc_values),\n    )\n    return ot_cost\n\n\ndef loss_fn_ot_jax(factor):\n    pred_osc_values = osc_bank(t, omegas_gt * factor).mean(axis=0)\n    x_mag = jnp.log(compute_mag(gt_osc_values.mean(axis=0)))\n    y_mag = jnp.log(compute_mag(pred_osc_values))\n    x_mag = x_mag / jnp.sum(x_mag)\n    y_mag = y_mag / jnp.sum(y_mag)\n\n    x_pos = jnp.linspace(0, 1, x_mag.shape[-1])\n    stacked_x = jnp.stack([x_pos, x_mag], axis=-1)\n    stacked_y = jnp.stack([x_pos, y_mag], axis=-1)\n\n    ot_cost = wasserstein_1d_jax(stacked_x, stacked_y)\n    return ot_cost\n\n\ndef loss_fn_sinkhorn(factor):\n    pred_osc_values = osc_bank(t, omegas_gt * factor).mean(axis=0)\n    x_mag = compute_mag(gt_osc_values.mean(axis=0))\n    y_mag = compute_mag(pred_osc_values)\n    x_mag = x_mag / jnp.sum(x_mag)\n    y_mag = y_mag / jnp.sum(y_mag)\n    x_pos = jnp.linspace(0, 1, x_mag.shape[-1])\n    return sinkhorn_loss(x_pos, x_pos, x_mag, y_mag)\n\n\nranges = jnp.linspace(0.8, 1.1, 100)\n\n# print(omegas_scan.shape)\nloss_ot, grad_ot = jax.vmap(jax.value_and_grad(loss_fn_ot))(ranges)\nloss_ot_jax, grad_ot_jax = jax.vmap(jax.value_and_grad(loss_fn_ot_jax))(ranges)\nloss_sinkhorn, grad_sinkhorn = jax.vmap(jax.value_and_grad(loss_fn_sinkhorn))(ranges)\n\nfig, ax = plt.subplots(1, 1)\n# ax.plot(ranges, loss_ot)\nax.plot(ranges, loss_ot_jax * 10)\n# ax.plot(ranges, loss_sinkhorn * 10)\n\n\n\n\n\n\n\n\n\n\n\nspectral_convergence_loss\n\n spectral_convergence_loss (pred:jax.Array, target:jax.Array)\n\nSpectral convergence loss but for a fft of a signal See Arik et al., 2018\n\n\n\n\nType\nDetails\n\n\n\n\npred\nArray\nmagnitude of the fft of the predicted signal\n\n\ntarget\nArray\nmagnitude of the fft of the target signal",
    "crumbs": [
      "API",
      "Losses"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters",
    "href": "api/lpc.html#parameters",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: np.ndarray The input signal. p: int The order of the LPC. method: str The method to compute the LPC. Either “autocorrelation” or “covariance”.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#returns",
    "href": "api/lpc.html#returns",
    "title": "LPC",
    "section": "Returns:",
    "text": "Returns:\nnp.ndarray The LPC coefficients. int The gain (or the square root of the energy) of the residual signal.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nndarray\n\n(time,)\n\n\np\nint\n\norder\n\n\nmethod\nstr\nautocorrelation\nmethod for the lpc computation\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\nReturns\nTuple\n\nadditional arguments for the method\n\n\n\n\n\njitted_linear_solve\n\n jitted_linear_solve (x, p)\n\n\n\n\njitted_lstsq\n\n jitted_lstsq (x, p)\n\n\nx = np.random.randn(100)\n\np = 4\na_autocorr, g_autocorr = lpc_cpu_solve(x, p, method=\"autocorrelation\", biased=False)\na_covar, g_covar = lpc_cpu_solve(x, p, method=\"covariance\")\n\nprint(a_autocorr, g_autocorr)\nprint(a_covar, g_covar)\n\n[-0.03891267  0.05897309 -0.11110881 -0.10518435] 8.848879174571616\n[-0.05351606  0.04524858 -0.09969181 -0.10755192] 8.666443074154966\n\n\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nComputes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n---------- in \nComputes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\n\n\nlinear_prediction\n\n linear_prediction (x:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.numbe\n                    r,bool,int,float,complex], a:Union[jax.Array,numpy.nda\n                    rray,numpy.bool,numpy.number,bool,int,float,complex])\n\n*Computes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters-1",
    "href": "api/lpc.html#parameters-1",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: ArrayLike The signal used to compute the linear prediction a: ArrayLike The coefficients of the linear prediction*\n\n\n\n\nType\nDetails\n\n\n\n\nx\nUnion\n(T)\n\n\na\nUnion\n(p)\n\n\nReturns\nUnion\n\n\n\n\n\n\nlinear_prediction_np\n\n linear_prediction_np (x:numpy.ndarray, a:numpy.ndarray)\n\n*Computes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters-2",
    "href": "api/lpc.html#parameters-2",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: ArrayLike The signal used to compute the linear prediction a: ArrayLike The coefficients of the linear prediction*\n\n\n\n\nType\nDetails\n\n\n\n\nx\nndarray\n(T,)\n\n\na\nndarray\n(p,)\n\n\nReturns\nndarray\n\n\n\n\n\nrng = np.random.default_rng(42)\nx = rng.normal(0, 1, 100)\na = rng.normal(0, 1, 4)\n\nlp_np = linear_prediction_np(x, a)\nlp_jax = linear_prediction(x, a)\n\nassert np.allclose(lp_np, lp_jax)\n\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nComputes the inverse filter of a signal x using the coefficients a.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n---------- in \nComputes the inverse filter of a signal x using the coefficients a.\n...\n  else: warn(msg)\n\n\ninverse_filter_np\n\n inverse_filter_np (x:numpy.ndarray, a:numpy.ndarray)\n\n*Computes the inverse filter of a signal x using the coefficients a.",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/lpc.html#parameters-3",
    "href": "api/lpc.html#parameters-3",
    "title": "LPC",
    "section": "Parameters:",
    "text": "Parameters:\nx: ArrayLike The signal used to compute the inverse filter a: ArrayLike The coefficients of the linear prediction*\n\n\n\n\nType\nDetails\n\n\n\n\nx\nndarray\n(T,)\n\n\na\nndarray\n(p,)\n\n\nReturns\nndarray\n\n\n\n\n\n\ncoeffs_and_residual\n\n coeffs_and_residual (y:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.num\n                      ber,bool,int,float,complex], p:int, **kwargs)\n\nUtility function to compute the LPC coefficients and the residual.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ny\nUnion\ninput signal (time,)\n\n\np\nint\nnumber of coefficients\n\n\nkwargs\nVAR_KEYWORD\n\n\n\nReturns\nTuple\ncoefficients (p+1) and residual and gain\n\n\n\n\nrng = np.random.default_rng(42)\nx = rng.normal(size=1000)\npole = np.array([0.999 * np.exp(1j * np.pi / 4)])\npoles = np.concatenate([pole, np.conj(pole)])\nb, a = scipy.signal.zpk2tf([], poles, 1)\ny = scipy.signal.lfilter(b, a, x)\n\np = 10\na_autocorr, e_hat_autocorr, _ = coeffs_and_residual(x, p, method=\"autocorrelation\")\na_covar, e_hat_covar, _ = coeffs_and_residual(x, p, method=\"covariance\")",
    "crumbs": [
      "API",
      "LPC"
    ]
  },
  {
    "objectID": "api/time_integrators.html",
    "href": "api/time_integrators.html",
    "title": "Time integrators",
    "section": "",
    "text": "A collection of efficient time integration methods for the damped oscillator with optional nonlinearities and initial conditions or excitation inputs.",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/time_integrators.html#stormer-verlet",
    "href": "api/time_integrators.html#stormer-verlet",
    "title": "Time integrators",
    "section": "Stormer-verlet",
    "text": "Stormer-verlet\nThe stormer-verlet is a centered difference scheme used to approximate derivatives. In the present case we use it for approximating the second and first derivatives of an oscillator defined by the following differential equation:\n\\[\n\\ddot{q} + c \\dot{q} + k q = f(t)\n\\]\nThe finite difference operators are defined as:\n\\[\n\\begin{align}\n\\delta_t q &= \\frac{q^{n+1} - q^{n-1}}{2 h} \\\\\n\\delta_{tt} q &= \\frac{q^{n+1} - 2 q^n + q^{n-1}}{h^2}\n\\end{align}\n\\]\nfor the first derivative and the second derivative respectively. The difference equation for the oscillator is then:\n\\[\n\\delta_{tt} q + c \\delta_t q + k q = f(t)\n\\]\nafter expanding and some algebraic manipulation to isolate \\(q^{n+1}\\) we get:\n\\[\n\\bigl(\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\bigr)\\,q^{n+1} +\n\\bigl(-\\tfrac{2}{h^2} + k\\bigr) q^n +\n\\bigl(\\tfrac{1}{h^2} - \\tfrac{c}{2h}\\bigr)\\,q^{n-1} =\nf(t^n).\n\\]\n\\[\n\\boxed{\nq^{n+1} = \\frac{2 h^2}{2 + c h}\n\\Bigl[\nf(t^n) + \\Bigl(\\tfrac{2}{h^2} - k\\Bigr) q^n +\n\\Bigl(-\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\Bigr) q^{n-1}\n\\Bigr].\n}\n\\]\nTo make it more readable we can define the following constants:\n\\[\n\\begin{align}\na &= \\frac{2 h^2}{2 + c h} \\\\\nb &= \\frac{2}{h^2} - k \\\\\nc &= -\\frac{1}{h^2} + \\frac{c}{2h}\n\\end{align}\n\\]\n\n\nmake_tm_nl_fn\n\n make_tm_nl_fn (lambda_mu, factors)\n\nReturns a function that computes nl given q.\n\n\n\nmake_vk_nl_fn\n\n make_vk_nl_fn (H)\n\nReturns a function that computes nl given q.\n\n\n\nmake_identity_nl_fn\n\n make_identity_nl_fn ()\n\n\n\n\nstring_tau_with_density\n\n string_tau_with_density (string_params)\n\n\n\n\nsecond_order_step\n\n second_order_step (u0:jax.Array, v0:jax.Array, dt:float,\n                    gamma2_mu:jax.Array, omega_mu_squared:jax.Array)\n\nOne step of 2nd-order Taylor expansion for damped oscillator. Returns: (u1, v1)\n\n\n\n\nType\nDetails\n\n\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\ntime step\n\n\ngamma2_mu\nArray\ndamping (n_modes,)\n\n\nomega_mu_squared\nArray\nfrequency (n_modes,)\n\n\n\n\n\n\nrk4_step\n\n rk4_step (u0:jax.Array, v0:jax.Array, dt:float, gamma2_mu:jax.Array,\n           omega_mu_squared:jax.Array)\n\nOne step of RK4 for the second-order damped oscillator. Returns: (u1, v1)\n\n\n\n\nType\nDetails\n\n\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\ntime step\n\n\ngamma2_mu\nArray\ndamping (n_modes,)\n\n\nomega_mu_squared\nArray\nfrequency (n_modes,)\n\n\n\n\n\n\nsolve_sv_initial_conditions\n\n solve_sv_initial_conditions (gamma2_mu, omega_mu_squared, u0:jax.Array,\n                              v0:jax.Array, dt:float, n_steps:int,\n                              nl_fn:collections.abc.Callable)\n\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n(n_modes,)\n\n\nomega_mu_squared\n\n(n_modes,)\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\n\n\n\nn_steps\nint\n\n\n\nnl_fn\nCallable\n\n\n\n\n\n\n\nsolve_sv_excitation\n\n solve_sv_excitation (gamma2_mu, omega_mu_squared,\n                      modal_excitation:jax.Array, dt:float,\n                      nl_fn:collections.abc.Callable)\n\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n(n_modes,)\n\n\nomega_mu_squared\n\n(n_modes,)\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\ndt\nfloat\n\n\n\nnl_fn\nCallable\n\n\n\n\n\n\n\nsolve_sv_vk_jax_scan\n\n solve_sv_vk_jax_scan (A_inv:jax.Array, B:jax.Array, C:jax.Array,\n                       modal_excitation:jax.Array,\n                       nl_fn:collections.abc.Callable)\n\n\n\n\n\nType\nDetails\n\n\n\n\nA_inv\nArray\n\n\n\nB\nArray\n\n\n\nC\nArray\n\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\nnl_fn\nCallable",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/time_integrators.html#discretised-transfer-function-method",
    "href": "api/time_integrators.html#discretised-transfer-function-method",
    "title": "Time integrators",
    "section": "Discretised transfer function method",
    "text": "Discretised transfer function method\n\n\nsolve_tf_initial_conditions\n\n solve_tf_initial_conditions (gamma2_mu, omega_mu_squared, u0:jax.Array,\n                              v0:jax.Array, dt:float, n_steps:int,\n                              nl_fn:collections.abc.Callable)\n\nSolve using transfer-function (TF) based recurrence.\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n\n\n\nomega_mu_squared\n\n\n\n\nu0\nArray\ninitial conditions (n_modes,)\n\n\nv0\nArray\ninitial conditions (n_modes,)\n\n\ndt\nfloat\n\n\n\nn_steps\nint\n\n\n\nnl_fn\nCallable\n\n\n\n\n\n\n\nsolve_tf_excitation\n\n solve_tf_excitation (gamma2_mu, omega_mu_squared,\n                      modal_excitation:jax.Array, dt:float,\n                      nl_fn:collections.abc.Callable)\n\nSolve using transfer-function (TF) based recurrence.\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\n\n\n\n\nomega_mu_squared\n\n\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\ndt\nfloat\n\n\n\nnl_fn\nCallable",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/time_integrators.html#sinusoidal-solve",
    "href": "api/time_integrators.html#sinusoidal-solve",
    "title": "Time integrators",
    "section": "Sinusoidal solve",
    "text": "Sinusoidal solve\nSolve the system of ODEs using complex exponentials\nThe system of ODEs is given by:\n\\[\n\\ddot{q} + 2 \\gamma \\dot{q} + \\omega^2 q = 0\n\\]\nwhere \\(\\gamma\\) is the damping coefficient and \\(\\omega\\) is the frequency. The damped frequencies are given by:\n\\[\n\\tilde{\\omega} = \\omega \\sqrt{1 - \\gamma^2} = \\sqrt{\\omega^2 - \\gamma^2}\n\\] The eigenvalues after the dispersion relation are then \\[\ns_\\pm = -\\gamma \\pm i \\tilde{\\omega}\n\\]\nand discrete time eigenvalues (poles) are \\[\nz_\\pm = e^{s_\\pm \\Delta t} = e^{-\\gamma \\Delta t} e^{\\pm i \\tilde{\\omega} \\Delta t}\n\\]\n\n\nsolve_sinusoidal\n\n solve_sinusoidal (gamma2_mu, omega_mu_squared, ic, n_steps, dt)\n\nSolve the system of ODEs using complex exponentials NB: this assumes the ic is only for positions and that the initial velocities are 0\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\njnp.ndarray\nDamping coefficients\n\n\nomega_mu_squared\njnp.ndarray\nSquared frequencies\n\n\nic\njnp.ndarray\nInitial conditions\n\n\nn_steps\nint\nNumber of steps\n\n\ndt\nfloat\nTime step\n\n\nReturns\njnp.ndarray\nModal solution\n\n\n\n\n\n\nsolve_sinusoidal_excitation\n\n solve_sinusoidal_excitation (gamma2_mu, omega_mu_squared,\n                              modal_excitation:jax.Array, dt:float)\n\nSolve the modal system with sinusoidal response for external excitation using parallel scan.\n\n\n\n\nType\nDetails\n\n\n\n\ngamma2_mu\njnp.ndarray\nDamping coefficients (n_modes,)\n\n\nomega_mu_squared\njnp.ndarray\nSquared frequencies (n_modes,)\n\n\nmodal_excitation\nArray\n(T, n_modes)\n\n\ndt\nfloat\nTime step\n\n\nReturns\njnp.ndarray\nModal solution (T, n_modes)\n\n\n\n\n\n\nsolve_tf_ic\n\n solve_tf_ic (gamma2_mu, omega_mu_squared, ic, n_steps, dt, nl_fn)",
    "crumbs": [
      "API",
      "Time integrators"
    ]
  },
  {
    "objectID": "api/coupling.html",
    "href": "api/coupling.html",
    "title": "Coupling functions",
    "section": "",
    "text": "assemble_K_and_M (Npsi, Lx, Ly)\n\n\n\n\n\n\n build_I4 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int4(m,p,L).\n\n\n\n\n\n build_I2 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int2(m,p,L).\n\n\n\n\n\n build_I1 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int1(m,p,L).\n\n\n\n\n\n int2_mat (N, L)\n\nBuilds the N x N matrix whose (m,p) entry is int2(m,p,L). Mirrors the logic of the original Matlab int2_mat function exactly, but we can do it more simply by calling int2 in a loop.\n\n\n\n\n\n int2 (m, p, L)\n\nFunction int2(m,p,L). Piecewise definition from the Matlab code.\n\n\n\n\n\n int1 (m, p, L)\n\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nFirst mode number\n\n\np\nint\nSecond mode number\n\n\nL\nfloat\nLength of the domain\n\n\nReturns\nfloat\nValue of the integral\n\n\n\n\n\n\n\n\n int4 (m:int, p:int, L:float)\n\nCompute the integral of Xd(m,x)Xd(p,x) from 0 to L, where X is the clamped-plate function and d denotes derivative in x.\nThe integral is computed for different cases based on the mode numbers m and p.*\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nFirst mode number\n\n\np\nint\nSecond mode number\n\n\nL\nfloat\nLength of the domain\n\n\nReturns\nfloat\nValue of the integral\n\n\n\n\n\n\n\n\n airy_stress_coefficients (n_psi, vals, vecs)\n\nCompute the Airy stress function coefficients from the eigenvalues and eigenvectors",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "href": "api/coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "title": "Coupling functions",
    "section": "",
    "text": "assemble_K_and_M (Npsi, Lx, Ly)\n\n\n\n\n\n\n build_I4 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int4(m,p,L).\n\n\n\n\n\n build_I2 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int2(m,p,L).\n\n\n\n\n\n build_I1 (N, L)\n\nReturns the N x N matrix whose (m,p) entry = int1(m,p,L).\n\n\n\n\n\n int2_mat (N, L)\n\nBuilds the N x N matrix whose (m,p) entry is int2(m,p,L). Mirrors the logic of the original Matlab int2_mat function exactly, but we can do it more simply by calling int2 in a loop.\n\n\n\n\n\n int2 (m, p, L)\n\nFunction int2(m,p,L). Piecewise definition from the Matlab code.\n\n\n\n\n\n int1 (m, p, L)\n\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nFirst mode number\n\n\np\nint\nSecond mode number\n\n\nL\nfloat\nLength of the domain\n\n\nReturns\nfloat\nValue of the integral\n\n\n\n\n\n\n\n\n int4 (m:int, p:int, L:float)\n\nCompute the integral of Xd(m,x)Xd(p,x) from 0 to L, where X is the clamped-plate function and d denotes derivative in x.\nThe integral is computed for different cases based on the mode numbers m and p.*\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nFirst mode number\n\n\np\nint\nSecond mode number\n\n\nL\nfloat\nLength of the domain\n\n\nReturns\nfloat\nValue of the integral\n\n\n\n\n\n\n\n\n airy_stress_coefficients (n_psi, vals, vecs)\n\nCompute the Airy stress function coefficients from the eigenvalues and eigenvectors",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "href": "api/coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "title": "Coupling functions",
    "section": "Basis used to build the mass and stiffness matrices",
    "text": "Basis used to build the mass and stiffness matrices\n\n\nbasis\n\n basis (m:int, n:int, x:float|numpy.ndarray, y:float|numpy.ndarray,\n        Lx:float, Ly:float)\n\n*Evaluate the full 2D basis function for indices (m, n) at point (x, y).\nThe basis function is defined as:\n.. math:: _{mn}(x,y) = X_m(x)Y_n(y)\nwhere X_m and Y_n are the 1D basis functions in x and y directions.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nm\nint\nMode number in x direction\n\n\nn\nint\nMode number in y direction\n\n\nx\nfloat | numpy.ndarray\nx coordinate(s) where to evaluate\n\n\ny\nfloat | numpy.ndarray\ny coordinate(s) where to evaluate\n\n\nLx\nfloat\nLength in x direction\n\n\nLy\nfloat\nLength in y direction\n\n\nReturns\nfloat | numpy.ndarray\nValue of the basis function at (x,y)",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "href": "api/coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "Partial integrals to calculate the coupling matrix",
    "text": "Partial integrals to calculate the coupling matrix\n\n\ni13_mat\n\n i13_mat (Npsi, Nphi, L)\n\n\n\n\ni12_mat\n\n i12_mat (Npsi, Nphi, L)\n\n\n\n\ni11_mat\n\n i11_mat (Npsi, Nphi, L)\n\n\n\n\ni10_mat\n\n i10_mat (Npsi, Nphi, L)\n\n\n\n\ni9_mat\n\n i9_mat (Npsi, Nphi, L)\n\n\n\n\ni5_mat\n\n i5_mat (Npsi, Nphi, L)\n\n\n\n\ni4_mat\n\n i4_mat (Npsi, Nphi, L)\n\nAuxiliary integral for the computation of the coupling coefficient H.\n\n\n\ni3_mat\n\n i3_mat (Npsi, Nphi, L)\n\nAuxiliary integral for the computation of the coupling coefficient H.\n\n\n\ni2_mat\n\n i2_mat (Npsi, Nphi, L)\n\n\n\n\ni1_mat\n\n i1_mat (Npsi, Nphi, L)",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "api/coupling.html#functions-to-put-together-the-coupling-matrix",
    "href": "api/coupling.html#functions-to-put-together-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "functions to put together the coupling matrix",
    "text": "functions to put together the coupling matrix\n\n\ng6\n\n g6 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng5\n\n g5 (Npsi, Nphi, S, kx, cache)\n\n\n\n\ng4\n\n g4 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng3\n\n g3 (Npsi, Nphi, S, ky, cache)\n\n\n\n\ng2\n\n g2 (Npsi, Nphi, S, kx, cache)\n\n\n\n\ng1\n\n g1 (Npsi, Nphi, S, kx, cache)\n\n\n\n\nbuild_s_matrix\n\n build_s_matrix (Npsi, Nphi, partials, idx_array, factor_mode)\n\nSummation of partial integrals in a 3D array with a factor.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nNpsi\n\n\n\n\nNphi\n\n\n\n\npartials\n\n\n\n\nidx_array\n\n\n\n\nfactor_mode\n\n\n\n\nReturns\nnp.ndarray of shape (Npsi, Nphi, Nphi)\nThe 3D tensor after summation and factor application.\n\n\n\n\n\n\ncompute_partial_integrals\n\n compute_partial_integrals (Npsi, Nphi, Lx, Ly)\n\nPrecompute and store all partial-integral matrices needed. Returns them in a dictionary or a custom object.\n\n\n\nH_tensor_rectangular\n\n H_tensor_rectangular (coeff0, coeff1, coeff2, Nphi, Npsi, Lx, Ly, kx, ky)\n\nCompute the H tensor for rectangular plates.\n\n\n\ncompute_coupling_matrix\n\n compute_coupling_matrix (n_psi, n_phi, lx, ly, kx_indices, ky_indices)",
    "crumbs": [
      "API",
      "Coupling functions"
    ]
  },
  {
    "objectID": "examples/non-linear.html",
    "href": "examples/non-linear.html",
    "title": "Simulating strings, membranes and plates with non-linearities",
    "section": "",
    "text": "The non-linear models are also similar to simulate. We add a non-linear to the equation:\n\\[\\begin{equation}\n\\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w} + (D \\Delta \\Delta - T_0 \\Delta) w = f_{\\text{ext}} - f_{\\text{nl}},\n\\end{equation}\\]\nwhere \\(f_{\\text{nl}}\\) is the non-linear term. Again we get damped harmonic oscillators:\n\\[\\begin{equation}\n\\ddot{q}_{\\mu} + 2\\gamma_{\\mu}\\dot{q}_{\\mu} + \\omega_{\\mu}^2 q_{\\mu} = \\bar{f}_{\\text{ext},\\mu} - \\bar{f}_{\\text{nl},\\mu},\n\\end{equation}\\]\nwhere \\(\\bar{f}_{\\text{nl},\\mu}\\) is the non-linear term in modal space. This term differs depending on the type of non-linearity and whether we are simulating a string, membrane or plate.",
    "crumbs": [
      "Examples",
      "Simulating strings, membranes and plates with non-linearities"
    ]
  },
  {
    "objectID": "examples/non-linear.html#tension-modulated-string",
    "href": "examples/non-linear.html#tension-modulated-string",
    "title": "Simulating strings, membranes and plates with non-linearities",
    "section": "Tension modulated string",
    "text": "Tension modulated string",
    "crumbs": [
      "Examples",
      "Simulating strings, membranes and plates with non-linearities"
    ]
  },
  {
    "objectID": "examples/non-linear.html#tension-modulated-plate",
    "href": "examples/non-linear.html#tension-modulated-plate",
    "title": "Simulating strings, membranes and plates with non-linearities",
    "section": "Tension modulated plate",
    "text": "Tension modulated plate",
    "crumbs": [
      "Examples",
      "Simulating strings, membranes and plates with non-linearities"
    ]
  },
  {
    "objectID": "examples/non-linear.html#von-karman-plate",
    "href": "examples/non-linear.html#von-karman-plate",
    "title": "Simulating strings, membranes and plates with non-linearities",
    "section": "Von Karman plate",
    "text": "Von Karman plate",
    "crumbs": [
      "Examples",
      "Simulating strings, membranes and plates with non-linearities"
    ]
  },
  {
    "objectID": "examples/simulations.html",
    "href": "examples/simulations.html",
    "title": "Simulating strings, membranes, and plates",
    "section": "",
    "text": "We can simulate strings, membranes, and plates in different ways. For the linear case, it is practical to use a fast linear solver, such as solve_sinusoidal, or a an iir filter (iir_filter_parallel). The latter being slower than the former.\nFor most cases the steps are similar:\n\nDefine the parameters of the simulation\nGet the eigenpairs\nDiscretize\nSimulate\n\n\nLinear models\nFor the linear models we want to solve the following equation:\n\\[\\begin{equation}\n\\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w} + (D \\Delta \\Delta - T_0 \\Delta) w = f_{\\text{ext}},\n\\end{equation}\\]\nwhich in modal coordinates \\(q_{\\mu}\\) results in uncoupled damped harmonic oscillators:\n\\[\\begin{equation}\n\\ddot{q}_{\\mu} + 2\\gamma_{\\mu}\\dot{q}_{\\mu} + \\omega_{\\mu}^2 q_{\\mu} = \\bar{f}_{\\text{ext},\\mu},\n\\end{equation}\\]\nwhere the coefficients are given by:\n\\[\\begin{align}\n\\omega_{\\mu}^2 &= \\frac{D\\lambda_{\\mu}^2 - T_0\\lambda_{\\mu}}{\\rho},\\\\\n\\gamma_{\\mu} &= \\frac{d_1 + d_3\\lambda_{\\mu}}{2\\rho}.\n\\end{align}\\]\n\nString\nSome parameters for the string\n\n\nCode\nn_modes = 50\nn_steps = 44100\nsample_rate = 44100\ndt = 1.0 / sample_rate\nexcitation_position = 0.2\nreadout_position = 0.5\ninitial_deflection = 0.03\nn_gridpoints = 101  # number of gridpoints for evaluating the eigenfunctions\nstring_params = StringParameters()\n\n\nGetting the eigenpairs\n\n\nCode\nlambda_mu = string_eigenvalues(n_modes, string_params.length)\nwn = np.sqrt(lambda_mu)\ngrid = np.linspace(0, string_params.length, n_gridpoints)\nK = string_eigenfunctions(wn, grid)\n\n\nGet the initial conditions or the excitation\n\nu0_modal = create_pluck_modal(\n    lambda_mu,\n    pluck_position=excitation_position,\n    initial_deflection=initial_deflection,\n    string_length=string_params.length,\n)\nu0 = inverse_STL(K, u0_modal, string_params.length)\nfig, ax = plt.subplots(1, 1, figsize=(6, 2))\nax.plot(grid, u0)\nax.set_xlabel(\"Position (m)\")\nax.set_ylabel(\"Deflection (m)\")\nax.set_title(\"Initial deflection of the string\")\nax.grid(True)\n\n\n\n\n\n\n\n\nGet \\(\\gamma_{\\mu}\\) and \\(\\omega_{\\mu}\\) and integrate in time from the initial conditions defined above. This should be very fast, even for a large number of modes.\n\ngamma2_mu = damping_term(\n    string_params,\n    lambda_mu,\n)\nomega_mu_squared = stiffness_term(\n    string_params,\n    lambda_mu,\n)\n\nmodal_sol = solve_sinusoidal(\n    gamma2_mu,\n    omega_mu_squared,\n    u0_modal,\n    n_steps,\n    dt,\n)\n\nTransform the modal solution back to the physical space using the precomputed eigenfunctions, or evaluate at a single point.\n\nmu = np.arange(1, n_modes + 1) # mode indices\n\nreadout_weights = evaluate_string_eigenfunctions(\n    mu,\n    readout_position,\n    string_params,\n)\n\n# at a single point\nu_readout = readout_weights @ modal_sol\n\n# at all points\nsol = inverse_STL(K, modal_sol, string_params.length)\n\nSingle point:\n\n\nCode\ndisplay(Audio(u_readout, rate=sample_rate))\nfig, ax = plt.subplots(1, 1, figsize=(6, 2))\nax.plot(u_readout)\nax.set_xlabel(\"Sample\")\nax.set_ylabel(\"Deflection (m)\")\nax.set_title(\"Deflection of the string at a single point\")\nax.set_xlim(-2, sample_rate // 10)\nax.grid(True)\n\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\n\n\n\n\n\n\nAll points:\n\n\nCode\nn_frames = 2000\nframe_stride = 15\npositions = np.linspace(0, string_params.length, sol.shape[0])\ntime_samples = sol[:, :n_frames]\n\nfig, ax = plt.subplots(figsize=(6, 3))\n(line,) = ax.plot(positions, time_samples[:, 0])\nax.set_ylim(np.min(time_samples) * 1.1, np.max(time_samples) * 1.1)\nax.set_xlabel(\"Position (m)\")\nax.set_ylabel(\"Deflection (m)\")\nax.set_title(\"String Vibration\")\nax.grid(True)\nfig.tight_layout()\n\n\ndef update(i):\n    frame = i * frame_stride\n    line.set_ydata(time_samples[:, frame])\n    return (line,)\n\n\nani = animation.FuncAnimation(\n    fig,\n    update,\n    frames=n_frames // frame_stride,\n    interval=25,\n    blit=True,\n)\n\n# Only display the animation, not the still figure\nplt.close(fig)\nHTML(ani.to_jshtml())\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\n\nPlate\nWe do a very similar thing for plates. First define the parameters\n\n\nCode\nn_modes_x = 8\nn_modes_y = 8\nn_modes = n_modes_x * n_modes_y\nn_steps = 44100\nsample_rate = 44100\ndt = 1.0 / sample_rate\nexcitation_duration = 1.0  # seconds\nexcitation_amplitude = 1.0\nforce_position = (0.05, 0.05)\nreadout_position = (0.1, 0.1)\nplate_params = PlateParameters(\n    Ts0=0,\n    d1=4e-3,\n    d3=3e-2,\n)\n\n\nGet the eigenpairs\n\n\nCode\nwnx, wny = plate_wavenumbers(\n    n_modes_x,\n    n_modes_y,\n    plate_params.l1,\n    plate_params.l2,\n)\nlambda_mu_2d = plate_eigenvalues(wnx, wny)\nn_gridpoints_x = 101\nn_gridpoints_y = 151\nx = np.linspace(0, plate_params.l1, n_gridpoints_x)\ny = np.linspace(0, plate_params.l2, n_gridpoints_y)\nK = plate_eigenfunctions(wnx, wny, x, y)\n\n# Sort the eigenvalues and get the indices\nindices = np.argsort(lambda_mu_2d.ravel())\nky_indices, kx_indices = np.unravel_index(indices, lambda_mu_2d.shape)\nky_indices, kx_indices = ky_indices + 1, kx_indices + 1\nselected_indices = np.stack([kx_indices, ky_indices], axis=-1)\nlambda_mu = np.sort(lambda_mu_2d.reshape(-1))\n\n\nThis time we will use an excitation force instead on initial conditions. We define the force as a 1D raised cosine at a single point on the plate.\n\n\nCode\nrc = create_1d_raised_cosine(\n    duration=excitation_duration,\n    start_time=0.010,\n    end_time=0.012,\n    amplitude=excitation_amplitude,\n    sample_rate=sample_rate,\n)\n\nweights_at_ex = evaluate_rectangular_eigenfunctions(\n    selected_indices,\n    force_position,\n    params=plate_params,\n) / plate_params.density\n\nweights_at_readout = (\n    evaluate_rectangular_eigenfunctions(\n        selected_indices,\n        readout_position,\n        params=plate_params,\n    )\n)\n\nmodal_excitation = np.outer(rc, weights_at_ex)\n\n\nGet \\(\\gamma_{\\mu}\\) and \\(\\omega_{\\mu}\\) and integrate in time using the excitation force.\n\n\nCode\ngamma2_mu = damping_term(\n    plate_params,\n    lambda_mu,\n)\nomega_mu_squared = stiffness_term(\n    plate_params,\n    lambda_mu,\n)\n\ndef nl_fn(modal_sol):\n    return 0.0\n\n_, modal_sol = solve_tf_excitation(\n    gamma2_mu,\n    omega_mu_squared,\n    modal_excitation,\n    dt,\n    nl_fn = nl_fn,\n)\n\n\nGet the solution in physical space\n\nzsol = modal_sol @ weights_at_readout\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 2))\nax.plot(sol)\nax.grid(True)\nax.set_xlim(200, 4410 * 2)\n\ndisplay(Audio(sol, rate=sample_rate))\n\n\n                \n                    \n                    Your browser does not support the audio element.",
    "crumbs": [
      "Examples",
      "Simulating strings, membranes, and plates"
    ]
  },
  {
    "objectID": "api/features.html",
    "href": "api/features.html",
    "title": "Features",
    "section": "",
    "text": "cqt_transform\n\n cqt_transform (x, cqt_instance, output_format=None)\n\nJIT-compiled CQT transform function.\n\n\n\nCQT1992v2\n\n CQT1992v2 (sr=22050, hop_length=512, fmin=32.7, fmax=None, n_bins=84,\n            bins_per_octave=12, filter_scale=1, norm=1, window='hann',\n            center=True, pad_mode='reflect', trainable=False,\n            output_format='Magnitude')\n\nJAX implementation of CQT1992v2 from nnAudio.\n\n\n\nconv1d_efficient\n\n conv1d_efficient (x, kernel, stride=1)\n\nEfficient JAX implementation of 1D convolution using lax.conv_general_dilated.\n\n\n\ncreate_cqt_kernels\n\n create_cqt_kernels (Q, fs, fmin, n_bins=84, bins_per_octave=12, norm=1,\n                     window='hann', fmax=None, topbin_check=True, gamma=0)\n\nCreate CQT kernels in time domain.\n\n\n\nget_window_dispatch\n\n get_window_dispatch (window, N, fftbins=True)\n\nGet the window function.\n\n\n\nbroadcast_dim\n\n broadcast_dim (x)\n\nAuto broadcast input so that it can fit into a Conv1d.\n\n\n\nnextpow2\n\n nextpow2 (A)\n\nCalculate the next nearest number to the power of 2.",
    "crumbs": [
      "API",
      "Features"
    ]
  },
  {
    "objectID": "api/excitations.html",
    "href": "api/excitations.html",
    "title": "Excitation functions",
    "section": "",
    "text": "import matplotlib.pyplot as plt\n\n\n\ncreate_1d_raised_cosine\n\n create_1d_raised_cosine (duration:float, start_time:float,\n                          end_time:float, amplitude:float,\n                          sample_rate:float)\n\nCreate a 1D raised cosine excitation with time parameters in seconds.\n\n\n\n\nType\nDetails\n\n\n\n\nduration\nfloat\nTotal duration of the excitation (in seconds).\n\n\nstart_time\nfloat\nStart time of the excitation (in seconds).\n\n\nend_time\nfloat\nEnd time of the excitation (in seconds).\n\n\namplitude\nfloat\nAmplitude of the excitation.\n\n\nsample_rate\nfloat\nSample rate (samples per second).\n\n\nReturns\nndarray\nThe excitation signal.\n\n\n\n\nrc = create_1d_raised_cosine(\n    1,\n    0.01,\n    0.05,\n    1,\n    44100,\n)\n\nplt.plot(rc)\n\n\n\n\n\n\n\n\n\n\n\ncreate_raised_cosine\n\n create_raised_cosine (Nx, Ny, h, ctr, epsilon, wid)\n\n*Create a raised cosine function on a 2D grid.\nParameters: Nx (int): Number of grid points in the x-direction. Ny (int): Number of grid points in the y-direction. h (float): Grid spacing. ctr (tuple): Center of the raised cosine (x, y). epsilon (float): Scaling parameter. wid (float): Width of the cosine.\nReturns: np.ndarray: Flattened raised cosine array.*\n\nfrom matplotlib import pyplot as plt\n\n\n# Example usage\nNx, Ny = 25, 21  # Grid dimensions\nh = 0.0438  # Grid spacing\nctr = (0.5, 0.5)  # Center of the raised cosine\nepsilon = 1.2000  # Scaling parameter\nwid = 0.3  # Width of the cosine\n\nrc, X, Y, dist, distx, disty = create_raised_cosine(\n    Nx,\n    Ny,\n    h,\n    ctr,\n    epsilon,\n    wid,\n)\n\nplt.imshow(rc, cmap=\"gray\", origin=\"lower\")\n\n\n\n\n\n\n\n\n\n\n\ncreate_pluck_modal\n\n create_pluck_modal (lambdas:numpy.ndarray, pluck_position:float=0.28,\n                     initial_deflection:float=0.03,\n                     string_length:float=1.0)\n\nCreate a pluck excitation for a string with a given length and pluck position. The pluck is modeled in the modal domain.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlambdas\nndarray\n\neigenvalues of the Laplacian operator\n\n\npluck_position\nfloat\n0.28\nposition of pluck on the string in meters\n\n\ninitial_deflection\nfloat\n0.03\ninitial deflection of the string in meters\n\n\nstring_length\nfloat\n1.0\ntotal length of the string in meters\n\n\nReturns\nndarray\n\nThe pluck excitation in the modal domain.",
    "crumbs": [
      "API",
      "Excitation functions"
    ]
  },
  {
    "objectID": "api/ftm.html",
    "href": "api/ftm.html",
    "title": "Funtional Transformation Method Utilities",
    "section": "",
    "text": "This notebook contains a set of utility functions for the functional transformation method.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#parameters",
    "href": "api/ftm.html#parameters",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nwavenumbers: np.ndarray The wavenumbers for the drumhead. r: np.ndarray Radial grid points. theta: np.ndarray Angular grid points.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#returns",
    "href": "api/ftm.html#returns",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\nmodes: np.ndarray The eigenfunctions for the drumhead.*\n\n\n\n\nType\nDetails\n\n\n\n\nwavenumbers\nndarray\n(n_max_modes, m_max_modes)\n\n\nr\nndarray\n(n_gridpoints_r)\n\n\ntheta\nndarray\n(n_gridpoints_theta)\n\n\nReturns\nndarray\n\n\n\n\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nCompute the eigenvalues of the drumhead.\nThe eigenvalues of the drumhead are given by the square of the wavenumbers....\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nCompute the eigenvalues of the drumhead.\nThe eigenvalues of the drumhead are given by the square of the wavenumbers....\n  else: warn(msg)\n\n\ndrumhead_eigenvalues\n\n drumhead_eigenvalues (wavenumbers:numpy.ndarray)\n\n*Compute the eigenvalues of the drumhead. The eigenvalues of the drumhead are given by the square of the wavenumbers.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#parameters-1",
    "href": "api/ftm.html#parameters-1",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nwavenumbers: np.ndarray The wavenumbers for the drumhead. squared: bool If True, return the squared eigenvalues.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#returns-1",
    "href": "api/ftm.html#returns-1",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\neigenvalues: np.ndarray The eigenvalues of the drumhead.*\n\n\n\n\nType\nDetails\n\n\n\n\nwavenumbers\nndarray\n(n_max_modes, m_max_modes)\n\n\n\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nParameters: \n---------- in \nCompute the wavenumbers of the drumhead.\n...\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \nReturns: \n------- in \nCompute the wavenumbers of the drumhead.\n...\n  else: warn(msg)\n\n\ndrumhead_wavenumbers\n\n drumhead_wavenumbers (n_max_modes:int, m_max_modes:int, radius:float)\n\n*Compute the wavenumbers of the drumhead.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#parameters-2",
    "href": "api/ftm.html#parameters-2",
    "title": "Funtional Transformation Method Utilities",
    "section": "Parameters:",
    "text": "Parameters:\nn_max_modes: int The number of angular modes. m_max_modes: int The number of radial modes. radius: float The radius of the drumhead.",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/ftm.html#returns-2",
    "href": "api/ftm.html#returns-2",
    "title": "Funtional Transformation Method Utilities",
    "section": "Returns:",
    "text": "Returns:\nwavenumbers: np.ndarray The wavenumbers for the drumhead.*\n\n\ndblintegral\n\n dblintegral (integrand, x, y, method='simpson')\n\nCompute the double integral of a function K over the domain x and y.\n\n# Example usage\nn_max_modes = 25\nm_max_modes = 25\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert K_inv.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\nassert K_fwd.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\n\\[\nK_{n,m}(r, \\varphi) = \\cos (n \\varphi) J_n\\left(\\mu_{n, m} \\frac{r}{R}\\right)\n\\]\nwhere \\(J_n\\) is the Bessel function of the first kind of order \\(n\\), and \\(\\mu_{n, m}\\) is the \\(m\\)-th root of the \\(n\\)-th order Bessel function of the first kind.\n\nwnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, length_x, length_y)\nassert np.allclose(plate_eigenfunctions(wnx, wny, grid_x, grid_y), K)\nassert np.allclose(plate_eigenvalues(wnx, wny), Lambda)\n\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\n\n\ninverse_STL\n\n inverse_STL (K:numpy.ndarray, u_bar:numpy.ndarray, length:float)\n\nCompute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes, n_gridpoints)\n\n\nu_bar\nndarray\n(n_modes, n_samples) or (n_modes,)\n\n\nlength\nfloat\nlength of the string\n\n\nReturns\nndarray\n\n\n\n\n\n\n\nforward_STL\n\n forward_STL (K:numpy.ndarray, u:numpy.ndarray, dx:float)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes, n_gridpoints)\n\n\nu\nndarray\n(n_gridpoints, n_samples) or (n_gridpoints,)\n\n\ndx\nfloat\ngrid spacing\n\n\nReturns\nndarray\nThe transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n\n\n\n\n\n\ninverse_STL_2d\n\n inverse_STL_2d (K:numpy.ndarray, u_bar:numpy.ndarray, l1:float, l2:float)\n\nCompute the inverse STL transform.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK\nndarray\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu_bar\nndarray\n(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n\n\nl1\nfloat\nlength in x\n\n\nl2\nfloat\nlength in y\n\n\nReturns\nndarray\nThe reconstructed signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n\n\n\n\n\n\nforward_STL_2d\n\n forward_STL_2d (K:numpy.ndarray, u:numpy.ndarray, x:float, y:float,\n                 use_simpson:bool=False)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nK\nndarray\n\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu\nndarray\n\n(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n\n\nx\nfloat\n\ngrid spacing\n\n\ny\nfloat\n\ngrid spacing\n\n\nuse_simpson\nbool\nFalse\n\n\n\nReturns\nndarray\n\nThe transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n\n\n\n\n\n\nevaluate_rectangular_eigenfunctions\n\n evaluate_rectangular_eigenfunctions (mn_indices:numpy.ndarray,\n                                      position:numpy.ndarray,\n                                      params:__main__.PlateParameters)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmn_indices\nndarray\n(n_modes, 2) selected mode indices\n\n\nposition\nndarray\n(2,) position to evaluate the eigenfunctions\n\n\nparams\nPlateParameters\n\n\n\nReturns\nndarray\n(n_modes,) mode gains of selected modes at the given position\n\n\n\n\n\n\nevaluate_string_eigenfunctions\n\n evaluate_string_eigenfunctions (indices:numpy.ndarray,\n                                 position:numpy.ndarray,\n                                 params:__main__.StringParameters)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nindices\nndarray\n(n_modes,) selected mode indices\n\n\nposition\nndarray\n(1,) position to evaluate the eigenfunctions\n\n\nparams\nStringParameters\n\n\n\nReturns\nndarray\n(n_modes,) mode gains of selected modes at the given position\n\n\n\n\nlength_x = 1.08\nlength_y = 0.8\nn_max_modes_x = 25\nn_max_modes_y = 25\nn_gridpoints_x = 100\nn_gridpoints_y = 100\n\nx = np.linspace(0, length_x, n_gridpoints_x)\ny = np.linspace(0, length_y, n_gridpoints_y)\n\nwnx, wny = plate_wavenumbers(\n    n_max_modes_x,\n    n_max_modes_y,\n    length_x,\n    length_y,\n)\nK = plate_eigenfunctions(wnx, wny, x, y)\n\ng = 0.5 * K[2, 2] + 0.5 * K[3, 3]\n\nbar_g = forward_STL_2d(K, g, x, y, use_simpson=True)\ng_reconstructed = inverse_STL_2d(K, bar_g, length_x, length_y)\n\nassert np.allclose(g, g_reconstructed, atol=1e-2)\n\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\n\nax[0].imshow(g, origin=\"lower\", aspect=\"auto\")\nax[0].set_title(\"Original excitation\")\nax[1].imshow(g_reconstructed, origin=\"lower\", aspect=\"auto\")\nax[1].set_title(\"Reconstructed excitation\")\n\nText(0.5, 1.0, 'Reconstructed excitation')\n\n\n\n\n\n\n\n\n\n\n\n\ninverse_STL_drumhead\n\n inverse_STL_drumhead (K_inv:numpy.ndarray, u_bar:numpy.ndarray)\n\nCompute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nK_inv\nndarray\n(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n\n\nu_bar\nndarray\n(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n\n\nReturns\nndarray\n\n\n\n\n\n\n\nforward_STL_drumhead\n\n forward_STL_drumhead (K:numpy.ndarray, u:numpy.ndarray, r:numpy.ndarray,\n                       theta:numpy.ndarray, use_simpson:bool=False)\n\nCompute the forward STL transform. The integration is done using the trapezoidal rule or Simpson’s rule.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nK\nndarray\n\n(n_modes_r, n_modes_theta, n_gridpoints_r, n_gridpoints_theta)\n\n\nu\nndarray\n\n(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n\n\nr\nndarray\n\nradial grid\n\n\ntheta\nndarray\n\nangular grid\n\n\nuse_simpson\nbool\nFalse\n\n\n\nReturns\nndarray\n\n\n\n\n\n\n# Example usage\nn_max_modes = 10\nm_max_modes = 10\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert np.allclose(\n    K_fwd.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\nassert np.allclose(\n    K_inv.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\n\n# Create an example g array to test the transforms\ng = K_fwd[3, 3]\n\nbar_g = forward_STL_drumhead(K_fwd, g, r, theta, use_simpson=False)\ng_reconstructed = inverse_STL_drumhead(K_inv, bar_g)\n\n# Verify if g can be reconstructed\nassert np.allclose(g, g_reconstructed, atol=1e-2)\nprint(g.min(), g.max())\nprint(g_reconstructed.min(), g_reconstructed.max())\n\n# Plot using pcolormesh\nfig, ax = plt.subplots(\n    1,\n    2,\n    subplot_kw={\"projection\": \"polar\"},\n    figsize=(10, 5),\n)\nc = ax[0].pcolormesh(theta, r, g, shading=\"auto\", cmap=\"viridis\")\nc = ax[1].pcolormesh(theta, r, g_reconstructed, shading=\"auto\", cmap=\"viridis\")\n\n-0.4320502477222054 0.43401550352665574\n-0.4320519880367027 0.4340172517572766\n\n\n\n\n\n\n\n\n\n\n\n\nstiffness_term\n\n stiffness_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)\n\n\n\n\ndamping_term_simple\n\n damping_term_simple (omega_mu:jax.Array, factor:float=0.001)\n\n\n\n\ndamping_term\n\n damping_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)\n\n\n\n\neigenvalues_from_pde\n\n eigenvalues_from_pde (pars:__main__.PhysicalParameters,\n                       lambda_mu:jax.Array)\n\nCompute the positive imaginary side of the eigenvalues of the continuous-time system from the PDE parameters.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npars\nPhysicalParameters\nThe physical parameters of the system.\n\n\nlambda_mu\nArray\nThe eigenvalues of the decompostion of the Laplacian operator.\n\n\nReturns\nArray\nThe eigenvalues of the continuous-time system.\n\n\n\nSome example use. Note that this is just a preview of how all the modes sound when excited at once. In a real setting they must be weighted with the eigenfunctions and the initial conditions or modal excitation.\n\nn_max_modes = 30\nsr = 44100\ndt = 1 / sr\nfinal_time = 1.0\nn_samples = int(final_time / dt)\np_params = StringParameters()\nlambda_mu = string_eigenvalues(n_max_modes, p_params.length)\neigvals = eigenvalues_from_pde(p_params, lambda_mu)\n\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\ndisplay(Audio(states.sum(0), rate=sr))\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\nsr = 44100\ndt = 1 / sr\nn_modes_x = 8\nn_modes_y = 8\nn_modes = n_modes_x * n_modes_y\nfinal_time = 6.0\nn_samples = int(final_time / dt)\n\np_params = PlateParameters()\nwnx, wny = plate_wavenumbers(\n    n_max_modes_x,\n    n_max_modes_y,\n    p_params.l1,\n    p_params.l2,\n)\nlambda_mu = plate_eigenvalues(wnx, wny)\nlambda_mu = np.sort(lambda_mu.reshape(-1))[:n_modes]\neigvals = eigenvalues_from_pde(p_params, lambda_mu)\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\ndisplay(Audio(states.sum(0), rate=sr))\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\nsr = 44100\ndt = 1 / sr\nn_modes_x = 8\nn_modes_y = 8\nn_modes = n_modes_x * n_modes_y\nfinal_time = 2.0\nn_samples = int(final_time / dt)\np_params = CircularDrumHeadParameters.avanzini()\n\nwn = drumhead_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.r0)\nlambda_mu = np.sort(drumhead_eigenvalues(wn).reshape(-1))[:n_modes]\neigvals = eigenvalues_from_pde(p_params, lambda_mu)\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\ndisplay(Audio(states[0], rate=sr))\n\n\n                \n                    \n                    Your browser does not support the audio element.\n                \n              \n\n\n\n\n\nsample_parallel_tf\n\n sample_parallel_tf (num:numpy.ndarray, den:numpy.ndarray, dt:float,\n                     method:str='impulse')\n\nSample multiple transfer functions.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnum\nndarray\n\n(n_modes,)\n\n\nden\nndarray\n\n(n_modes,)\n\n\ndt\nfloat\n\n\n\n\nmethod\nstr\nimpulse\n\n\n\nReturns\nnp.ndarray\n\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_continuous_2\n\n tf_initial_conditions_continuous_2 (D:float, density:float, d1:float,\n                                     d3:float, Ts0:float,\n                                     lambda_mu:&lt;function array&gt;)\n\nConpute the continuous-time initial condition transfer function. This is an alternative to the function tf_initial_conditions_continuous that eigenvalues of the PDE as input.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nD\nfloat\nThe bending stiffness of the string or plate.\n\n\ndensity\nfloat\nThe area or surface density of the string or plate.\n\n\nd1\nfloat\nThe linear damping coefficient, or frequency-independent damping.\n\n\nd3\nfloat\nThe cubic damping coefficient, or frequency-dependent damping.\n\n\nTs0\nfloat\nThe initial tension of the string or plate.\n\n\nlambda_mu\narray\nThe eigenvalues from the decomposition of the Laplacian operator.\n\n\nReturns\ntuple\nThe numerator and denominator of the transfer function.\n\n\n\n\n\n\ntf_excitation_discrete\n\n tf_excitation_discrete (eigenvalues:numpy.ndarray, density:float,\n                         dt:float)\n\nCompute the discrete-time excitation transfer function of a system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndensity\nfloat\nsurface or area density\n\n\ndt\nfloat\ntime step\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_excitation_continuous\n\n tf_excitation_continuous (eigenvalues:numpy.ndarray, density:float)\n\nCompute the continuous excitation transfer function.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndensity\nfloat\nsurface or area density\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_discrete\n\n tf_initial_conditions_discrete (eigenvalues:numpy.ndarray, dt:float)\n\nCompute the discrete-time initial conditions transfer function of a system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\ndt\nfloat\ntime step\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\n\n\ntf_initial_conditions_continuous\n\n tf_initial_conditions_continuous (eigenvalues:numpy.ndarray)\n\nCompute the continuos “initial-conditions” transfer function from the eigenvalues of the system.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\neigenvalues\nndarray\nThe eigenvalues of the system.\n\n\nReturns\ntuple\nThe numerator of the discrete-time transfer function.\n\n\n\n\nb, a = tf_excitation_discrete(eigvals, p_params.density, dt)\nb_ic, a_ic = tf_initial_conditions_discrete(eigvals, dt)\n\n# manual discretization\neigenvalues_d = np.exp(eigvals * dt)\n\n# for the excitation tf\nb1 = (\n    np.exp(eigvals.real * dt)\n    * np.sin(eigvals.imag * dt)\n    / eigvals.imag\n    / p_params.density\n)\n\n# for the initial conditions tf\n# here we ignore initial velocity\nr = np.exp(eigvals.real * dt)\nb1_ic = r * np.sin(eigvals.imag * dt) / eigvals.imag * -eigvals.real - r * np.cos(\n    eigvals.imag * dt\n)\n\na1 = -2 * np.exp(eigvals.real * dt) * np.cos(eigvals.imag * dt)\na2 = np.exp(2 * eigvals.real * dt)\nb_manual = np.stack([np.zeros_like(b1), b1, np.zeros_like(b1)], axis=-1) * dt\na_manual = np.stack([np.ones_like(a1), a1, a2], axis=-1)\n\nb_ic_manual = np.stack([np.ones_like(b1_ic), b1_ic], axis=-1) * dt\n\nprint(b[0])\nprint(b_manual[0])\nprint(b_ic[0] * sr)\nprint(b_ic_manual[0] * sr)\nassert np.allclose(b[:, 1], b_manual[:, 1])\nassert np.allclose(a, a_manual)\nassert np.allclose(b_ic[:, :2], b_ic_manual[:, :2])\n\n[0.00000000e+00 1.90416682e-09 1.11022302e-16]\n[0.00000000e+00 1.90416703e-09 0.00000000e+00]\n[ 1.00000000e+00 -9.99682425e-01  2.93765012e-11]\n[ 1.         -0.99968243]",
    "crumbs": [
      "API",
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "api/utils.html",
    "href": "api/utils.html",
    "title": "Utils",
    "section": "",
    "text": "next_root\n\n next_root (x)\n\n\n\n\nsafe_log\n\n safe_log (x, eps=1e-10)\n\n\n\n\nto_db\n\n to_db (x)\n\n\n\n\nimpulse_response\n\n impulse_response (b:jax.Array, a:jax.Array, n=4410)\n\nCompute the impulse response of a discrete time system\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nb\nArray\n\nnumerators of the discrete transfer function\n\n\na\nArray\n\ndenominators of the discrete transfer function\n\n\nn\nint\n4410\n\n\n\nReturns\njnp.ndarray\n\nThe impulse response of the system, with shape (n_modes, n)\n\n\n\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:\n  else: warn(msg)\n/home/diaz/projects/jaxdiffmodal/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\n\n\niir_filter_parallel\n\n iir_filter_parallel (b, a, x)\n\nEfficient parallel IIR filter implementation using JAX.\n\n\n\n\nDetails\n\n\n\n\nb\nshape (n_modes, 3)\n\n\na\nshape (n_modes, 3)\n\n\nx\nshape (n_samples,)\n\n\n\n\n\n\nplot_poles_zeros\n\n plot_poles_zeros (p:numpy.ndarray, ax=None, xlim=(-1.1, 1.1), ylim=(-1.1,\n                   1.1), show_unit_circle=True, save_path=None, **kwargs)\n\n*Plot poles and zeros on a 2D complex plane with customizable axis limits.\nArgs: p (np.ndarray): Array of complex poles/zeros, will be flattened. ax (matplotlib.axes._subplots.AxesSubplot, optional): Pre-existing axis to plot on. xlim (tuple, optional): Limits for the x-axis (real part). ylim (tuple, optional): Limits for the y-axis (imaginary part). show_unit_circle (bool, optional): Whether to show the unit circle. save_path (str, optional): File path to save the plot. **kwargs: Additional keyword arguments passed to scatter plot.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\np\nndarray\n\nArray of zeros or poles (any shape)\n\n\nax\nNoneType\nNone\n\n\n\nxlim\ntuple\n(-1.1, 1.1)\nDefault x-axis limits\n\n\nylim\ntuple\n(-1.1, 1.1)\nDefault y-axis limits\n\n\nshow_unit_circle\nbool\nTrue\nOption to show the unit circle\n\n\nsave_path\nNoneType\nNone\nOptional file path to save the plot\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\n\n\nhz2bark\n\n hz2bark (f)\n\n\n\n\nbark2hz\n\n bark2hz (b)\n\n\n\n\nhz2mel\n\n hz2mel (h)\n\n\n\n\nmel2hz\n\n mel2hz (m)\n\n\n\n\ntf_freqs\n\n tf_freqs (b:jax.Array, a:jax.Array, s:jax.Array)\n\nSample the frequency response of a transfer functions.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nb\nArray\nnumerator (n_modes, 3)\n\n\na\nArray\ndenominator (n_modes, 3)\n\n\ns\nArray\nfrequency (n_freqs,)\n\n\nReturns\nArray\nThe frequency response of the transfer function.\n\n\n\n\n\n\ntf_freqz\n\n tf_freqz (b:jax.Array, a:jax.Array, worN:jax.Array, sample_rate:int)\n\nSample the frequency response of the transfer functions.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nb\nArray\nnumerator (n_modes, 3)\n\n\na\nArray\ndenominator (n_modes, 3)\n\n\nworN\nArray\nfrequencies (n_freqs,)\n\n\nsample_rate\nint\nThe sample rate in Hz of the transfer function\n\n\nReturns\njnp.ndarray\nThe frequency response of the transfer function\n\n\n\n\n\n\ncompute_spectrogram\n\n compute_spectrogram (signal:numpy.ndarray, sample_rate:int, n_fft:int,\n                      hop_length:int, max_freq:float=None,\n                      time_limit_s:float=0.5)",
    "crumbs": [
      "API",
      "Utils"
    ]
  },
  {
    "objectID": "api/num_utils.html#modal-pruning",
    "href": "api/num_utils.html#modal-pruning",
    "title": "Numerical utilities",
    "section": "Modal pruning",
    "text": "Modal pruning\n\n\npolarisation\n\n polarisation (interpolated_eigenvectors, eigenvectors, h)\n\n\n\n\neigenMAC\n\n eigenMAC (ref_eigenvectors, ref_nx, ref_ny, eigenvectors, eigenvalues,\n           nx, ny, n_modes, Lx, Ly, h)\n\n*Computes the Modal Assurance Criterion (MAC) between reference eigenvectors and given eigenvectors.\nThe Modal Assurance Criterion (MAC) between two eigenvectors (mode shapes) \\(\\Phi_i\\) and \\(\\Phi_j\\) is:\n\\[\n\\mathrm{MAC}(\\Phi_i,\\Phi_j) =\n\\frac{|\\Phi_i^{T}\\,\\Phi_j|^{2}}\n    {\\left(\\Phi_i^{T}\\,\\Phi_i\\right)\\,\\left(\\Phi_j^{T}\\,\\Phi_j\\right)}.\n\\]\nMAC measures the degree of similarity (or consistency) between the two mode shapes. A value of 1 indicates identical shapes (up to a scalar), while a value near 0 indicates they are nearly orthogonal.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nref_eigenvectors\nndarray\nReference eigenvectors (reshaped for interpolation).\n\n\nref_nx\nint\nNumber of reference grid points along the x-axis.\n\n\nref_ny\nint\nNumber of reference grid points along the y-axis.\n\n\neigenvectors\nndarray\nEigenvectors to compare against the reference.\n\n\neigenvalues\nndarray\nCorresponding eigenvalues of the eigenvectors.\n\n\nnx\nint\nNumber of grid points along the x-axis for interpolation.\n\n\nny\nint\nNumber of grid points along the y-axis for interpolation.\n\n\nn_modes\nint\nNumber of modes to compare.\n\n\nLx\nfloat\nLength of the domain along the x-axis.\n\n\nLy\nfloat\nLength of the domain along the y-axis.\n\n\nh\n\n\n\n\nReturns\nndarray\nReordered eigenvectors after MAC computation.",
    "crumbs": [
      "API",
      "Numerical utilities"
    ]
  },
  {
    "objectID": "api/num_utils.html#biharmonic-decomposition",
    "href": "api/num_utils.html#biharmonic-decomposition",
    "title": "Numerical utilities",
    "section": "Biharmonic decomposition",
    "text": "Biharmonic decomposition\nComputes the eigenvalue decomposition of the biharmonic operator for the plate:\n\\[\n\\Delta \\Delta \\Phi_p(x, y)=\\frac{\\rho h}{D} \\lambda_p^2 \\Phi_p(x, y) .\n\\]\n\\(\\rho\\), \\(h\\) and \\(D\\) are density, tickness and bending stiffness of the plate, respectively.\n\n\nbiharmonic_eigendecomposition\n\n biharmonic_eigendecomposition (params:jaxdiffmodal.ftm.PlateParameters,\n                                n_modes:int, bcs:numpy.ndarray, nx:int,\n                                ny:int, h:float,\n                                normalise_eigenvectors=True)\n\n*Computes the eigenvalue decomposition of the biharmonic operator for a plate with the given parameters and boundary conditions.\nAdditionally it sorts the eigenvalues and eigenvectors in ascending order, and normalises the eigenvectors if requested.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\nPlateParameters\n\nThe parameters of the plate.\n\n\nn_modes\nint\n\nThe number of modes to compute.\n\n\nbcs\nndarray\n\nThe boundary conditions of the plate.\n\n\nnx\nint\n\nThe number of points in the x direction.\n\n\nny\nint\n\nThe number of points in the y direction.\n\n\nh\nfloat\n\nThe spacing between points.\n\n\nnormalise_eigenvectors\nbool\nTrue\nWhether to normalise the eigenvectors.\n\n\nReturns\nTuple[np.ndarray, np.ndarray, np.ndarray]\n\nThe eigenvalues, eigenvectors and norms of the eigenvectors.\n\n\n\n\n\n\nmultiresolution_eigendecomposition\n\n multiresolution_eigendecomposition\n                                     (params:jaxdiffmodal.ftm.PlateParamet\n                                     ers, n_modes:int, bcs:numpy.ndarray,\n                                     h:float, nx:int, ny:int,\n                                     levels:int=2)\n\nRuns the biharmonic eigendecomposition and eigenvector alignment on multiple grid resolutions.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\nPlateParameters\n\n\n\n\nn_modes\nint\n\nNumber of eigenmodes to compute.\n\n\nbcs\nndarray\n\nBoundary conditions.\n\n\nh\nfloat\n\nInitial grid spacing.\n\n\nnx\nint\n\nNumber of grid points in the x-direction.\n\n\nny\nint\n\nNumber of grid points in the y-direction.\n\n\nlevels\nint\n2\nTotal number of resolutions to run (default 2).The first level is the coarse grid, and each subsequent leveluses h/2 and double the grid points to cover the same domain.\n\n\nReturns\nswapped_eigenvectors, swapped_eigenvalues from the last refinement.",
    "crumbs": [
      "API",
      "Numerical utilities"
    ]
  }
]