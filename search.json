[
  {
    "objectID": "num_utils.html",
    "href": "num_utils.html",
    "title": "Numerical utilities",
    "section": "",
    "text": "::: {#cell-3 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’ 6=‘i’}\n:::\n::: {#cell-4 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n:::\nThe bilinear von Kármán operator is defined as\n\\[\nL(f, g)=f_{, x x} g_{, y y}+f_{, y y} g_{, x x}-2 f_{, x y} g_{, x y}\n\\]\n::: {#cell-6 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n:::\n::: {#cell-7 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n:::\nThe modal coupling matrix is computed as\n\\[\nH_{p, q}^k=\\frac{\\int_S \\Psi_k L\\left(\\Phi_p, \\Phi_q\\right) \\mathrm{d} S}{\\left\\|\\Psi_k\\right\\|\\left\\|\\Phi_p\\right\\|\\left\\|\\Phi_q\\right\\|}\n\\]\nHere however we compute\n\\[\nH_{p, q}^k= \\int_S \\Psi_k L\\left(\\Phi_p, \\Phi_q\\right) \\mathrm{d} S\n\\]\nsince the \\(\\Psi\\) and \\(\\Phi\\) functions are normalised elsewhere.\n::: {#cell-9 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n:::",
    "crumbs": [
      "Numerical utilities"
    ]
  },
  {
    "objectID": "num_utils.html#modal-pruning",
    "href": "num_utils.html#modal-pruning",
    "title": "Numerical utilities",
    "section": "Modal pruning",
    "text": "Modal pruning\n::: {#cell-11 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef polarisation(\n    interpolated_eigenvectors,\n    eigenvectors,\n    h,\n):\n    negative = interpolated_eigenvectors - eigenvectors\n    positive = interpolated_eigenvectors + eigenvectors\n\n    sgn = np.sign(\n        -np.abs(double_trapezoid(negative * negative, dx=h))\n        + np.abs(double_trapezoid(positive * positive, dx=h))\n    )\n    return sgn * eigenvectors\n:::\nThe Modal Assurance Criterion (MAC) between two eigenvectors (mode shapes) \\(\\Phi_i\\) and \\(\\Phi_j\\) is:\n\\[\n\\mathrm{MAC}(\\Phi_i,\\Phi_j) =\n\\frac{|\\Phi_i^{T}\\,\\Phi_j|^{2}}\n    {\\left(\\Phi_i^{T}\\,\\Phi_i\\right)\\,\\left(\\Phi_j^{T}\\,\\Phi_j\\right)}.\n\\]\nMAC measures the degree of similarity (or consistency) between the two mode shapes. A value of 1 indicates identical shapes (up to a scalar), while a value near 0 indicates they are nearly orthogonal.\n::: {#cell-13 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef eigenMAC(\n    ref_eigenvectors,\n    ref_nx,\n    ref_ny,\n    eigenvectors,\n    eigenvalues,\n    nx,\n    ny,\n    n_modes,\n    Lx,\n    Ly,\n    h,\n):\n    \"\"\"\n\n    Computes the Modal Assurance Criterion (MAC) between reference eigenvectors and given eigenvectors.\n\n\n    Parameters\n    ----------\n    ref_eigenvectors : ndarray\n        Reference eigenvectors (reshaped for interpolation).\n    ref_nx : int\n        Number of reference grid points along the x-axis.\n    ref_ny : int\n        Number of reference grid points along the y-axis.\n    eigenvectors : ndarray\n        Eigenvectors to compare against the reference.\n    eigenvalues : ndarray\n        Corresponding eigenvalues of the eigenvectors.\n    nx : int\n        Number of grid points along the x-axis for interpolation.\n    ny : int\n        Number of grid points along the y-axis for interpolation.\n    n_modes : int\n        Number of modes to compare.\n    Lx : float\n        Length of the domain along the x-axis.\n    Ly : float\n        Length of the domain along the y-axis.\n\n    Returns\n    -------\n    eigenvectors_swapped : ndarray\n        Reordered eigenvectors after MAC computation.\n    eigenvalues_swapped : ndarray\n        Reordered eigenvalues after MAC computation.\n    \"\"\"\n    # Define reference and target grids\n    xref = np.linspace(0, Lx, ref_nx + 1)\n    yref = np.linspace(0, Ly, ref_ny + 1)\n\n    x = np.linspace(0, Lx, nx + 1)\n    y = np.linspace(0, Ly, ny + 1)\n\n    # Interpolate eigenvectors\n    interpolated_eigenvectors = np.zeros(((nx + 1) * (ny + 1), n_modes))\n    for mode in range(n_modes):\n        Z = ref_eigenvectors[:, mode].reshape(ref_nx + 1, ref_ny + 1)\n\n        interpolator = RectBivariateSpline(\n            xref,\n            yref,\n            Z,\n            kx=1,\n            ky=1,\n        )\n\n        interpolated_eigenvectors[:, mode] = interpolator(x, y).ravel()\n\n    # Compute MAC matrix\n    norm_eigenvectors = np.sum(eigenvectors**2, axis=0, keepdims=True)\n    norm_interpolated = np.sum(interpolated_eigenvectors**2, axis=0, keepdims=True)\n\n    num = np.abs(interpolated_eigenvectors.T @ eigenvectors) ** 2\n    den = norm_interpolated.T @ norm_eigenvectors  # Shape (n_modes, n_modes)\n\n    MAC_matrix = num / den\n    MAC_matrix[MAC_matrix &lt; 0.1] = 0\n    np.fill_diagonal(MAC_matrix, 0)\n\n    # Find matching indices\n    rows, cols = np.where(MAC_matrix &gt; 0)\n    lmc = len(cols)\n\n    if lmc &gt; 0:\n        swap_indices = np.arange(n_modes)\n        check = rows[0]\n        for i in range(lmc - 1):\n            if check != cols[i]:\n                swap_indices[cols[i]], swap_indices[rows[i]] = (\n                    swap_indices[rows[i]],\n                    swap_indices[cols[i]],\n                )\n                check = rows[i]\n\n        eigenvectors = polarisation(interpolated_eigenvectors, eigenvectors, h)\n\n        # Reorder eigenvectors and eigenvalues\n        eigenvectors_swapped = eigenvectors[:, swap_indices]\n        eigenvalues_swapped = eigenvalues[swap_indices]\n\n    else:\n        eigenvectors_swapped = eigenvectors\n        eigenvalues_swapped = eigenvalues\n    return eigenvectors_swapped, eigenvalues_swapped\n:::",
    "crumbs": [
      "Numerical utilities"
    ]
  },
  {
    "objectID": "num_utils.html#biharmonic-decomposition",
    "href": "num_utils.html#biharmonic-decomposition",
    "title": "Numerical utilities",
    "section": "Biharmonic decomposition",
    "text": "Biharmonic decomposition\nComputes the eigenvalue decomposition of the biharmonic operator for the plate:\n\\[\n\\Delta \\Delta \\Phi_p(x, y)=\\frac{\\rho h}{D} \\lambda_p^2 \\Phi_p(x, y) .\n\\]\n\\(\\rho\\), \\(h\\) and \\(D\\) are density, tickness and bending stiffness of the plate, respectively.\n::: {#cell-16 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef biharmonic_eigendecomposition(\n    params: PlateParameters,\n    n_modes: int,\n    bcs: np.ndarray,\n    nx: int,\n    ny: int,\n    h: float,\n    normalise_eigenvectors=True,\n):\n    \"\"\"\n    Computes the eigenvalue decomposition of the biharmonic operator for a\n    plate with the given parameters and boundary conditions.\n\n    Additionally it sorts the eigenvalues and eigenvectors in ascending order,\n    and normalises the eigenvectors if requested.\n\n    Parameters\n    ----------\n    params : PlateParameters\n        The parameters of the plate.\n    n_modes : int\n        The number of modes to compute.\n    bcs : np.ndarray\n        The boundary conditions of the plate.\n    nx : int\n        The number of points in the x direction.\n    ny : int\n        The number of points in the y direction.\n    h : float\n        The spacing between points.\n    normalise_eigenvectors : bool\n        Whether to normalise the eigenvectors.\n\n    Returns\n    -------\n    Tuple[np.ndarray, np.ndarray, np.ndarray]\n        The eigenvalues, eigenvectors and norms of the eigenvectors.\n    \"\"\"\n    biharm = bhmat(bcs, [nx + 1, ny + 1], h, params.h, params.E, params.nu)\n\n    [eigenvalues, eigenvectors] = eigs(biharm, k=n_modes, sigma=0, which=\"LR\")\n\n    indSort = np.argsort(eigenvalues)\n\n    eigenvalues = eigenvalues[indSort]\n    eigenvectors = eigenvectors[:, indSort]\n\n    # sometimes these might be complex due to numerical errors in bhmat?\n    # TODO: check if the biharmonic matrix is symmetric always\n    # if so we take the real part\n    eigenvectors = np.real(eigenvectors)\n    eigenvalues = np.real(eigenvalues)\n\n    norms = np.zeros(n_modes)\n    for i in range(n_modes):\n        norm = double_trapezoid_flat(\n            eigenvectors[:, i] ** 2,\n            h,\n            h,\n            ny + 1,\n            nx + 1,\n        )\n        norms[i] = norm\n        if normalise_eigenvectors:\n            eigenvectors[:, i] /= np.sqrt(norm)\n    return eigenvalues, eigenvectors, norms\n:::\n::: {#cell-17 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef multiresolution_eigendecomposition(\n    params,\n    n_modes,\n    bcs,\n    h,\n    nx: int,\n    ny: int,\n    levels: int = 2,\n):\n    \"\"\"\n    Runs the biharmonic eigendecomposition and eigenvector alignment on multiple grid resolutions.\n\n    Parameters\n      params:       Parameters object containing domain lengths (e.g. params.lx and params.ly).\n      n_modes:      Number of eigenmodes to compute.\n      bcs:          Boundary conditions.\n      h:            Initial grid spacing.\n      nx, ny:       Initial grid dimensions.\n      levels:       Total number of resolutions to run (default 2).\n                    The first level is the coarse grid, and each subsequent level\n                    uses h/2 and double the grid points to cover the same domain.\n\n    Returns\n      swapped_eigenvectors, swapped_eigenvalues from the last refinement.\n    \"\"\"\n    # Store the coarse grid values to use as a reference for eigenMAC.\n    ref_h, ref_nx, ref_ny = h, nx, ny\n\n    # Run the coarse-grid eigen-decomposition.\n    _, ref_eigenvectors, norms = biharmonic_eigendecomposition(\n        params,\n        n_modes,\n        bcs,\n        nx,\n        ny,\n        h,\n    )\n\n    # For each subsequent refinement level, halve h and double the grid points.\n    for _ in range(1, levels):\n        print(f\"Refining grid to h = {h / 2}, nx = {nx * 2}, ny = {ny * 2}\")\n        h = h / 2\n        nx = int(nx * 2)\n        ny = int(ny * 2)\n\n        omega_mu, eigenvectors, norms = biharmonic_eigendecomposition(\n            params,\n            n_modes,\n            bcs,\n            nx,\n            ny,\n            h,\n        )\n\n        swapped_eigenvectors, swapped_eigenvalues = eigenMAC(\n            ref_eigenvectors=ref_eigenvectors,\n            ref_nx=ref_nx,\n            ref_ny=ref_ny,\n            eigenvectors=eigenvectors,\n            eigenvalues=omega_mu,\n            nx=nx,\n            ny=ny,\n            n_modes=n_modes,\n            Lx=params.l1,\n            Ly=params.l2,\n            h=h,\n        )\n\n        # Optionally, update the reference eigenvectors for the next level.\n        ref_eigenvectors = swapped_eigenvectors\n\n    return swapped_eigenvectors, swapped_eigenvalues, nx, ny, h, norms\n:::",
    "crumbs": [
      "Numerical utilities"
    ]
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "::: {#cell-3 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’ 6=‘i’}\nimport jax.numpy as jnp\nimport numpy as np\nfrom scipy.interpolate import RectBivariateSpline\n:::\n::: {#cell-4 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef to_db(x):\n    return 20 * jnp.log10(x)\n:::\n::: {#cell-5 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef impulse_response(\n    b: jnp.ndarray,  # numerators of the discrete transfer function\n    a: jnp.ndarray,  # denominators of the discrete transfer function\n    n=4410,\n):\n    \"\"\"\n    Compute the impulse response of a discrete time system\n\n    Parameters\n    ----------\n    b : jnp.ndarray\n        The numerator of the discrete transfer function, with shape (n_modes, n)\n    a : jnp.ndarray\n        The denominator of the discrete transfer function, with shape (n_modes, n)\n\n    Returns\n    -------\n    jnp.ndarray\n        The impulse response of the system, with shape (n_modes, n)\n\n    \"\"\"\n    # sample the discrete time systems\n    ret = jnp.fft.rfft(b, n=n) / jnp.fft.rfft(a, n=n)\n    return jnp.fft.irfft(ret)\n:::\n::: {#cell-6 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef eigenMAC(\n    ref_eigenvectors,\n    ref_nx,\n    ref_ny,\n    eigenvectors,\n    eigenvalues,\n    nx,\n    ny,\n    n_modes,\n    Lx,\n    Ly,\n):\n    \"\"\"\n    Computes the Modal Assurance Criterion (MAC) between reference eigenvectors and given eigenvectors.\n\n    Parameters:\n    ref_eigenvectors : ndarray\n        Reference eigenvectors (reshaped for interpolation).\n    ref_nx : int\n        Number of reference grid points along the x-axis.\n    ref_ny : int\n        Number of reference grid points along the y-axis.\n    eigenvectors : ndarray\n        Eigenvectors to compare against the reference.\n    eigenvalues : ndarray\n        Corresponding eigenvalues of the eigenvectors.\n    nx : int\n        Number of grid points along the x-axis for interpolation.\n    ny : int\n        Number of grid points along the y-axis for interpolation.\n    n_modes : int\n        Number of modes to compare.\n    Lx : float\n        Length of the domain along the x-axis.\n    Ly : float\n        Length of the domain along the y-axis.\n\n    Returns:\n    eigenvectors_swapped : ndarray\n        Reordered eigenvectors after MAC computation.\n    eigenvalues_swapped : ndarray\n        Reordered eigenvalues after MAC computation.\n    \"\"\"\n    # Define reference and target grids\n    xref = np.linspace(0, Lx, ref_nx + 1)\n    yref = np.linspace(0, Ly, ref_ny + 1)\n\n    x = np.linspace(0, Lx, nx + 1)\n    y = np.linspace(0, Ly, ny + 1)\n\n    # Interpolate eigenvectors\n    interpolated_eigenvectors = np.zeros(((nx + 1) * (ny + 1), n_modes))\n    for mode in range(n_modes):\n        Z = ref_eigenvectors[:, mode].reshape(ref_nx + 1, ref_ny + 1)\n\n        interpolator = RectBivariateSpline(\n            xref,\n            yref,\n            Z,\n            kx=1,\n            ky=1,\n        )\n\n        interpolated_eigenvectors[:, mode] = interpolator(x, y).ravel()\n\n    # Compute MAC matrix\n    norm_eigenvectors = np.sum(eigenvectors**2, axis=0, keepdims=True)\n    norm_interpolated = np.sum(interpolated_eigenvectors**2, axis=0, keepdims=True)\n\n    num = np.abs(interpolated_eigenvectors.T @ eigenvectors) ** 2\n    den = norm_interpolated.T @ norm_eigenvectors  # Shape (n_modes, n_modes)\n\n    MAC_matrix = num / den\n    MAC_matrix[MAC_matrix &lt; 0.1] = 0\n    np.fill_diagonal(MAC_matrix, 0)\n\n    # Find matching indices\n    rows, cols = np.where(MAC_matrix &gt; 0)\n    lmc = len(cols)\n\n    if lmc &gt; 0:\n        swap_indices = np.arange(n_modes)\n        check = rows[0]\n        for i in range(lmc - 1):\n            if check != cols[i]:\n                swap_indices[cols[i]], swap_indices[rows[i]] = (\n                    swap_indices[rows[i]],\n                    swap_indices[cols[i]],\n                )\n                check = rows[i]\n\n        # Reorder eigenvectors and eigenvalues\n        eigenvectors_swapped = eigenvectors[:, swap_indices]\n        eigenvalues_swapped = eigenvalues[swap_indices]\n\n    return eigenvectors_swapped, eigenvalues_swapped\n:::",
    "crumbs": [
      "Utils"
    ]
  },
  {
    "objectID": "sv.html",
    "href": "sv.html",
    "title": "Stormer-verlet integrators",
    "section": "",
    "text": "The stormer-verlet is a centered difference scheme used to approximate derivatives. In the present case we use it for approximating the second and first derivatives of an oscillator defined by the following differential equation:\n\\[\n\\ddot{q} + c \\dot{q} + k q = f(t)\n\\]\nThe finite difference operators are defined as:\n\\[\n\\begin{align}\n\\delta_t q &= \\frac{q^{n+1} - q^{n-1}}{2 h} \\\\\n\\delta_{tt} q &= \\frac{q^{n+1} - 2 q^n + q^{n-1}}{h^2}\n\\end{align}\n\\]\nfor the first derivative and the second derivative respectively. The difference equation for the oscillator is then:\n\\[\n\\delta_{tt} q + c \\delta_t q + k q = f(t)\n\\]\nafter expanding and some algebraic manipulation to isolate \\(q^{n+1}\\) we get:\n\\[\n\\bigl(\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\bigr)\\,q^{n+1} +\n\\bigl(-\\tfrac{2}{h^2} + k\\bigr) q^n +\n\\bigl(\\tfrac{1}{h^2} - \\tfrac{c}{2h}\\bigr)\\,q^{n-1} =\nf(t^n).\n\\]\n\\[\n\\boxed{\nq^{n+1} = \\frac{2 h^2}{2 + c h}\n\\Bigl[\nf(t^n) + \\Bigl(\\tfrac{2}{h^2} - k\\Bigr) q^n +\n\\Bigl(-\\tfrac{1}{h^2} + \\tfrac{c}{2h}\\Bigr) q^{n-1}\n\\Bigr].\n}\n\\]\nTo make it more readable we can define the following constants:\n\\[\n\\begin{align}\na &= \\frac{2 h^2}{2 + c h} \\\\\nb &= \\frac{2}{h^2} - k \\\\\nc &= -\\frac{1}{h^2} + \\frac{c}{2h}\n\\end{align}\n\\]\nso that the equation becomes:\n\\[\n\\boxed{\nq^{n+1} = a \\Bigl[ f(t^n) + b q^n + c q^{n-1} \\Bigr].\n}\n\\]\nSince we have \\(h^2\\) in the denominator we can multiply the whole equation by \\(h^2\\) to get rid of it. Then the constants become:\n\\[\n\\begin{align}\na &= \\frac{2}{2 + c h} \\\\\nb &= 2 - k h^2 \\\\\nc &= -1 + \\frac{c h}{2}\n\\end{align}\n\\]\nNote that we also need to multiply the forcing term and the eventual non-linear terms by \\(h^2\\). Since we also divide all \\(k\\) and \\(c\\) by \\(\\rho\\) we can define a new constant \\(g = \\frac{h^2}{\\rho}\\) so that the equation becomes:\n::: {#cell-5 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’ 6=‘i’}\nimport einops\nimport jax\nimport jax.numpy as jnp\n:::\n::: {#cell-6 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef A_inv_vector(\n    h,  # temporal grid spacing (scalar)\n    damping,  # damping term (vector)\n):\n    \"\"\"\n    Also this is already multiplied $h^2$\n    \"\"\"\n    return 2.0 * h**2 / (2.0 + damping * h)\n    # return 2.0 / (2.0 + damping * h)\n\n\ndef B_vector(\n    h,  # temporal grid spacing (scalar)\n    stiffness,  # stiffness term (vector)\n):\n    \"\"\"\n    Note this include the minus side caused by puting this term on the right hand side of the equation. Also this is already multiplied $h^2$\n    \"\"\"\n    return 2.0 / h**2 - stiffness\n\n    # return 2.0 - stiffness * h**2\n\n\ndef C_vector(\n    h,  # temporal grid spacing (scalar)\n    damping,  # damping term (vector)\n):\n    \"\"\"\n    Note this include the minus side caused by puting this term on the right hand side of the equation. Also this is already multiplied $h^2$\n    \"\"\"\n    return -1.0 / h**2 + (damping / (2.0 * h))\n    # return -1.0 + damping * h * 0.5\n:::\n\nStormer-verlet for the tension modulated case\n\\[\nD \\Delta \\Delta w + \\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w}- T_0 \\Delta w = f_{ext} - T_{nl} \\Delta w\n\\]\nwe can rearrange the terms to isolate have it in the form:\n\\[\n\\rho \\ddot{w} + \\left(d_1 + d_3 \\Delta\\right)\\dot{w} + (D \\Delta \\Delta - T_0 \\Delta) w = f_{ext} - T_{nl} \\Delta w\n\\]\nBy applying the SLT transformation to get rid of the spatial derivatives we get:\n\\[\n\\rho \\ddot{q} + \\left(d_1 + d_3 \\lambda \\right)\\dot{q} + (D \\lambda^2 - T_0 \\lambda) q = f_{ext} - \\bar{T}_{nl} \\lambda q\n\\]\nnow by applying the previously defined differece operators we get:\n$$ q^{n+1} = a .\n$$\nwhere the constants are:\n\\[\n\\begin{align}\na &= g\\left(\\frac{2}{2 + d_1 + d_3 \\lambda h}\\right) \\\\\nb &= g\\left(2 -  D \\lambda^2 - T_0 \\lambda h^2\\right) \\\\\nc &= g\\left(-1 +  \\frac{d_1 + d_3 \\lambda h}{2}\\right)\n\\end{align}\n\\]\nwe know that \\(\\bar{T}_{N L}(q)=\\frac{1}{2} \\frac{E A}{L} \\sum_\\eta \\frac{\\lambda_\\eta q_\\eta^2(t)}{\\left\\|K_\\eta\\right\\|_2^2}\\) from Avanzini and Trautmann.\n::: {#cell-9 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@jax.jit\ndef solve_sv_berger_jax_scan(\n    A_inv: jnp.ndarray,\n    B: jnp.ndarray,\n    C: jnp.ndarray,\n    modal_excitation: jnp.ndarray,  # (T, n_modes)\n    lambda_mu: jnp.ndarray,\n    factors: jnp.ndarray,\n    g: float,  # factor for the input\n):\n    n_modes = A_inv.shape[0]\n    q = jnp.zeros((n_modes,))  # Modal displacement vector at n (n_modes, 1)\n    q_prev = jnp.zeros((n_modes,))  # Modal displacement vector at n-1\n\n    def advance_state(\n        state: jnp.ndarray,  # inital state\n        x: jnp.ndarray,  # input\n    ) -&gt; tuple[jnp.ndarray, jnp.ndarray]:  # carry, output\n        # unpack state\n        q_prev, q = state\n\n        nl = lambda_mu * q * (factors @ q**2)\n\n        # compute the next state\n        # q_next = B * q + C * q_prev - g * nl + g * x\n        q_next = B * q + C * q_prev - g * nl + x\n\n        # return the next state and the output\n        return (q, q_next), q_next\n\n    state, final = jax.lax.scan(\n        advance_state,\n        (q_prev, q),\n        modal_excitation,  # (T, n_modes)\n        unroll=8,\n    )\n    return state, final\n:::\n\n# # | export\n\n\n# @jax.jit\n# def solve_sv_vk_jax_scan(\n#     A_inv: jnp.ndarray,\n#     B: jnp.ndarray,\n#     C: jnp.ndarray,\n#     modal_excitation: jnp.ndarray,  # (T, n_modes)\n#     Hv: jnp.ndarray,\n#     zetafourth: jnp.ndarray,\n#     C_NL: float,\n#     g: float,  # factor for the input\n# ):\n#     n_modes = A_inv.shape[0]\n#     q = jnp.zeros((n_modes,))  # Modal displacement vector at n (n_modes, 1)\n#     q_prev = jnp.zeros((n_modes,))  # Modal displacement vector at n-1\n\n#     # precompute Hv divided by the eigenvalues to make it a bit faster\n#     Hva = Hv / (2.0 * zetafourth)\n\n#     def advance_state(\n#         state: jnp.ndarray,  # inital state\n#         x: jnp.ndarray,  # input\n#     ) -&gt; tuple[jnp.ndarray, jnp.ndarray]:  # carry, output\n#         # unpack state\n#         q_prev, q = state\n\n#         nl = C_NL * einops.einsum(\n#             Hva,\n#             Hv,\n#             q,\n#             q,\n#             q,\n#             \"m i j, k l j, i, k, l -&gt; m\",\n#         )\n#         # compute the next state\n#         q_next = A_inv * (B * q + C * q_prev - g * nl + g * x)\n\n#         # return the next state and the output\n#         return (q, q_next), q_next\n\n#     state, final = jax.lax.scan(\n#         advance_state,\n#         (q_prev, q),\n#         modal_excitation,  # (T, n_modes)\n#         unroll=8,\n#     )\n#     return state, final\n\n::: {#cell-11 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@jax.jit\ndef solve_sv_vk_jax_scan(\n    A_inv: jnp.ndarray,\n    B: jnp.ndarray,\n    C: jnp.ndarray,\n    modal_excitation: jnp.ndarray,  # (T, n_modes)\n    Hv: jnp.ndarray,\n    g: float,  # factor for the input\n):\n    n_modes = A_inv.shape[0]\n    q = jnp.zeros((n_modes,))  # Modal displacement vector at n (n_modes, 1)\n    q_prev = jnp.zeros((n_modes,))  # Modal displacement vector at n-1\n\n    def advance_state(\n        state: jnp.ndarray,  # inital state\n        x: jnp.ndarray,  # input\n    ) -&gt; tuple[jnp.ndarray, jnp.ndarray]:  # carry, output\n        # unpack state\n        q_prev, q = state\n\n        nl = einops.einsum(\n            Hv,\n            Hv,\n            q,\n            q,\n            q,\n            \"n p q, n r s, p, q, r -&gt; s\",\n        )\n        # compute the next state\n        q_next = B * q + C * q_prev - g * nl + x\n\n        # return the next state and the output\n        return (q, q_next), q_next\n\n    state, final = jax.lax.scan(\n        advance_state,\n        (q_prev, q),\n        modal_excitation,  # (T, n_modes)\n        unroll=8,\n    )\n    return state, final\n:::",
    "crumbs": [
      "Stormer-verlet integrators"
    ]
  },
  {
    "objectID": "excitations.html",
    "href": "excitations.html",
    "title": "Excitation functions",
    "section": "",
    "text": "::: {#cell-3 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’ 6=‘i’}\nimport numpy as np\n:::\n\nimport matplotlib.pyplot as plt\n\n::: {#cell-5 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef create_1d_raised_cosine(\n    duration: float,\n    start_time: float,\n    end_time: float,\n    amplitude: float,\n    sample_rate: float,\n):\n    \"\"\"\n    Create a 1D raised cosine excitation with time parameters in seconds.\n\n    Parameters\n    ----------\n    duration : float\n        Total duration of the excitation (in seconds).\n    start_time : float\n        Start time of the excitation (in seconds).\n    end_time : float\n        End time of the excitation (in seconds).\n    amplitude : float\n        Amplitude of the excitation.\n    sample_rate : float\n        Sample rate (samples per second).\n\n    Returns\n    -------\n    excitation : ndarray\n        The excitation signal.\n    \"\"\"\n    num_samples = int(duration * sample_rate)\n    excitation = np.zeros(num_samples)\n\n    start_index = int(start_time * sample_rate)\n    end_index = int(end_time * sample_rate)\n\n    if start_index &lt; 0 or end_index &gt; num_samples or start_index &gt;= end_index:\n        raise ValueError(\"Invalid start_time or end_time range.\")\n\n    excitation[start_index:end_index] = (\n        amplitude\n        * (1 - np.cos(2 * np.pi * np.linspace(0, 1, end_index - start_index)))\n        / 2\n    )\n\n    return excitation\n:::\n\nrc = create_1d_raised_cosine(\n    1,\n    0.01,\n    0.05,\n    1,\n    44100,\n)\n\nplt.plot(rc)\n\n\n\n\n\n\n\n\n::: {#cell-7 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef create_raised_cosine(Nx, Ny, h, ctr, epsilon, wid):\n    \"\"\"\n    Create a raised cosine function on a 2D grid.\n\n    Parameters:\n        Nx (int): Number of grid points in the x-direction.\n        Ny (int): Number of grid points in the y-direction.\n        h (float): Grid spacing.\n        ctr (tuple): Center of the raised cosine (x, y).\n        epsilon (float): Scaling parameter.\n        wid (float): Width of the cosine.\n\n    Returns:\n        np.ndarray: Flattened raised cosine array.\n    \"\"\"\n    # Create the grid\n    X, Y = np.meshgrid(np.arange(0, Nx + 1) * h, np.arange(0, Ny + 1) * h)\n\n    # Compute the distance\n    dist_x = (X - ctr[0]) ** 2\n    dist_y = (Y - ctr[1]) ** 2\n    dist = np.sqrt(dist_x + dist_y)\n\n    # Compute the indicator function\n    ind = np.sign(np.maximum(-dist + wid / 2, 0))\n\n    # Compute the raised cosine\n    rc = 0.5 * ind.T * (1 + np.cos(2 * np.pi * dist.T / wid))\n\n    # Flatten the array\n    # rc = rc.ravel()\n    return rc, X, Y, dist, dist_x, dist_y\n:::\n\nfrom matplotlib import pyplot as plt\n\n\n# Example usage\nNx, Ny = 25, 21  # Grid dimensions\nh = 0.0438  # Grid spacing\nctr = (0.5, 0.5)  # Center of the raised cosine\nepsilon = 1.2000  # Scaling parameter\nwid = 0.3  # Width of the cosine\n\nrc, X, Y, dist, distx, disty = create_raised_cosine(\n    Nx,\n    Ny,\n    h,\n    ctr,\n    epsilon,\n    wid,\n)\n\nplt.imshow(rc, cmap=\"gray\", origin=\"lower\")\n\n\n\n\n\n\n\n\n::: {#cell-10 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef create_pluck_modal(\n    lambdas: np.ndarray,  # eigenvalues of the Laplacian operator\n    pluck_position: float = 0.28,  # position of pluck on the string in meters\n    initial_deflection: float = 0.03,  # initial deflection of the string in meters\n    string_length: float = 1.0,  # total length of the string in meters\n) -&gt; np.ndarray:\n    \"\"\"\n    Create a pluck excitation for a string with a given length and pluck position.\n    The pluck is modeled in the modal domain.\n\n    Parameters\n    ----------\n    wavenumbers : np.ndarray\n        The wavenumbers of the modes.\n    xe : float\n        The position of the pluck in meters.\n    hi : float\n        The initial deflection of the string in meters.\n    length : float\n        The length of the string in meters.\n\n    Returns\n    -------\n    np.ndarray\n        The pluck excitation in the modal domain.\n    \"\"\"\n\n    lambdas_sqrt = np.sqrt(lambdas)\n\n    # Scaling factor for the initial deflection\n    deflection_scaling = initial_deflection * (\n        string_length / (string_length - pluck_position)\n    )\n\n    # Compute the coefficients\n    coefficients = (\n        deflection_scaling\n        * np.sin(lambdas_sqrt * pluck_position)\n        / (lambdas_sqrt * pluck_position)\n    )\n    coefficients /= lambdas_sqrt\n\n    return coefficients\n:::",
    "crumbs": [
      "Excitation functions"
    ]
  },
  {
    "objectID": "coupling.html",
    "href": "coupling.html",
    "title": "Coupling functions",
    "section": "",
    "text": "::: {#cell-3 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’ 6=‘i’}\n:::",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "href": "coupling.html#integrals-for-building-the-mass-and-stifness-matrices",
    "title": "Coupling functions",
    "section": "Integrals for building the mass and stifness matrices",
    "text": "Integrals for building the mass and stifness matrices\n::: {#cell-5 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef int4(m, p, L):\n    \"\"\"\n    Integral of Xd(m,x)*Xd(p,x) from 0 to L,\n    where X is the clamped-plate function and d denotes derivative in x.\n    Piecewise definition follows the original Matlab code exactly.\n    \"\"\"\n    if m == 0 and p == 0:\n        y = 120.0 / (7.0 * L)\n    elif (m == p) and (m != 0):\n        # (768*pi^2*m^2 - 47040*(-1)^m + 35*pi^4*m^4 + 432*(-1)^m*pi^2*m^2 - 53760) / (70*L*pi^2*m^2)\n        y = (\n            768.0 * math.pi**2 * m * m\n            - 47040.0 * ((-1) ** m)\n            + 35.0 * math.pi**4 * m**4\n            + 432.0 * ((-1) ** m) * math.pi**2 * m * m\n            - 53760.0\n        ) / (70.0 * L * math.pi**2 * m * m)\n    elif m == 0:\n        # (60*((-1)^p + 1)*(pi^2*p^2 - 42)) / (7*L*pi^2*p^2)\n        num = 60.0 * (((-1) ** p + 1.0) * (math.pi**2 * p**2 - 42.0))\n        den = 7.0 * L * math.pi**2 * p**2\n        y = num / den\n    elif p == 0:\n        # (60*((-1)^m + 1)*(pi^2*m^2 - 42)) / (7*L*pi^2*m^2)\n        num = 60.0 * (((-1) ** m + 1.0) * (math.pi**2 * m**2 - 42.0))\n        den = 7.0 * L * math.pi**2 * m**2\n        y = num / den\n    else:\n        # 192/35/L*(1 + (-1)^m*(-1)^p)\n        # - 192/(m^2*p^2*L*pi^2)*((p^2+m^2)*(1 + (-1)^m*(-1)^p))\n        # - 168/(m^2*p^2*L*pi^2)*((p^2+m^2)*((-1)^m + (-1)^p))\n        # + 108/35/L*((-1)^m + (-1)^p)\n        term1 = 192.0 / 35.0 / L * (1.0 + (-1) ** m * (-1) ** p)\n        term2 = (\n            -192.0\n            / (m * m * p * p * L * math.pi**2)\n            * ((p * p + m * m) * (1.0 + (-1) ** m * (-1) ** p))\n        )\n        term3 = (\n            -168.0\n            / (m * m * p * p * L * math.pi**2)\n            * ((p * p + m * m) * (((-1) ** m) + ((-1) ** p)))\n        )\n        term4 = 108.0 / 35.0 / L * (((-1) ** m) + ((-1) ** p))\n        y = term1 + term2 + term3 + term4\n    return y\n\n\ndef int1(m, p, L):\n    \"\"\"\n    Function int1(m,p,L). Piecewise definition from the Matlab code.\n    \"\"\"\n    if m == 0 and p == 0:\n        # y = 720 / L^3\n        y = 720.0 / (L**3)\n    elif m == p:\n        # (pi^4*m^4 - 672*(-1)^m - 768)/(2*L^3)\n        y = ((math.pi**4) * (m**4) - 672.0 * ((-1) ** m) - 768.0) / (2.0 * (L**3))\n    elif m == 0 or p == 0:\n        # y=0\n        y = 0.0\n    else:\n        # -(24*(7*(-1)^m + 7*(-1)^p + 8*(-1)^m*(-1)^p + 8))/L^3\n        val = (\n            7.0 * ((-1) ** m)\n            + 7.0 * ((-1) ** p)\n            + 8.0 * ((-1) ** m) * ((-1) ** p)\n            + 8.0\n        )\n        y = -24.0 * val / (L**3)\n    return y\n\n\ndef int2(m, p, L):\n    \"\"\"\n    Function int2(m,p,L). Piecewise definition from the Matlab code.\n    \"\"\"\n    if m == 0 and p == 0:\n        y = (10.0 * L) / 7.0\n    elif m == p:\n        # (67*L)/70 - ((-1)^m*L)/35 - (768*L)/(pi^4*m^4) - (672*(-1)^m*L)/(pi^4*m^4)\n        y = (\n            (67.0 * L) / 70.0\n            - ((-1) ** m * L) / 35.0\n            - (768.0 * L) / (math.pi**4 * m**4)\n            - (672.0 * ((-1) ** m) * L) / (math.pi**4 * m**4)\n        )\n    elif m == 0:\n        # (3*L*((-1)^p + 1)*(pi^4*p^4 - 1680)) / (14*pi^4*p^4)\n        num = 3.0 * L * (((-1) ** p + 1.0) * ((math.pi**4) * (p**4) - 1680.0))\n        den = 14.0 * math.pi**4 * (p**4)\n        y = num / den\n    elif p == 0:\n        # (3*L*((-1)^m + 1)*(pi^4*m^4 - 1680)) / (14*pi^4*m^4)\n        num = 3.0 * L * (((-1) ** m + 1.0) * ((math.pi**4) * (m**4) - 1680.0))\n        den = 14.0 * math.pi**4 * (m**4)\n        y = num / den\n    else:\n        # Big piecewise \"else\" expression from the Matlab code\n        # -(L*(11760*(-1)^m + 11760*(-1)^p - 16*pi^4*m^4 + ...)) / (70*pi^4*m^4)\n        #  - (L*(13440*m^4 + 11760*(-1)^m*m^4 + 11760*(-1)^p*m^4 + ... )) / (70*pi^4*m^4*p^4)\n        part1 = (\n            11760.0 * ((-1) ** m)\n            + 11760.0 * ((-1) ** p)\n            - 16.0 * (math.pi**4) * m**4\n            + 13440.0 * ((-1) ** m) * ((-1) ** p)\n            + ((-1) ** m) * (math.pi**4) * (m**4)\n            + ((-1) ** p) * (math.pi**4) * (m**4)\n            - 16.0 * ((-1) ** m) * ((-1) ** p) * (math.pi**4) * (m**4)\n            + 13440.0\n        )\n        part2 = (\n            13440.0 * m**4\n            + 11760.0 * ((-1) ** m) * m**4\n            + 11760.0 * ((-1) ** p) * m**4\n            + 13440.0 * ((-1) ** m) * ((-1) ** p) * m**4\n        )\n        y = -(L * part1) / (70.0 * (math.pi**4) * (m**4)) - (L * part2) / (\n            70.0 * (math.pi**4) * (m**4) * (p**4)\n        )\n    return y\n\n\ndef int2_mat(N, L):\n    \"\"\"\n    Builds the N x N matrix whose (m,p) entry is int2(m,p,L).\n    Mirrors the logic of the original Matlab int2_mat function exactly,\n    but we can do it more simply by calling int2 in a loop.\n    \"\"\"\n    y = np.zeros((N, N), dtype=float)\n    for m in range(N):\n        for p in range(N):\n            y[m, p] = int2(m, p, L)\n    return y\n\n\ndef build_I1(N, L):\n    \"\"\"Returns the N x N matrix whose (m,p) entry = int1(m,p,L).\"\"\"\n    I = np.zeros((N, N), dtype=float)\n    for m in range(N):\n        for p in range(N):\n            I[m, p] = int1(m, p, L)\n    return I\n\n\ndef build_I2(N, L):\n    \"\"\"Returns the N x N matrix whose (m,p) entry = int2(m,p,L).\"\"\"\n    I = np.zeros((N, N), dtype=float)\n    for m in range(N):\n        for p in range(N):\n            I[m, p] = int2(m, p, L)\n    return I\n\n\ndef build_I4(N, L):\n    \"\"\"Returns the N x N matrix whose (m,p) entry = int4(m,p,L).\"\"\"\n    I = np.zeros((N, N), dtype=float)\n    for m in range(N):\n        for p in range(N):\n            I[m, p] = int4(m, p, L)\n    return I\n\n\ndef assemble_K_and_M(Npsi, Lx, Ly):\n    # 1) Precompute integrals in the x-direction:\n    I1x = build_I1(Npsi, Lx)\n    I2x = build_I2(Npsi, Lx)\n    I4x = build_I4(Npsi, Lx)\n\n    # 2) Precompute integrals in the y-direction:\n    I1y = build_I1(Npsi, Ly)\n    I2y = build_I2(Npsi, Ly)\n    I4y = build_I4(Npsi, Ly)\n\n    # 3) Build the K, M matrices via Kronecker products:\n    K = np.kron(I1x, I2y) + np.kron(I2x, I1y) + 2.0 * np.kron(I4x, I4y)\n    M = np.kron(I2x, I2y)\n\n    return K, M\n:::\n::: {#cell-6 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef airy_stress_coefficients(\n    n_psi,\n    vals,\n    vecs,\n):\n    \"\"\"\n    Compute the Airy stress function coefficients from the eigenvalues and eigenvectors\n    \"\"\"\n\n    # Remove negative or imaginary eigenvalues:\n    #    (1) negative real part\n    #    (2) any non-zero imaginary part\n    real_vals = vals.real\n    imag_vals = vals.imag\n\n    # Indices of negative or significantly imaginary eigenvalues\n    eps_imag = 1e-12  # small threshold\n    bad_neg = np.where(real_vals &lt; 0.0)[0]\n    bad_imag = np.where(abs(imag_vals) &gt; eps_imag)[0]\n    bad_indices = np.unique(np.concatenate((bad_neg, bad_imag)))\n\n    # Filter out the unwanted eigenvalues and eigenvectors\n    good_mask = np.ones(vals.shape, dtype=bool)\n    good_mask[bad_indices] = False\n    good_vals = vals[good_mask]\n    good_vecs = vecs[:, good_mask]\n\n    # Sort them\n    idx_sort = np.argsort(good_vals.real)  # sort by real part\n    auto = good_vals.real[idx_sort]\n    coeff = good_vecs[:, idx_sort]\n\n    # Build the factor arrays (coeff0, coeff1, coeff2)\n    dim = n_psi**2\n    coeff0 = np.zeros((dim, coeff.shape[0]), dtype=float)\n    coeff1 = np.zeros((dim, coeff.shape[0]), dtype=float)\n    coeff2 = np.zeros((dim, coeff.shape[0]), dtype=float)\n\n    NN = int2_mat(n_psi, 0.2)  # NxN\n    MM = int2_mat(n_psi, 0.3)  # NxN\n\n    NN = np.tile(NN.reshape(-1, 1), dim)\n    MM = np.tile(MM.reshape(1, -1), (dim, 1))\n\n    nmatr = NN * MM\n    nmatr = np.reshape(nmatr, (n_psi, n_psi, n_psi, n_psi))\n\n    # 3) Permute from [0,1,2,3] -&gt; [3,0,2,1]\n    #    i.e. \"permute(nmatr,[4 1 3 2])\" in Matlab =&gt; zero-based is (3,0,2,1)\n    nmatr = np.transpose(nmatr, (3, 0, 2, 1))\n    nmatr = np.reshape(nmatr, (1, n_psi**4))\n\n    nmatr = sparse.csr_matrix(nmatr)  # Or \"sparse.csc_matrix(nmatr)\" or whichever\n\n    S = auto.shape[0]\n\n    for d in range(S):\n        temp = coeff[:, d]  # shape (DIM,)\n\n        # \"temp = reshape(temp, [Npsi^2,1]);\"\n        temp = temp.reshape(n_psi**2, 1)  # shape (DIM,1)\n\n        # \"temp = repmat(temp,[1 Npsi^2]);\" =&gt; now shape (DIM, DIM)\n        # In Python: replicate horizontally Npsi^2 times\n        temp_big = np.tile(temp, (1, n_psi**2))  # shape (DIM, DIM)\n\n        # \"temp2 = permute(temp,[2,1]);\" =&gt; shape (DIM, DIM) transposed\n        temp2 = temp_big.T  # shape (DIM, DIM)\n\n        # \"temp3 = temp.*temp2;\" =&gt; shape (DIM, DIM), elementwise multiply\n        temp3 = temp_big * temp2  # shape (DIM, DIM)\n\n        # \"temp3 = reshape(temp3,[Npsi^4,1]);\"\n        temp3 = temp3.reshape(n_psi**4, 1)  # shape (Npsi^4, 1)\n\n        # \"norms = (nmatr*temp3);\" =&gt; shape (1,1)\n        # with nmatr shape (1, Npsi^4), temp3 shape (Npsi^4,1)\n        norms = nmatr.dot(temp3)  # shape (1,1) as a sparse result\n\n        # Convert to scalar:\n        # norms_val = norms[0,0]\n\n        # Then do the same normalizations:\n        coeff0[:, d] = coeff[:, d] / np.sqrt(norms)\n        coeff1[:, d] = coeff[:, d] / np.sqrt(norms) / np.sqrt(auto[d])\n        coeff2[:, d] = coeff[:, d] / np.sqrt(norms) / auto[d]\n\n    # \"S = floor(S/2);\"\n    S2 = S // 2\n\n    coeff0 = coeff0[:S2, :S2]\n    coeff1 = coeff1[:S2, :S2]\n    coeff2 = coeff2[:S2, :S2]\n\n    return coeff0, coeff1, coeff2\n:::",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "href": "coupling.html#basis-used-to-build-the-mass-and-stiffness-matrices",
    "title": "Coupling functions",
    "section": "Basis used to build the mass and stiffness matrices",
    "text": "Basis used to build the mass and stiffness matrices\n::: {#cell-8 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef _basis(m, x, Lx):\n    \"\"\"\n    Evaluate the 1D basis function in the x or y direction\n    for integer index m at location x, with length Lx.\n    \"\"\"\n    # Python integer exponent (-1)**m is fine for integer m\n    return (\n        np.cos(m * np.pi * x / Lx)\n        + (15 * (1 + (-1) ** m) / Lx**4) * x**4\n        - (4 * (8 + 7 * (-1) ** m) / Lx**3) * x**3\n        + (6 * (3 + 2 * (-1) ** m) / Lx**2) * x**2\n        - 1.0\n    )\n\n\ndef basis(m, n, x, y, Lx, Ly):\n    \"\"\"\n    Evaluate the full 2D basis function for indices (m, n)\n    at point (x, y). This is simply X_m(x)*Y_n(y).\n    \"\"\"\n    return _basis(m, x, Lx) * _basis(n, y, Ly)\n:::",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "href": "coupling.html#partial-integrals-to-calculate-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "Partial integrals to calculate the coupling matrix",
    "text": "Partial integrals to calculate the coupling matrix\n::: {#cell-10 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef i1_mat(Npsi, Nphi, L):\n    # Initialize a 3D array of zeros.\n    s = np.zeros((Npsi, Nphi, Nphi))\n\n    # Loop over indices.\n    # In MATLAB: m = 1:Npsi, here m = 0,...,Npsi-1, and m1 = m (since MATLAB m1 = m-1)\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if m1 == 0 and n == p:\n                    s[m - 1, n - 1, p - 1] = L / 2.0\n                elif m1 == (p - n) or m1 == (n - p):\n                    s[m - 1, n - 1, p - 1] = L / 4.0\n                elif m1 == (-n - p) or m1 == (n + p):\n                    s[m - 1, n - 1, p - 1] = -L / 4.0\n    return s\n\n\ndef i2_mat(Npsi, Nphi, L):\n    \"\"\" \"\"\"\n    s = np.zeros((Npsi, Nphi, Nphi))\n\n    # Loop over m, n, and p (using 1-indexing, then subtract 1 for Python indexing)\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                # The condition \"if n==0 || p==0\" is omitted since n,p &gt;= 1.\n                if n == p:\n                    # s(m,n,p) = (15/L^4*((-1)^(m1) + 1))*(L^5*(4*pi^5*p^5 - 20*pi^3*p^3 + 30*pi*p))/(40*pi^5*p^5);\n                    numerator = L**5 * (\n                        4 * np.pi**5 * p**5 - 20 * np.pi**3 * p**3 + 30 * np.pi * p\n                    )\n                    s[m - 1, n - 1, p - 1] = (15 / L**4 * (((-1) ** m1) + 1)) * (\n                        numerator / (40 * np.pi**5 * p**5)\n                    )\n                else:\n                    # Else branch: a long expression.\n                    # First compute the common terms:\n                    np_sum = n + p\n                    np_diff = (\n                        n - p\n                    )  # note: may be negative, but the formula handles it.\n\n                    term1 = (\n                        np.sin(np.pi * np_sum)\n                        * (\n                            (1713638851887625 * L**4 * np_sum**4) / 17592186044416\n                            - (8334140006820045 * L**4 * np_sum**2) / 70368744177664\n                            + 24 * L**4\n                        )\n                    ) + 4 * np.pi * L**2 * np.cos(np.pi * np_sum) * np_sum * (\n                        ((2778046668940015 * L**2 * np_sum**2) / 281474976710656)\n                        - 6 * L**2\n                    )\n                    term1 /= np_sum**5\n\n                    term2 = (\n                        np.sin(np.pi * np_diff)\n                        * (\n                            (1713638851887625 * L**4 * np_diff**4) / 17592186044416\n                            - (8334140006820045 * L**4 * np_diff**2) / 70368744177664\n                            + 24 * L**4\n                        )\n                    ) + 4 * np.pi * L**2 * np.cos(np.pi * np_diff) * np_diff * (\n                        ((2778046668940015 * L**2 * np_diff**2) / 281474976710656)\n                        - 6 * L**2\n                    )\n                    term2 /= np_diff**5\n\n                    big_term = 8796093022208 * L * (term1 - term2)\n                    s[m - 1, n - 1, p - 1] = (\n                        -(15 / L**4 * (((-1) ** m1) + 1)) * big_term / 5383555227996211\n                    )\n    return s\n\n\ndef i3_mat(Npsi, Nphi, L):\n    \"\"\"\n    Auxiliary integral for the computation of the coupling coefficient H.\n    \"\"\"\n    s = np.zeros((Npsi, Nphi, Nphi))\n\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                # The first condition \"if n==0 && p==0\" never occurs because n, p start at 1.\n                if n == p:\n                    # Compute:\n                    # s(m,n,p) = -(-4/L^3*(7*(-1)^(m1)+8))*(L^4*(6*pi^2*p^2 - 2*pi^4*p^4))/(16*pi^4*p^4)\n                    # The double negative simplifies to a positive.\n                    s[m - 1, n - 1, p - 1] = (\n                        (4 / L**3 * (7 * (-1) ** m1 + 8))\n                        * (L**4 * (6 * np.pi**2 * p**2 - 2 * np.pi**4 * p**4))\n                        / (16 * np.pi**4 * p**4)\n                    )\n                else:\n                    # Else branch: compute two terms and add them.\n                    term1 = (\n                        (-4 / L**3 * (7 * (-1) ** m1 + 8))\n                        * (L * ((6 * L**3) / (n - p) ** 4 - (6 * L**3) / (n + p) ** 4))\n                        / (2 * np.pi**4)\n                    )\n\n                    term2 = (\n                        (-4 / L**3 * (7 * (-1) ** m1 + 8))\n                        * (\n                            L\n                            * (\n                                (\n                                    3\n                                    * L\n                                    * np.cos(np.pi * (n + p))\n                                    * (2 * L**2 - L**2 * np.pi**2 * (n + p) ** 2)\n                                )\n                                / (n + p) ** 4\n                                - (\n                                    3\n                                    * L\n                                    * np.cos(np.pi * (n - p))\n                                    * (2 * L**2 - L**2 * np.pi**2 * (n - p) ** 2)\n                                )\n                                / (n - p) ** 4\n                            )\n                        )\n                        / (2 * np.pi**4)\n                    )\n\n                    s[m - 1, n - 1, p - 1] = term1 + term2\n    return s\n\n\ndef i4_mat(Npsi, Nphi, L):\n    \"\"\"\n    Auxiliary integral for the computation of the coupling coefficient H.\n    \"\"\"\n    s = np.zeros((Npsi, Nphi, Nphi))\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if n == p:\n                    s[m - 1, n - 1, p - 1] = (\n                        -(6 / L**2 * (2 * (-1) ** m1 + 3))\n                        * (L**3 * (6 * np.pi * p - 4 * np.pi**3 * p**3))\n                        / (24 * np.pi**3 * p**3)\n                    )\n                else:\n                    term1 = (\n                        (6 / L**2 * (2 * (-1) ** m1 + 3))\n                        * (L**3 * np.cos(np.pi * (n - p)))\n                        / (np.pi**2 * (n - p) ** 2)\n                    )\n                    term2 = (\n                        (6 / L**2 * (2 * (-1) ** m1 + 3))\n                        * (L**3 * np.cos(np.pi * (n + p)))\n                        / (np.pi**2 * (n + p) ** 2)\n                    )\n                    s[m - 1, n - 1, p - 1] = term1 - term2\n    return s\n\n\ndef i5_mat(Npsi, Nphi, L):\n    s = np.zeros((Npsi, Nphi, Nphi))\n    for m in range(1, Npsi + 1):\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if n == p:\n                    s[m - 1, n - 1, p - 1] = L / 2.0\n    return -s\n\n\ndef i9_mat(Npsi, Nphi, L):\n    # Initialize a 3D array of zeros.\n    s = np.zeros((Npsi, Nphi, Nphi))\n\n    # Loop over indices.\n    # In MATLAB: m = 1:Npsi, here m = 0,...,Npsi-1, and m1 = m (since MATLAB m1 = m-1)\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if m1 == 0 and n == p:\n                    s[m - 1, n - 1, p - 1] = L / 2.0\n                elif m1 == (p - n) or m1 == (n - p):\n                    s[m - 1, n - 1, p - 1] = L / 4.0\n                elif m1 == (-n - p) or m1 == (n + p):\n                    s[m - 1, n - 1, p - 1] = L / 4.0\n    return s\n\n\ndef i10_mat(Npsi, Nphi, L):\n    s = np.zeros((Npsi, Nphi, Nphi))\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if n == p and p != 0:\n                    s[m - 1, n - 1, p - 1] = (\n                        (15 / L**4 * (((-1) ** m1) + 1))\n                        * (\n                            L**5\n                            * (\n                                4 * np.pi**5 * n**5\n                                + 20 * np.pi**3 * n**3\n                                - 30 * np.pi * n\n                            )\n                        )\n                        / (40 * np.pi**5 * n**5)\n                    )\n                else:\n                    term1 = (\n                        4\n                        * np.pi\n                        * L**2\n                        * np.cos(np.pi * (n + p))\n                        * (6 * L**2 - L**2 * np.pi**2 * (n + p) ** 2)\n                    ) / (n + p) ** 4\n                    term2 = (\n                        4\n                        * np.pi\n                        * L**2\n                        * np.cos(np.pi * (n - p))\n                        * (6 * L**2 - L**2 * np.pi**2 * (n - p) ** 2)\n                    ) / (n - p) ** 4\n                    s[m - 1, n - 1, p - 1] = (\n                        -(15 / L**4 * (((-1) ** m1) + 1))\n                        * (L * (term1 + term2))\n                        / (2 * np.pi**5)\n                    )\n    return s\n\n\ndef i11_mat(Npsi, Nphi, L):\n    s = np.zeros((Npsi, Nphi, Nphi))\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if n == p and p != 0:\n                    s[m - 1, n - 1, p - 1] = (\n                        (-4 / L**3 * (7 * ((-1) ** m1) + 8)) * L**4\n                    ) / 8 + ((-4 / L**3 * (7 * ((-1) ** m1) + 8)) * (3 * L**4)) / (\n                        8 * np.pi**2 * p**2\n                    )\n                else:\n                    term1 = (\n                        (-4 / L**3 * (7 * ((-1) ** m1) + 8))\n                        * (L * ((6 * L**3) / (n - p) ** 4 + (6 * L**3) / (n + p) ** 4))\n                        / (2 * np.pi**4)\n                    )\n                    term2 = (\n                        (-4 / L**3 * (7 * ((-1) ** m1) + 8))\n                        * (\n                            L\n                            * (\n                                (\n                                    3\n                                    * L\n                                    * np.cos(np.pi * (n + p))\n                                    * (2 * L**2 - L**2 * np.pi**2 * (n + p) ** 2)\n                                )\n                                / (n + p) ** 4\n                                + (\n                                    3\n                                    * L\n                                    * np.cos(np.pi * (n - p))\n                                    * (2 * L**2 - L**2 * np.pi**2 * (n - p) ** 2)\n                                )\n                                / (n - p) ** 4\n                            )\n                        )\n                        / (2 * np.pi**4)\n                    )\n                    s[m - 1, n - 1, p - 1] = term1 - term2\n    return s\n\n\ndef i12_mat(Npsi, Nphi, L):\n    s = np.zeros((Npsi, Nphi, Nphi))\n    for m in range(1, Npsi + 1):\n        m1 = m - 1\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if n == p and p != 0:\n                    s[m - 1, n - 1, p - 1] = (\n                        6 / L**2 * (2 * ((-1) ** m1) + 3)\n                    ) * L**3 / 6 + (6 / L**2 * (2 * ((-1) ** m1) + 3)) * L**3 / (\n                        4 * np.pi**2 * p**2\n                    )\n                else:\n                    s[m - 1, n - 1, p - 1] = (\n                        6 / L**2 * (2 * ((-1) ** m1) + 3)\n                    ) * L**3 * np.cos(np.pi * (n - p)) / (np.pi**2 * (n - p) ** 2) + (\n                        6 / L**2 * (2 * ((-1) ** m1) + 3)\n                    ) * L**3 * np.cos(np.pi * (n + p)) / (np.pi**2 * (n + p) ** 2)\n    return s\n\n\ndef i13_mat(Npsi, Nphi, L):\n    s = np.zeros((Npsi, Nphi, Nphi))\n    for m in range(1, Npsi + 1):\n        for n in range(1, Nphi + 1):\n            for p in range(1, Nphi + 1):\n                if n == p:\n                    s[m - 1, n - 1, p - 1] = L / 2.0\n    return -s\n:::",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "coupling.html#functions-to-put-together-the-coupling-matrix",
    "href": "coupling.html#functions-to-put-together-the-coupling-matrix",
    "title": "Coupling functions",
    "section": "functions to put together the coupling matrix",
    "text": "functions to put together the coupling matrix\n::: {#cell-12 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef compute_partial_integrals(\n    Npsi,\n    Nphi,\n    Lx,\n    Ly,\n):\n    \"\"\"\n    Precompute and store all partial-integral matrices needed.\n    Returns them in a dictionary or a custom object.\n    \"\"\"\n    partials = {}\n    partials[\"i1_Lx\"] = i1_mat(Npsi, Nphi, Lx)\n    partials[\"i2_Lx\"] = i2_mat(Npsi, Nphi, Lx)\n    partials[\"i3_Lx\"] = i3_mat(Npsi, Nphi, Lx)\n    partials[\"i4_Lx\"] = i4_mat(Npsi, Nphi, Lx)\n    partials[\"i5_Lx\"] = i5_mat(Npsi, Nphi, Lx)\n\n    partials[\"i9_Lx\"] = i9_mat(Npsi, Nphi, Lx)\n    partials[\"i10_Lx\"] = i10_mat(Npsi, Nphi, Lx)\n    partials[\"i11_Lx\"] = i11_mat(Npsi, Nphi, Lx)\n    partials[\"i12_Lx\"] = i12_mat(Npsi, Nphi, Lx)\n    partials[\"i13_Lx\"] = i13_mat(Npsi, Nphi, Lx)\n\n    # For Ly-based:\n    partials[\"i1_Ly\"] = i1_mat(Npsi, Nphi, Ly)\n    partials[\"i2_Ly\"] = i2_mat(Npsi, Nphi, Ly)\n    partials[\"i3_Ly\"] = i3_mat(Npsi, Nphi, Ly)\n    partials[\"i4_Ly\"] = i4_mat(Npsi, Nphi, Ly)\n    partials[\"i5_Ly\"] = i5_mat(Npsi, Nphi, Ly)\n\n    partials[\"i9_Ly\"] = i9_mat(Npsi, Nphi, Ly)\n    partials[\"i10_Ly\"] = i10_mat(Npsi, Nphi, Ly)\n    partials[\"i11_Ly\"] = i11_mat(Npsi, Nphi, Ly)\n    partials[\"i12_Ly\"] = i12_mat(Npsi, Nphi, Ly)\n    partials[\"i13_Ly\"] = i13_mat(Npsi, Nphi, Ly)\n\n    return partials\n\n\ndef build_s_matrix(Npsi, Nphi, partials, idx_array, factor_mode):\n    \"\"\"\n    Summation of partial integrals in a 3D array with a factor.\n\n    Returns\n    -------\n    s : np.ndarray of shape (Npsi, Nphi, Nphi)\n        The 3D tensor after summation and factor application.\n    \"\"\"\n    s = np.zeros((Npsi, Nphi, Nphi), dtype=float)\n\n    for m in range(Npsi):\n        for n in range(Nphi):\n            n_idx = idx_array[n]\n            for p in range(Nphi):\n                p_idx = idx_array[p]\n\n                val = 0.0\n                for mat in partials:\n                    val += mat[m, n_idx - 1, p_idx - 1]\n\n                # Apply factor\n                if factor_mode == \"n\":\n                    val *= n_idx**2\n                elif factor_mode == \"p\":\n                    val *= p_idx**2\n                elif factor_mode == \"np\":\n                    val *= n_idx * p_idx\n\n                s[m, n, p] = val\n\n    return s\n\n\ndef g1(Npsi, Nphi, S, kx, cache):\n    partials = [\n        cache[\"i1_Lx\"],\n        cache[\"i2_Lx\"],\n        cache[\"i3_Lx\"],\n        cache[\"i4_Lx\"],\n        cache[\"i5_Lx\"],\n    ]\n    s = build_s_matrix(Npsi, Nphi, partials, idx_array=kx, factor_mode=\"n\")\n    s_reshaped = s.reshape((Npsi, Nphi**2), order=\"F\")\n    m_mat = np.repeat(s_reshaped, Npsi, axis=0)\n    return m_mat[:S, :]\n\n\ndef g2(Npsi, Nphi, S, kx, cache):\n    partials = [\n        cache[\"i1_Lx\"],\n        cache[\"i2_Lx\"],\n        cache[\"i3_Lx\"],\n        cache[\"i4_Lx\"],\n        cache[\"i5_Lx\"],\n    ]\n    s = build_s_matrix(Npsi, Nphi, partials, idx_array=kx, factor_mode=\"p\")\n    s_reshaped = s.reshape((Npsi, Nphi**2), order=\"F\")\n    m_mat = np.repeat(s_reshaped, Npsi, axis=0)\n    return m_mat[:S, :]\n\n\ndef g3(Npsi, Nphi, S, ky, cache):\n    partials = [\n        cache[\"i1_Ly\"],\n        cache[\"i2_Ly\"],\n        cache[\"i3_Ly\"],\n        cache[\"i4_Ly\"],\n        cache[\"i5_Ly\"],\n    ]\n    s = build_s_matrix(Npsi, Nphi, partials, idx_array=ky, factor_mode=\"n\")\n    s_reshaped = s.reshape((Npsi, Nphi**2), order=\"F\")\n    m_mat = np.tile(s_reshaped, (Npsi, 1))\n    return m_mat[:S, :]\n\n\ndef g4(Npsi, Nphi, S, ky, cache):\n    partials = [\n        cache[\"i1_Ly\"],\n        cache[\"i2_Ly\"],\n        cache[\"i3_Ly\"],\n        cache[\"i4_Ly\"],\n        cache[\"i5_Ly\"],\n    ]\n    s = build_s_matrix(Npsi, Nphi, partials, idx_array=ky, factor_mode=\"p\")\n    s_reshaped = s.reshape((Npsi, Nphi**2), order=\"F\")\n    m_mat = np.tile(s_reshaped, (Npsi, 1))\n    return m_mat[:S, :]\n\n\ndef g5(Npsi, Nphi, S, kx, cache):\n    partials = [\n        cache[\"i9_Lx\"],\n        cache[\"i10_Lx\"],\n        cache[\"i11_Lx\"],\n        cache[\"i12_Lx\"],\n        cache[\"i13_Lx\"],\n    ]\n    s = build_s_matrix(Npsi, Nphi, partials, idx_array=kx, factor_mode=\"np\")\n    s_reshaped = s.reshape((Npsi, Nphi**2), order=\"F\")\n    m_mat = np.repeat(s_reshaped, Npsi, axis=0)\n    return m_mat[:S, :]\n\n\ndef g6(Npsi, Nphi, S, ky, cache):\n    partials = [\n        cache[\"i9_Ly\"],\n        cache[\"i10_Ly\"],\n        cache[\"i11_Ly\"],\n        cache[\"i12_Ly\"],\n        cache[\"i13_Ly\"],\n    ]\n    s = build_s_matrix(Npsi, Nphi, partials, idx_array=ky, factor_mode=\"np\")\n    s_reshaped = s.reshape((Npsi, Nphi**2), order=\"F\")\n    m_mat = np.tile(s_reshaped, (Npsi, 1))\n    return m_mat[:S, :]\n:::\n::: {#cell-13 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef H_tensor_rectangular(\n    coeff0,\n    coeff1,\n    coeff2,\n    Nphi,\n    Npsi,\n    Lx,\n    Ly,\n    kx,\n    ky,\n):\n    \"\"\"\n    Compute the H tensor for rectangular plates.\n    \"\"\"\n    S = coeff1.shape[1]  # Number of modes\n\n    # Initialize H tensors\n    H0 = np.zeros((S, Nphi * Nphi))\n    H1 = np.zeros((S, Nphi * Nphi))\n    H2 = np.zeros((S, Nphi * Nphi))\n\n    partials = compute_partial_integrals(Npsi, Nphi, Lx, Ly)\n\n    # Compute integral components\n    m1 = g1(Npsi, Nphi, S, kx, partials)\n    m2 = g2(Npsi, Nphi, S, kx, partials)\n\n    m3 = g3(Npsi, Nphi, S, ky, partials)\n    m4 = g4(Npsi, Nphi, S, ky, partials)\n\n    m5 = g5(Npsi, Nphi, S, kx, partials)\n    m6 = g6(Npsi, Nphi, S, ky, partials)\n\n    # Compute H tensor\n    for n in range(S):\n        f0 = coeff0[:, n].T @ (m1 * m4 + m2 * m3 - 2 * m5 * m6)\n        f1 = coeff1[:, n].T @ (m1 * m4 + m2 * m3 - 2 * m5 * m6)\n        f2 = coeff2[:, n].T @ (m1 * m4 + m2 * m3 - 2 * m5 * m6)\n\n        H0[n, :] = f0\n        H1[n, :] = f1\n        H2[n, :] = f2\n\n    # Normalize with constants\n    const_factor = 4 * np.pi**4 / (Lx**3 * Ly**3)\n    H0 *= const_factor\n    H1 *= const_factor\n    H2 *= const_factor\n\n    # Zero small values\n    threshold = 1e-8\n    H0[np.abs(H0 / np.max(np.abs(H0))) &lt; threshold] = 0\n    H1[np.abs(H1 / np.max(np.abs(H1))) &lt; threshold] = 0\n    H2[np.abs(H2 / np.max(np.abs(H2))) &lt; threshold] = 0\n    return H0, H1, H2\n:::\n::: {#cell-14 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef compute_coupling_matrix(\n    n_psi,\n    n_phi,\n    lx,\n    ly,\n    kx_indices,\n    ky_indices,\n):\n    K, M = assemble_K_and_M(n_psi, lx, ly)\n\n    # this will give different results than in MATLAB\n    vals, vecs = eig(K, M)\n\n    coeff0, coeff1, coeff2 = airy_stress_coefficients(n_psi, vals, vecs)\n    H0, H1, H2 = H_tensor_rectangular(\n        coeff0=coeff0,\n        coeff1=coeff1,\n        coeff2=coeff2,\n        Npsi=n_psi,\n        Nphi=n_phi,\n        Lx=lx,\n        Ly=ly,\n        kx=kx_indices,\n        ky=ky_indices,\n    )\n\n    H0 = H0[:n_psi, : n_phi * n_phi]\n    H1 = H1[:n_psi, : n_phi * n_phi]\n    H2 = H2[:n_psi, : n_phi * n_phi]\n\n    H0 = H0.reshape((n_psi, n_phi, n_phi))\n    H1 = H1.reshape((n_psi, n_phi, n_phi))\n    H2 = H2.reshape((n_psi, n_phi, n_phi))\n    return H0, H1, H2\n:::",
    "crumbs": [
      "Coupling functions"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "vkplatejax",
    "section": "",
    "text": "Fast and differentiable simulation of the Von Karman plate model using JAX.\nThis code is based on the matlab implementation of the Von Karman plate model found here.\nTo run the time integration of the Von Karman plate model using JAX, the coupling coefficients and the eigenmodes of the plate are precomputed using the matlab implementation.\nExample matrices can be downloaded with the following command:",
    "crumbs": [
      "vkplatejax"
    ]
  },
  {
    "objectID": "index.html#installation-for-development",
    "href": "index.html#installation-for-development",
    "title": "vkplatejax",
    "section": "Installation for Development",
    "text": "Installation for Development\nIt is strongly recommended to use the uv package manager to install the environment and dependencies.\nuv sync --all-extras\notherwise you can create a virtual environment and install the dependencies manually:\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e .",
    "crumbs": [
      "vkplatejax"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "vkplatejax",
    "section": "How to use",
    "text": "How to use\nOnce everything is installed, you can run the vkplate_opt.ipynb notebook.",
    "crumbs": [
      "vkplatejax"
    ]
  },
  {
    "objectID": "ftm.html",
    "href": "ftm.html",
    "title": "Funtional Transformation Method Utilities",
    "section": "",
    "text": "This notebook contains a set of utility functions for the functional transformation method.\n::: {#cell-4 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’ 6=‘i’}\nfrom dataclasses import asdict, dataclass\n\nimport numpy as np\nfrom jax import numpy as jnp\nfrom opt_einsum import contract as einsum\nfrom scipy.integrate import simpson, trapezoid\nfrom scipy.signal import cont2discrete\nfrom scipy.special import jn_zeros, jv\nfrom tabulate import tabulate\n:::\n::: {#cell-5 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@dataclass\nclass PhysicalParameters:\n    def asdict(self):\n        return asdict(self)\n\n    def tabulate(self) -&gt; str:\n        param_symbols: dict[str, str] = {\n            \"A\": \"$A$\",\n            \"I\": \"$I$\",\n            \"rho\": \"$\\\\rho$\",\n            \"E\": \"$E$\",\n            \"d1\": \"$d_1$\",\n            \"d3\": \"$d_3$\",\n            \"Ts0\": \"$T_{s0}$\",\n            \"length\": \"$\\\\ell$\",\n            \"h\": \"$h$\",\n            \"l1\": \"$l_1$\",\n            \"l2\": \"$l_2$\",\n            \"nu\": \"$\\\\nu$\",\n            \"d0\": \"$d_0$\",\n            \"d2\": \"$d_2$\",\n            \"Tm\": \"$T_m$\",\n            \"f_1\": \"$f_1$\",\n            \"r0\": \"$r_0$\",\n            \"f0\": \"$f_0$\",\n        }\n\n        param_units: dict[str, str] = {\n            \"A\": \"$m^2$\",\n            \"I\": \"$m^4$\",\n            \"rho\": \"$kg/m^3$\",\n            \"E\": \"$Pa$\",\n            \"d1\": \"$kg/(ms)$\",\n            \"d3\": \"$kg\\\\cdot m/s$\",\n            \"Ts0\": \"$N$\",\n            \"length\": \"$m$\",\n            \"h\": \"$m$\",\n            \"l1\": \"$m$\",\n            \"l2\": \"$m$\",\n            \"nu\": \"dimensionless\",\n            \"d0\": \"$kg/(m^2 s)$\",\n            \"d2\": \"$kg/s$\",\n            \"Tm\": \"$N/m$\",\n            \"f_1\": \"$Hz$\",\n            \"r0\": \"$m$\",\n            \"f0\": \"$Hz$\",\n        }\n\n        table_data = []\n\n        for field_name, field_value in self.asdict().items():\n            if field_name in param_symbols:\n                symbol = param_symbols[field_name]\n                unit = param_units.get(field_name, \"\")\n                table_data.append([symbol, field_value, unit])\n\n        return tabulate(\n            table_data,\n            headers=[\"Parameter\", \"Value\", \"Units\"],\n            tablefmt=\"github\",\n        )\n\n\n@dataclass\nclass StringParameters(PhysicalParameters):\n    \"\"\"\n    Dataclass to store the parameters of the string. Based on a nylon B string\n    of the guitar. From Table 4.1 of Digital Sound Synthesis using the FTM.\n    Moment of intertia and damping are changed however.\n    \"\"\"\n\n    # fmt: off\n    A: float = 0.5188e-6        # m**2    Cross section area\n    I: float = 0.141e-12        # m**4    Moment of intertia\n    rho: float = 1140           # kg/m**3 Density\n    E: int = 5.4e9              # Pa      Young's modulus\n    d1: float= 8e-5             # kg/(ms) Frequency independent loss\n    d3: float = 1.4e-5          # kg m/s  Frequency dependent loss\n    Ts0: float = 60.97          # N       Tension\n    length: float = 0.65        # m       Length of the string\n    # fmt: on\n\n    @staticmethod\n    def piano_string():\n        \"\"\"\n        From Table 5.1 of Digital Sound Synthesis using the FTM\n        \"\"\"\n        return StringParameters(\n            A=1.54e-6,\n            I=4.12e-12,\n            rho=57.0e3,\n            E=19.5e9,\n            d1=3e-3,\n            d3=2e-5,\n            Ts0=2104,\n            length=1.08,\n        )\n\n    @staticmethod\n    def bass_string():\n        \"\"\"\n        From Table 5.1 of Digital Sound Synthesis using the FTM\n        \"\"\"\n        return StringParameters(\n            A=2.4e-6,\n            I=0.916e-12,\n            rho=6300,\n            E=5e9,\n            d1=6e-3,\n            d3=1e-3,\n            Ts0=114,\n            length=1.05,\n        )\n\n    @staticmethod\n    def guitar_string_D():\n        \"\"\"\n        From Table 8.2 of Simulation of Distributed Parameter Systems by Transfer Function Models\n        \"\"\"\n        return StringParameters(\n            A=7.96e-7,\n            I=0.171e-12,\n            rho=1140,\n            E=5.4e9,\n            d1=8e-5,\n            d3=1.4e-5,\n            Ts0=13.35,\n            length=0.65,\n        )\n\n    @staticmethod\n    def guitar_string_B_schafer():\n        \"\"\"\n        From A String In a Room: Mixed-Dimensional Transfer Function Models for Sound Synthesis\n        \"\"\"\n        return StringParameters(\n            A=0.5e-6,\n            I=0.17e-12,\n            rho=1140,\n            E=5.4e9,\n            d1=8e-5,\n            d3=1.4e-5,\n            Ts0=60.97,\n            length=0.65,\n        )\n\n    @property\n    def density(self):\n        \"\"\"\n        Area density of the string\n        \"\"\"\n        return self.rho * self.A\n\n    @property\n    def bending_stiffness(self):\n        return self.E * self.I\n\n\n@dataclass\nclass PlateParameters(PhysicalParameters):\n    \"\"\"\n    From Digital sound synthesis of string instruments with the functional transformation method Table 5.2.\n    \"\"\"\n\n    # fmt: off\n    h: float = 1.2e-3           # m           Thickness\n    l1: float = 1.08            # m           Width\n    l2: float = 1.08            # m           Height\n    I: float = 144e-12          # m**4        Moment of intertia\n    rho: float = 7.8e3          # kg/m**3     Density\n    E: int = 220e9              # Pa          Young's modulus\n    nu: float = 0.29            #             Poisson's ratio\n    d1: float= 3.2e-2           # kg/(m**2 s) Frequency independent loss\n    d3: float = 1.3e-3          # kg/s        Frequency dependent loss\n    Ts0: float = 2010            # N/m         Surface Tension\n    f_1: float = 10.27          # Hz          Fundamental frequency\n    # fmt: on\n\n    @property\n    def density(self):\n        \"\"\"\n        Surface density of the string\n        \"\"\"\n        return self.rho * self.h\n\n    @property\n    def bending_stiffness(self):\n        return self.E * self.h**3 / (12 * (1 - self.nu**2))\n\n\n@dataclass\nclass CircularDrumHeadParameters(PhysicalParameters):\n    \"\"\"\n    Kettle drum head, from Digital sound synthesis of string instruments with the functional transformation method Table 5.2.\n    \"\"\"\n\n    # fmt: off\n    h: float = 1.9e-4           # m           Thickness\n    r0: float = 0.328           # m           Radius\n    I: float = 0.57e-12         # m**4        Moment of intertia\n    rho: float = 1.38e3         # kg/m**3     Density\n    E: int = 3.5e9              # Pa          Young's modulus\n    nu: float = 0.35            #             Poisson's ratio\n    d1: float= 0.14             # kg/(m**2 s) Frequency independent loss\n    d3: float = 0.32            # kg/s        Frequency dependent loss\n    Ts0: float = 3990            # N/m         Surface Tension\n    f0: float = 143.95          # Hz          Fundamental frequency\n    # fmt: on\n\n    @property\n    def density(self):\n        return self.rho * self.h\n\n    @property\n    def bending_stiffness(self):\n        return self.E * self.h**3 / (12 * (1 - self.nu**2))\n\n    @staticmethod\n    def avanzini():\n        \"\"\"\n        From Section VI of \"A Modular Physically Based Approach to the Sound Synthesis of Membrane Percussion Instruments\"\n        \"\"\"\n        return CircularDrumHeadParameters(\n            h=2e-4,  # 0.2mmm\n            r0=0.20,  # 20cm\n            rho=1350.0,  # 0.27 / h\n            E=3.5e9,  # 3.5e9\n            nu=0.2,\n            d0=1.25,\n            d2=5e-4,\n            Tm=1500,\n        )\n:::\n::: {#cell-6 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef string_eigenvalues(n_modes: int, length: float):\n    mu = jnp.arange(1, n_modes + 1)\n    return (mu * jnp.pi / length) ** 2\n\n\ndef string_eigenvalues_sqrt(\n    n_max_modes: int,\n    length: float,\n):\n    \"\"\"\n    Compute the eigenvalues of the string.\n    The eigenvalues of the string are given by:\n\n    $$\n    \\lambda_{\\mu} = \\left(\\frac{\\mu \\pi}{L}\\right)\n    $$\n\n    where $\\mu$ is the mode number and $L$ is the length of the string.\n    \"\"\"\n\n    mu = np.arange(1, n_max_modes + 1)\n    return np.pi * mu / length\n\n\ndef string_eigenfunctions(\n    wavenumbers: np.ndarray,\n    grid: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the modes of the string.\n    The modes of the string are given by:\n\n    $$\n    K = \\sin(\\pi x k)\n    $$\n\n    where $k$ is the wavenumber and $x$ is the grid positions.\n\n    Parameters\n    ----------\n    wavenumbers : np.ndarray\n        The wavenumbers of the string.\n    grid : np.ndarray\n        The grid positions of the string where to compute the modes.\n\n    Returns\n    -------\n    np.ndarray\n        The modes of the string at the given grid positions.\n    \"\"\"\n    return np.sin(np.outer(wavenumbers, grid))\n\n\ndef othonormal_eigenfunctions(\n    eigenfunctions: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    Normalize the eigenfunctions of the string.\n    The orthonormal eigenfunctions of the string are given by:\n\n    $$\n    \\sqrt{\\frac{2}{N}} \\sin(\\pi x k)\n    $$\n\n    where $k$ is the wavenumber and $x$ is the grid positions.\n\n    Parameters\n    ----------\n    eigenfunctions : np.ndarray\n        The eigenfunctions of the string.\n\n    Returns\n    -------\n    np.ndarray\n        The orthonormal eigenfunctions of the string.\n    \"\"\"\n    return np.sqrt(2 / eigenfunctions.shape[1]) * eigenfunctions\n:::\n::: {#cell-7 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef plate_wavenumbers(\n    n_max_modes_x: int,\n    n_max_modes_y: int,\n    l1: float,\n    l2: float,\n) -&gt; tuple[jnp.ndarray, jnp.ndarray]:\n    \"\"\"\n    Compute the wavenumbers of the plate.\n\n    Parameters:\n    ----------\n    n_max_modes_x: int\n        The number of modes in the x direction.\n    n_max_modes_y: int\n        The number of modes in the y direction.\n    l1: float\n        The width of the plate.\n    l2: float\n        The height of the plate.\n\n    Returns:\n    -------\n    wn_x: np.ndarray\n        The wavenumbers in the x direction.\n    wn_y: np.ndarray\n        The wavenumbers in the y direction\n    \"\"\"\n\n    mu_x = jnp.arange(1, n_max_modes_x + 1)\n    mu_y = jnp.arange(1, n_max_modes_y + 1)\n    wavenumbers_x = mu_x * jnp.pi / l1\n    wavenumbers_y = mu_y * jnp.pi / l2\n    return wavenumbers_x, wavenumbers_y\n\n\ndef plate_eigenvalues(\n    wavenumbers_x: np.ndarray,  # (n_max_modes_x,)\n    wavenumbers_y: np.ndarray,  # (n_max_modes_y,)\n    squared: bool = False,\n):\n    \"\"\"\n    Compute the eigenvalues of the plate.\n    The eigenvalues of the plate are given by:\n\n    $$\n    \\lambda_{\\mu, \\nu} = \\pi \\sqrt{\\left(\\frac{\\mu}{L_1}\\right)^2 + \\left(\\frac{\\nu}{L_2}\\right)^2}\n    $$\n\n    where $\\mu$ and $\\nu$ are the mode numbers and $L_1$ and $L_2$ are the width and height of the plate.\n    \"\"\"\n    wn_x, wn_y = jnp.meshgrid(wavenumbers_x, wavenumbers_y)\n\n    # this is important because we can't simply take the square root of the sum of squares\n    # wn_x**4 + wn_y**4 != (wn_x**2 + wn_y**2) ** 2\n    return wn_x**4 + wn_y**4 if squared else wn_x**2 + wn_y**2\n\n\ndef plate_eigenfunctions(\n    wavenumbers_x: np.ndarray,  # (n_max_modes_x,)\n    wavenumbers_y: np.ndarray,  # (n_max_modes_y,)\n    x: np.ndarray,  # (n_gridpoints_x,)\n    y: np.ndarray,  # (n_gridpoints_y,)\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the modes of the plate.\n    The modes of the plate are given by:\n\n    $$\n    K = \\sin(\\pi x k) \\sin(\\pi y k)\n    $$\n\n    where $k$ is the wavenumber and $x$ and $y$ are the grid positions.\n    \"\"\"\n\n    # Compute the sine values using broadcasting\n    sin_wx_grid_x = np.sin(wavenumbers_x[:, None] * x[None, :])\n    sin_wy_grid_y = np.sin(wavenumbers_y[:, None] * y[None, :])\n\n    # Use einsum to compute the outer product and obtain the modes\n    return einsum(\"m x, n y -&gt; m n x y\", sin_wx_grid_x, sin_wy_grid_y)\n:::\n\nimport matplotlib.pyplot as plt\n\n::: {#cell-9 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef drumhead_wavenumbers(\n    n_max_modes: int,\n    m_max_modes: int,\n    radius: float,\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the wavenumbers of the drumhead.\n\n    Parameters:\n    ----------\n    n_max_modes: int\n        The number of angular modes.\n    m_max_modes: int\n        The number of radial modes.\n    radius: float\n        The radius of the drumhead.\n\n    Returns:\n    -------\n    wavenumbers: np.ndarray\n        The wavenumbers for the drumhead.\n    \"\"\"\n    # Bessel function roots for different orders (n) and radial modes (m)\n    wavenumbers = np.zeros((n_max_modes, m_max_modes))\n    for n in range(n_max_modes):\n        bessel_roots = jn_zeros(n, m_max_modes)\n        wavenumbers[n, :] = bessel_roots / radius\n    return wavenumbers\n\n\ndef drumhead_eigenvalues(\n    wavenumbers: np.ndarray,  # (n_max_modes, m_max_modes)\n):\n    \"\"\"\n    Compute the eigenvalues of the drumhead.\n    The eigenvalues of the drumhead are given by the square of the wavenumbers.\n\n    Parameters:\n    ----------\n    wavenumbers: np.ndarray\n        The wavenumbers for the drumhead.\n    squared: bool\n        If True, return the squared eigenvalues.\n\n    Returns:\n    -------\n    eigenvalues: np.ndarray\n        The eigenvalues of the drumhead.\n    \"\"\"\n    return wavenumbers**2\n\n\ndef drumhead_eigenfunctions(\n    wavenumbers: np.ndarray,  # (n_max_modes, m_max_modes)\n    r: np.ndarray,  # (n_gridpoints_r)\n    theta: np.ndarray,  # (n_gridpoints_theta)\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the modes of the drumhead.\n    The modes of the drumhead are given by the Bessel function times the sine/cosine of the angle.\n\n    Parameters:\n    ----------\n    wavenumbers: np.ndarray\n        The wavenumbers for the drumhead.\n    r: np.ndarray\n        Radial grid points.\n    theta: np.ndarray\n        Angular grid points.\n\n    Returns:\n    -------\n    modes: np.ndarray\n        The eigenfunctions for the drumhead.\n    \"\"\"\n    n_max_modes, m_max_modes = wavenumbers.shape\n    n_gridpoints_r = len(r)\n    n_gridpoints_theta = len(theta)\n\n    # Initialize the modes array\n    modes = np.zeros((n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta))\n    inverse_modes = np.zeros_like(modes)\n\n    squared_norms = np.zeros((n_max_modes, m_max_modes))\n\n    r_grid, theta_grid = np.meshgrid(r, theta, indexing=\"ij\")\n\n    # Compute the modes\n    for n in range(n_max_modes):\n        for m in range(m_max_modes):\n            modes[n, m] = np.cos(n * theta_grid) * jv(n, wavenumbers[n, m] * r_grid)\n\n            # calculate the squared norm\n            integrand = modes[n, m] ** 2 * r_grid\n            integral_theta = simpson(integrand, x=theta, axis=1)\n            squared_norms[n, m] = simpson(integral_theta, x=r)\n\n            # get the normalised modes\n            inverse_modes[n, m] = modes[n, m] / squared_norms[n, m]\n\n    return modes, inverse_modes, squared_norms\n:::\n::: {#cell-10 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef dblintegral(integrand, x, y, method=\"simpson\"):\n    \"\"\"\n    Compute the double integral of a function K over the domain x and y.\n    \"\"\"\n\n    if method == \"simpson\":\n        integral_y = simpson(integrand, x=y, axis=1)\n        return simpson(integral_y, x=x)\n    elif method == \"trapezoid\":\n        integral_y = trapezoid(integrand, x=y, axis=1)\n        return trapezoid(integral_y, x=x)\n    else:\n        raise ValueError(\"Method not supported\")\n:::\n\n# Example usage\nn_max_modes = 25\nm_max_modes = 25\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert K_inv.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\nassert K_fwd.shape == (\n    n_max_modes,\n    m_max_modes,\n    n_gridpoints_r,\n    n_gridpoints_theta,\n)\n\n\\[\nK_{n,m}(r, \\varphi) = \\cos (n \\varphi) J_n\\left(\\mu_{n, m} \\frac{r}{R}\\right)\n\\]\nwhere \\(J_n\\) is the Bessel function of the first kind of order \\(n\\), and \\(\\mu_{n, m}\\) is the \\(m\\)-th root of the \\(n\\)-th order Bessel function of the first kind.\n\nn_max_modes_x = 6\nn_max_modes_y = 6\nn_gridpoints_x = 20\nn_gridpoints_y = 20\nlength_x = 1.08\nlength_y = 1.08\ngrid_x = np.linspace(0, length_x, n_gridpoints_x)\ngrid_y = np.linspace(0, length_y, n_gridpoints_y)\n\n# slow version\n# Define the range for n and m\nn_values = np.arange(1, n_max_modes_x + 1)\nm_values = np.arange(1, n_max_modes_y + 1)\n\n# Define the range for x and y\nx_values = np.linspace(0, length_x, n_gridpoints_x)\ny_values = np.linspace(0, length_y, n_gridpoints_y)\n\n# Initialize the 4D array to store the results\nK = np.zeros((len(n_values), len(m_values), len(x_values), len(y_values)))\nLambda = np.zeros((len(n_values), len(m_values)))\n# Compute the values\nfor i, n in enumerate(n_values):\n    for j, m in enumerate(m_values):\n        Lambda[i, j] = np.pi**2 * ((n / length_x) ** 2 + (m / length_y) ** 2)\n        for k, x in enumerate(x_values):\n            for l, y in enumerate(y_values):\n                K[i, j, k, l] = np.sin(n * np.pi * x / length_x) * np.sin(\n                    m * np.pi * y / length_y\n                )\n\n::: {#cell-14 .cell 0=‘t’ 1=‘e’ 2=‘s’ 3=‘t’}\nwnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, length_x, length_y)\nassert np.allclose(plate_eigenfunctions(wnx, wny, grid_x, grid_y), K)\nassert np.allclose(plate_eigenvalues(wnx, wny), Lambda)\n:::\n::: {#cell-15 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef forward_STL(\n    K: np.ndarray,  # (n_modes, n_gridpoints)\n    u: np.ndarray,  # (n_gridpoints, n_samples) or (n_gridpoints,)\n    dx: float,  # grid spacing\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the forward STL transform. The integration is done using the trapezoidal rule.\n\n    Parameters\n    ----------\n    K: np.ndarray\n        The sampled eigenfunctions of the string. Shape (n_modes, n_gridpoints)\n    u: np.ndarray\n        The input signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n    dx: float\n        The grid spacing of the sampled string.\n\n    Returns\n    -------\n    np.ndarray\n        The transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n    \"\"\"\n    if u.ndim == 1:\n        u = u[:, None]\n    transformed_signal = dx * einsum(\"m n, n s -&gt; m s\", K, u)\n    return transformed_signal if u.shape[1] &gt; 1 else transformed_signal[:, 0]\n\n\ndef inverse_STL(\n    K: np.ndarray,  # (n_modes, n_gridpoints)\n    u_bar: np.ndarray,  # (n_modes, n_samples) or (n_modes,)\n    length: float,  # length of the string\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n    Parameters:\n    -----------\n\n    K: np.ndarray\n        The sampled eigenfunctions of the string. Shape (n_modes, n_gridpoints)\n    u_bar: np.ndarray\n        The transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n    length: float\n        The length of the string.\n\n    Returns:\n    --------\n    np.ndarray\n        The reconstructed signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n    \"\"\"\n    if u_bar.ndim == 1:\n        u_bar = u_bar[:, None]  # Convert to (n_modes, 1) if input is (n_modes,)\n\n    N = length / 2.0\n    reconstructed_signal = einsum(\"m n, m s -&gt; n s\", K, u_bar) / N\n    return reconstructed_signal if u_bar.shape[1] &gt; 1 else reconstructed_signal[:, 0]\n:::\n::: {#cell-16 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef forward_STL_2d(\n    K: np.ndarray,  # (n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n    u: np.ndarray,  # (n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n    x: float,  # grid spacing\n    y: float,  # grid spacing\n    use_simpson: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the forward STL transform. The integration is done using the trapezoidal rule.\n\n    Parameters\n    ----------\n    K : np.ndarray\n        The sampled eigenfunctions of the string. Shape (n_modes, n_gridpoints)\n    u : np.ndarray\n        The input signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n    dx : float\n        The grid spacing of the sampled string.\n\n    Returns\n    -------\n    np.ndarray\n        The transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n    \"\"\"\n    if u.ndim == 2:\n        u = u[..., None]\n\n    if use_simpson:\n        n_modes_x, n_modes_y, _, _ = K.shape\n        _, _, n_samples = u.shape\n\n        # print(u.shape)\n        transformed_signal = np.zeros((n_modes_x, n_modes_y, n_samples))\n\n        for mode_x in range(n_modes_x):\n            for mode_y in range(n_modes_y):\n                for sample in range(n_samples):\n                    # Perform 2D Simpson's integration\n                    uu = K[mode_x, mode_y] * u[:, :, sample]\n\n                    # integral_x = simpson([simpson(uu_y, dx=dy) for uu_y in uu], dx=dx)\n                    transformed_signal[mode_x, mode_y, sample] = dblintegral(\n                        uu,\n                        x,\n                        y,\n                        method=\"simpson\",\n                    )\n    # else use trapezoidal rule\n    else:\n        dx = x[1] - x[0]\n        dy = y[1] - y[0]\n        transformed_signal = dx * dy * einsum(\"m n x y, x y s -&gt; m n s\", K, u)\n\n    return (\n        transformed_signal.squeeze()\n        if transformed_signal.shape[-1] == 1\n        else transformed_signal\n    )\n\n\ndef inverse_STL_2d(\n    K: np.ndarray,  # (n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n    u_bar: np.ndarray,  # (n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n    l1: float,  # length in x\n    l2: float,  # length in y\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n    Parameters\n    ----------\n    K : np.ndarray\n        The sampled eigenfunctions of the string. Shape (n_modes, n_gridpoints)\n    u_bar : np.ndarray\n        The transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n    length : float\n        The length of the string.\n\n    Returns\n    -------\n    np.ndarray\n        The reconstructed signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n    \"\"\"\n    if u_bar.ndim == 2:\n        u_bar = u_bar[\n            ..., None\n        ]  # Convert to (n_modes_x, n_modes_y, 1) if input is (n_modes_x, n_modes_y)\n\n    N = 0.25 * (l1 * l2)\n    reconstructed_signal = einsum(\"m n x y, m n s -&gt; x y s\", K, u_bar) / N\n    return (\n        reconstructed_signal.squeeze() if u_bar.shape[-1] == 1 else reconstructed_signal\n    )\n:::\n::: {#cell-17 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef evaluate_rectangular_eigenfunctions(\n    mn_indices: np.ndarray,  # (n_modes, 2) selected mode indices\n    position: np.ndarray,  # (2,) position to evaluate the eigenfunctions\n    params: PlateParameters,\n) -&gt; np.ndarray:  # (n_modes,) mode gains of selected modes at the given position\n    return np.sin(mn_indices[:, 0] * np.pi * position[0] / params.l1) * np.sin(\n        mn_indices[:, 1] * np.pi * position[1] / params.l2\n    )\n:::\n\nlength_x = 1.08\nlength_y = 0.8\nn_max_modes_x = 25\nn_max_modes_y = 25\nn_gridpoints_x = 100\nn_gridpoints_y = 100\n\nx = np.linspace(0, length_x, n_gridpoints_x)\ny = np.linspace(0, length_y, n_gridpoints_y)\n\nwnx, wny = plate_wavenumbers(\n    n_max_modes_x,\n    n_max_modes_y,\n    length_x,\n    length_y,\n)\nK = plate_eigenfunctions(wnx, wny, x, y)\n\ng = 0.5 * K[2, 2] + 0.5 * K[3, 3]\n\nbar_g = forward_STL_2d(K, g, x, y, use_simpson=True)\ng_reconstructed = inverse_STL_2d(K, bar_g, length_x, length_y)\n\nassert np.allclose(g, g_reconstructed, atol=1e-2)\n\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\n\nax[0].imshow(g, origin=\"lower\", aspect=\"auto\")\nax[0].set_title(\"Original excitation\")\nax[1].imshow(g_reconstructed, origin=\"lower\", aspect=\"auto\")\nax[1].set_title(\"Reconstructed excitation\")\n\n::: {#cell-19 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef forward_STL_drumhead(\n    K: np.ndarray,  # (n_modes_r, n_modes_theta, n_gridpoints_r, n_gridpoints_theta)\n    u: np.ndarray,  # (n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x, n_gridpoints_y)\n    r: np.ndarray,  # radial grid\n    theta: np.ndarray,  # angular grid\n    use_simpson: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the forward STL transform. The integration is done using the trapezoidal rule or Simpson's rule.\n\n    Parameters:\n    -----------\n\n    K: np.ndarray\n        The sampled eigenfunctions of the string. Shape (n_modes_r, n_modes_theta, n_gridpoints_r, n_gridpoints_theta)\n    u: np.ndarray\n        The input signal. Shape (n_gridpoints_r, n_gridpoints_theta, n_samples) or (n_gridpoints_r, n_gridpoints_theta)\n    dr: float\n        The grid spacing of the sampled membrane.\n    dtheta: float\n        The grid spacing of the sampled membrane.\n\n    Returns:\n    --------\n    np.ndarray\n        The transformed signal. Shape (n_modes_r, n_modes_theta, n_samples) or (n_modes_r, n_modes_theta)\n    \"\"\"\n    if u.ndim == 2:\n        u = u[..., None]\n\n    r_grid, _ = np.meshgrid(r, theta, indexing=\"ij\")\n\n    if use_simpson:\n        max_n, max_m, _, _ = K.shape\n        _, _, n_samples = u.shape\n\n        transformed_signal = np.zeros((max_n, max_m, n_samples))\n\n        for n in range(max_n):\n            for m in range(max_m):\n                for sample in range(n_samples):\n                    integrand = (\n                        u[..., sample] * K[n, m] * r_grid\n                    )  # notice the r_grid (Jacobian determinant)\n                    transformed_signal[n, m] = dblintegral(\n                        integrand, x=r, y=theta, method=\"trapezoid\"\n                    )\n\n    else:\n        # integrand has shape (n_modes_r, n_modes_theta, n_gridpoints_r, n_gridpoints_theta)\n        integrand = u[..., None].transpose(2, 3, 0, 1) * K * r_grid\n\n        integral_y = trapezoid(integrand, x=theta, axis=-1)\n        transformed_signal = trapezoid(integral_y, x=r, axis=-1)\n\n    return (\n        transformed_signal.squeeze()\n        if transformed_signal.shape[-1] == 1\n        else transformed_signal\n    )\n\n\ndef inverse_STL_drumhead(\n    K_inv: np.ndarray,  # (n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)\n    u_bar: np.ndarray,  # (n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the inverse STL transform using the formula of Rabenstein et al. (2000).\n\n    Parameters:\n    -----------\n\n    K: np.ndarray\n        The sampled eigenfunctions of the string. Shape (n_modes, n_gridpoints)\n    u_bar: np.ndarray\n        The transformed signal. Shape (n_modes, n_samples) or (n_modes,)\n    length: float\n        The length of the string.\n\n    Returns:\n    --------\n    np.ndarray\n        The reconstructed signal. Shape (n_gridpoints, n_samples) or (n_gridpoints,)\n    \"\"\"\n    if u_bar.ndim == 2:\n        u_bar = u_bar[\n            ..., None\n        ]  # Convert to (n_modes_x, n_modes_y, 1) if input is (n_modes_x, n_modes_y)\n\n    reconstructed_signal = einsum(\"n m x y, n m s -&gt; x y s\", K_inv, u_bar)\n    return (\n        reconstructed_signal.squeeze() if u_bar.shape[-1] == 1 else reconstructed_signal\n    )\n:::\n\n# Example usage\nn_max_modes = 10\nm_max_modes = 10\nradius = 1.0\nn_gridpoints_r = 100\nn_gridpoints_theta = 100\n\nwavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)\neigenvalues = drumhead_eigenvalues(wavenumbers)\nr = np.linspace(0, radius, n_gridpoints_r)\ntheta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)\nK_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)\n\nassert np.allclose(\n    K_fwd.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\nassert np.allclose(\n    K_inv.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)\n)  # Should be (10, 10, 100, 100)\n\n# Create an example g array to test the transforms\ng = K_fwd[3, 3]\n\nbar_g = forward_STL_drumhead(K_fwd, g, r, theta, use_simpson=False)\ng_reconstructed = inverse_STL_drumhead(K_inv, bar_g)\n\n# Verify if g can be reconstructed\nassert np.allclose(g, g_reconstructed, atol=1e-2)\nprint(g.min(), g.max())\nprint(g_reconstructed.min(), g_reconstructed.max())\n\n# Plot using pcolormesh\nfig, ax = plt.subplots(\n    1,\n    2,\n    subplot_kw={\"projection\": \"polar\"},\n    figsize=(10, 5),\n)\nc = ax[0].pcolormesh(theta, r, g, shading=\"auto\", cmap=\"viridis\")\nc = ax[1].pcolormesh(theta, r, g_reconstructed, shading=\"auto\", cmap=\"viridis\")\n\n::: {#cell-21 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef damping_term(\n    params: PhysicalParameters,\n    lambda_mu: jnp.ndarray,\n):\n    return (params.d1 + params.d3 * lambda_mu) / params.density\n\n\ndef damping_term_simple(\n    lambda_mu: jnp.ndarray,\n    factor: float = 1e-3,\n):\n    return 0.5 * factor * lambda_mu\n\n\ndef stiffness_term(\n    params: PhysicalParameters,\n    lambda_mu: jnp.ndarray,\n):\n    omega_mu = params.bending_stiffness * lambda_mu**2 + params.Ts0 * lambda_mu\n    omega_mu = omega_mu / params.density\n    return omega_mu\n\nNameError: name 'PhysicalParameters' is not defined\n\n:::\n::: {#cell-22 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef eigenvalues_from_pde(\n    pars: PhysicalParameters,\n    lambda_mu: jnp.ndarray,\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Compute the positive imaginary side of the eigenvalues of the\n    continuous-time system from the PDE parameters.\n\n    Parameters\n    ----------\n    pars : PhysicalParameters\n        The physical parameters of the system.\n    lambda_mu : jnp.ndarray\n        The eigenvalues of the decompostion of the Laplacian operator.\n\n    Returns\n    -------\n    np.ndarray\n        The eigenvalues of the continuous-time system.\n    \"\"\"\n\n    # for the eigenvalues the damping term is divided by 2\n    sigma_mu = damping_term(pars, lambda_mu) / 2\n\n    omega_mu_squared = stiffness_term(pars, lambda_mu)\n\n    # damped frequencies\n    omega_mu = np.sqrt(omega_mu_squared - sigma_mu**2)\n\n    gt_eigenvalues = -sigma_mu + 1j * omega_mu  # continuous time eigenvalues\n    return gt_eigenvalues\n:::\n\nfrom IPython.display import Audio\n\n\nn_max_modes = 50\nsr = 44100\ndt = 1 / sr\nfinal_time = 1.0\nn_samples = int(final_time / dt)\np_params = StringParameters()\nwn = string_eigenvalues_sqrt(n_max_modes, p_params.length)\neigvals = eigenvalues_from_pde(p_params, wn)\n\nprint(eigvals.imag.min() / (2 * np.pi))\n\neigvals_d = np.exp(eigvals * dt)\n\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\ndisplay(Audio(states.sum(0), rate=sr))\n\n::: {#cell-25 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef eigenvalues_from_plate_pde(\n    platepars: PlateParameters,\n    wnx: np.ndarray,  # wavenumbers x (n_max_modes_x,)\n    wny: np.ndarray,  # wavenumbers y (n_max_modes_y,)\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the positive imaginary side of the eigenvalues of the continuous-time system from the PDE parameters of the rectangular plate. From 5.96 of Digital Sound Synthesis using the FTM, and Eq. 8 of TENSION MODULATED NONLINEAR 2D MODELS FOR DIGITAL SOUND SYNTHESIS WITH THE FUNCTIONAL TRANSFORMATION METHOD.\n\n    Parameters\n    ----------\n    d1 : float\n        The frequency independent damping coefficient.\n    d3 : float\n        The frequency dependent damping coefficient.\n    A : float\n        The cross-sectional area of the string.\n    E : float\n        The Young's modulus of the string.\n    I : float\n        The second moment of area of the string.\n    wavenumbers : np.ndarray\n        The wavenumbers of the modes.\n\n    Returns\n    -------\n    np.ndarray\n        The eigenvalues of the continuous-time system.\n    \"\"\"\n\n    Lambda = plate_eigenvalues(wnx, wny)\n\n    sigma_mu = platepars.d0 + platepars.d2 * Lambda  # real-part decay\n    sigma_mu = sigma_mu / (2 * platepars.surface_density)\n\n    beta_mu = (\n        platepars.bending_stiffness * Lambda**2 + platepars.Tm * Lambda\n    )  # this gives a correct result but it is not the same as Lambda_squared\n    omega_mu_squared = beta_mu / platepars.surface_density - sigma_mu**2\n\n    omega_mu = np.sqrt(omega_mu_squared)  # imaginary-part frequency\n\n    gt_eigenvalues = -sigma_mu + 1j * omega_mu  # continuous time eigenvalues\n    return gt_eigenvalues\n:::\n\nn_max_modes_x = 20\nn_max_modes_y = 20\nsr = 44100\ndt = 1 / sr\nfinal_time = 6.0\nn_samples = int(final_time / dt)\n\np_params = PlateParameters()\nwnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.l1, p_params.l2)\neigvals = eigenvalues_from_plate_pde(p_params, wnx, wny).reshape(-1)\n\nprint(eigvals.imag.min() / (2 * np.pi))\neigvals_d = np.exp(eigvals * dt)\n\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\ndisplay(Audio(states.sum(0), rate=sr))\n\n::: {#cell-27 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef eigenvalues_from_drumhead_pde(\n    drumhead_pars: CircularDrumHeadParameters,\n    Lambda_nm: np.ndarray,  # (n_max_modes_r, m_max_modes_theta)\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the positive imaginary side of the eigenvalues of the continuous-time system from the PDE parameters of the rectangular plate. From 5.96 of Digital Sound Synthesis using the FTM, and Eq. 8 of TENSION MODULATED NONLINEAR 2D MODELS FOR DIGITAL SOUND SYNTHESIS WITH THE FUNCTIONAL TRANSFORMATION METHOD.\n\n    Parameters\n    ----------\n    d1 : float\n        The frequency independent damping coefficient.\n    d3 : float\n        The frequency dependent damping coefficient.\n    rho : float\n        The density of the string.\n    A : float\n        The cross-sectional area of the string.\n    E : float\n        The Young's modulus of the string.\n    I : float\n        The second moment of area of the string.\n    wavenumbers : np.ndarray\n        The wavenumbers of the modes.\n\n    Returns\n    -------\n    np.ndarray\n        The eigenvalues of the continuous-time system.\n    \"\"\"\n\n    # The term that goes with the fourth spatial derivative\n    D = drumhead_pars.E * drumhead_pars.h**3 / (12 * (1 - drumhead_pars.nu**2))\n\n    sigma_mu = drumhead_pars.d0 + drumhead_pars.d2 * Lambda_nm  # real-part decay\n    sigma_mu = sigma_mu / (2 * drumhead_pars.surface_density)\n\n    omega_mu_squared = D * Lambda_nm**2 + drumhead_pars.Tm * Lambda_nm\n    omega_mu_squared = omega_mu_squared / drumhead_pars.surface_density - sigma_mu**2\n\n    omega_mu = np.sqrt(omega_mu_squared)  # imaginary-part frequency\n\n    gt_eigenvalues = -sigma_mu + 1j * omega_mu  # continuous time eigenvalues\n    return gt_eigenvalues\n:::\n\nn_max_modes_x = 20\nn_max_modes_y = 20\nsr = 44100\ndt = 1 / sr\nfinal_time = 2.0\nn_samples = int(final_time / dt)\np_params = CircularDrumHeadParameters.avanzini()\n\nv = drumhead_eigenvalues(\n    drumhead_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.r0)\n)\neigvals = eigenvalues_from_drumhead_pde(p_params, v).reshape(-1)\n\n# import matplotlib.pyplot as plt\nprint(eigvals.imag.min() / (2 * np.pi))\nprint(eigvals.imag.max() / (2 * np.pi))\n# plt.plot(eigvals)\n\neigvals_d = np.exp(eigvals * dt)\nstates = np.vander(eigvals_d, n_samples, increasing=True).real\n\n# fig, ax = plt.subplots(1, 1, figsize=(10, 5))\n# ax.plot(states[0])\ndisplay(Audio(states[0], rate=sr))\n\n::: {#cell-29 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef sample_parallel_tf(\n    num: np.ndarray,  # (n_modes,)\n    den: np.ndarray,  # (n_modes,)\n    dt: float,\n    method: str = \"impulse\",\n):\n    \"\"\"\n    Sample a parallel transfer function using the impulse invariant method.\n\n    Parameters\n    ----------\n    num : np.ndarray\n        The numerator of the transfer function.\n    den : np.ndarray\n        The denominator of the transfer function.\n\n    Returns\n    -------\n    num_d : np.ndarray\n        The numerator of the discrete-time transfer function.\n    den_d : np.ndarray\n        The denominator of the discrete-time transfer function.\n    \"\"\"\n\n    def sample(n, d):\n        b, a, _ = cont2discrete((n, d), dt, method=method)\n        return b.flatten(), a.flatten()\n\n    b, a = zip(*[sample(n, d) for n, d in zip(num, den)])\n\n    return np.array(b), np.array(a)\n:::\n::: {#cell-30 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef tf_initial_conditions_continuous_2(\n    D: float,\n    density: float,\n    d1: float,\n    d3: float,\n    Ts0: float,\n    lambda_mu: jnp.array,\n) -&gt; tuple[jnp.array, jnp.array]:\n    \"\"\"\n    Conpute the continuous-time initial condition transfer function.\n    This is an alternative to the function `tf_initial_conditions_continuous`\n    that eigenvalues of the PDE as input.\n\n    Parameters\n    ----------\n\n    D : float\n        The bending stiffness of the string or plate.\n    density : float\n        The area or surface density of the string or plate.\n    d1 : float\n        The linear damping coefficient, or frequency-independent damping.\n    d3 : float\n        The cubic damping coefficient, or frequency-dependent damping.\n    Ts0 : float\n        The initial tension of the string or plate.\n    lambda_mu : jnp.array\n        The eigenvalues from the decomposition of the Laplacian operator.\n\n    Returns\n    -------\n    tuple[jnp.array, jnp.array]\n        The numerator and denominator of the transfer function.\n    \"\"\"\n\n    sigma_mu = (d1 + d3 * lambda_mu) / density\n\n    omega_mu_squared = D * lambda_mu**2 + Ts0 * lambda_mu\n    omega_mu_squared = omega_mu_squared / density\n\n    a1 = sigma_mu\n    a2 = omega_mu_squared\n    ones = jnp.ones(lambda_mu.shape[0])\n\n    # assemble the numerator and denominator for the transfer function\n    # starting with highest order term\n    b = jnp.stack([ones, a1], axis=-1)\n    a = jnp.stack([ones, a1, a2], axis=-1)\n\n    return (b, a)\n:::\n::: {#cell-31 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef tf_excitation_continuous(\n    eigenvalues: np.ndarray,\n    density: float,  # surface or area density\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the continuous excitation transfer function.\n\n    Parameters\n    ----------\n    eigenvalues : np.ndarray\n        The eigenvalues of the system.\n    density: float\n        The surface density of a membrane (rho * h) or area density of a string (rho * A)\n    dt : float\n        The time step size.\n\n    Returns\n    -------\n    np.ndarray\n        The numerator of the discrete-time transfer function.\n    np.ndarray\n        The denominator of the discrete-time transfer function\n    \"\"\"\n    sigma_mu = -eigenvalues.real\n    omega_mu = eigenvalues.imag\n\n    a1 = sigma_mu * 2\n    a2 = sigma_mu**2 + omega_mu**2\n\n    ones = np.ones_like(sigma_mu)\n    b = ones / density\n    a = np.stack([ones, a1, a2], axis=-1)\n    return b, a\n\n\ndef tf_excitation_discrete(\n    eigenvalues: np.ndarray,\n    density: float,  # surface or area density\n    dt: float,  # time step\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the discrete-time excitation transfer function of a system.\n\n    Parameters\n    ----------\n    eigenvalues : np.ndarray\n        The eigenvalues of the system.\n    density: float\n        The surface density of a membrane (rho * h) or area density of a string (rho * A)\n    dt : float\n        The time step size.\n\n    Returns\n    -------\n    np.ndarray\n        The numerator of the discrete-time transfer function.\n    np.ndarray\n        The denominator of the discrete-time transfer function\n    \"\"\"\n    b, a = tf_excitation_continuous(eigenvalues, density)\n\n    # Discretize the system\n    tf_d = sample_parallel_tf(b, a, dt)\n\n    return tf_d\n:::\n::: {#cell-32 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef tf_initial_conditions_continuous(\n    eigenvalues: np.ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the continuos \"initial-conditions\" transfer function from the eigenvalues of the system.\n\n    Parameters\n    ----------\n    eigenvalues : np.ndarray\n        The eigenvalues of the system.\n    density: float\n        The surface density of a membrane (rho * h) or area density of a string (rho * A)\n    dt : float\n        The time step size.\n\n    Returns\n    -------\n    np.ndarray\n        The numerator of the discrete-time transfer function.\n    np.ndarray\n        The denominator of the discrete-time transfer function\n    \"\"\"\n    sigma_mu = -eigenvalues.real\n    omega_mu = eigenvalues.imag\n\n    a1 = sigma_mu * 2\n    a2 = sigma_mu**2 + omega_mu**2\n\n    ones = np.ones_like(sigma_mu)\n    b1 = a1\n\n    b = np.stack([ones, b1], axis=-1)\n    a = np.stack([ones, a1, a2], axis=-1)\n\n    return (b, a)\n\n\ndef tf_initial_conditions_discrete(\n    eigenvalues: np.ndarray,\n    dt: float,  # time step\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the discrete-time initial conditions transfer function of a system.\n\n    Parameters\n    ----------\n    eigenvalues : np.ndarray\n        The eigenvalues of the system.\n    density: float\n        The surface density of a membrane (rho * h) or area density of a string (rho * A)\n    dt : float\n        The time step size.\n\n    Returns\n    -------\n    np.ndarray\n        The numerator of the discrete-time transfer function.\n    np.ndarray\n        The denominator of the discrete-time transfer function\n    \"\"\"\n    b, a = tf_initial_conditions_continuous(eigenvalues)\n\n    # Discretize the system\n    tf_d = sample_parallel_tf(b, a, dt)\n\n    return tf_d\n:::\n::: {#cell-33 .cell 0=‘t’ 1=‘e’ 2=‘s’ 3=‘t’}\nb, a = tf_excitation_discrete(eigvals, p_params.surface_density, dt)\nb_ic, a_ic = tf_initial_conditions_discrete(eigvals, dt)\n\n# manual discretization\neigenvalues_d = np.exp(eigvals * dt)\n\n# for the excitation tf\nb1 = (\n    np.exp(eigvals.real * dt)\n    * np.sin(eigvals.imag * dt)\n    / eigvals.imag\n    / p_params.surface_density\n)\n\n# for the initial conditions tf\n# here we ignore initial velocity\nr = np.exp(eigvals.real * dt)\nb1_ic = r * np.sin(eigvals.imag * dt) / eigvals.imag * -eigvals.real - r * np.cos(\n    eigvals.imag * dt\n)\n\na1 = -2 * np.exp(eigvals.real * dt) * np.cos(eigvals.imag * dt)\na2 = np.exp(2 * eigvals.real * dt)\nb_manual = np.stack([np.zeros_like(b1), b1, np.zeros_like(b1)], axis=-1) * dt\na_manual = np.stack([np.ones_like(a1), a1, a2], axis=-1)\n\nb_ic_manual = np.stack([np.ones_like(b1_ic), b1_ic], axis=-1) * dt\n\nprint(b[0])\nprint(b_manual[0])\nprint(b_ic[0] * sr)\nprint(b_ic_manual[0] * sr)\nassert np.allclose(b[:, 1], b_manual[:, 1])\nassert np.allclose(a, a_manual)\nassert np.allclose(b_ic[:, :2], b_ic_manual[:, :2])\n:::\n::: {#cell-34 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef tf_freqs(\n    b: jnp.ndarray,  # numerator (n_modes, 2)\n    a: jnp.ndarray,  # denominator (n_modes, 3)\n    s: jnp.ndarray,  # frequency (n_freqs,)\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Compute the frequency response of a transfer function.\n\n    Parameters\n    ----------\n    b : jnp.ndarray\n        The numerator of the transfer function.\n    a : jnp.ndarray\n        The denominator of the transfer function.\n    s : jnp.ndarray\n        The frequencies to evaluate the transfer function at.\n\n    Returns\n    -------\n    jnp.ndarray\n        The frequency response of the transfer function.\n    \"\"\"\n\n    num = b[:, 0][..., None] * s + b[:, 1][..., None]\n    den = a[:, 0][..., None] * s**2 + a[:, 1][..., None] * s + a[:, 2][..., None]\n    return num / den\n:::",
    "crumbs": [
      "Funtional Transformation Method Utilities"
    ]
  },
  {
    "objectID": "losses.html",
    "href": "losses.html",
    "title": "Losses",
    "section": "",
    "text": "::: {#cell-3 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’ 6=‘i’}\nimport jax.numpy as jnp\nimport jax\n:::\n\nimport matplotlib.pyplot as plt\n\n::: {#cell-5 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef quantile_function(qs, cws, xs):\n    r\"\"\"Computes the quantile function of an empirical distribution\n\n    Parameters\n    ----------\n    qs: array-like, shape (n,)\n        Quantiles at which the quantile function is evaluated\n    cws: array-like, shape (m, ...)\n        cumulative weights of the 1D empirical distribution, if batched, must be similar to xs\n    xs: array-like, shape (n, ...)\n        locations of the 1D empirical distribution, batched against the `xs.ndim - 1` first dimensions\n\n    Returns\n    -------\n    q: array-like, shape (..., n)\n        The quantiles of the distribution\n    \"\"\"\n    n = xs.shape[0]\n    cws = cws.T\n    qs = qs.T\n    idx = jnp.searchsorted(cws, qs).T\n    return jnp.take_along_axis(xs, jnp.clip(idx, 0, n - 1), axis=0)\n\n\ndef wasserstein_1d(\n    u_values,\n    v_values,\n    u_weights=None,\n    v_weights=None,\n    p=1,\n    require_sort=True,\n):\n    r\"\"\"\n    Computes the 1 dimensional OT loss [15] between two (batched) empirical\n    distributions\n\n    .. math:\n        OT_{loss} = \\int_0^1 |cdf_u^{-1}(q) - cdf_v^{-1}(q)|^p dq\n\n    It is formally the p-Wasserstein distance raised to the power p.\n    We do so in a vectorized way by first building the individual quantile functions then integrating them.\n\n    This function should be preferred to `emd_1d` whenever the backend is\n    different to numpy, and when gradients over\n    either sample positions or weights are required.\n\n    Parameters\n    ----------\n    u_values: array-like, shape (n, ...)\n        locations of the first empirical distribution\n    v_values: array-like, shape (m, ...)\n        locations of the second empirical distribution\n    u_weights: array-like, shape (n, ...), optional\n        weights of the first empirical distribution, if None then uniform weights are used\n    v_weights: array-like, shape (m, ...), optional\n        weights of the second empirical distribution, if None then uniform weights are used\n    p: int, optional\n        order of the ground metric used, should be at least 1 (see [2, Chap. 2], default is 1\n    require_sort: bool, optional\n        sort the distributions atoms locations, if False we will consider they have been sorted prior to being passed to\n        the function, default is True\n\n    Returns\n    -------\n    cost: float/array-like, shape (...)\n        the batched EMD\n\n    References\n    ----------\n    .. [15] Peyré, G., & Cuturi, M. (2018). Computational Optimal Transport.\n\n    \"\"\"\n\n    assert p &gt;= 1, \"The OT loss is only valid for p&gt;=1, {p} was given\".format(p=p)\n\n    n = u_values.shape[0]\n    m = v_values.shape[0]\n\n    if u_weights is None:\n        u_weights = jnp.full(u_values.shape, 1.0 / n, dtype=u_values.dtype)\n    elif u_weights.ndim != u_values.ndim:\n        u_weights = jnp.repeat(u_weights[..., None], u_values.shape[-1], -1)\n    if v_weights is None:\n        v_weights = jnp.full(v_values.shape, 1.0 / m, dtype=v_values.dtype)\n    elif v_weights.ndim != v_values.ndim:\n        v_weights = jnp.repeat(v_weights[..., None], v_values.shape[-1], -1)\n\n    if require_sort:\n        u_sorter = jnp.argsort(u_values, 0)\n        u_values = jnp.take_along_axis(u_values, u_sorter, 0)\n\n        v_sorter = jnp.argsort(v_values, 0)\n        v_values = jnp.take_along_axis(v_values, v_sorter, 0)\n\n        u_weights = jnp.take_along_axis(u_weights, u_sorter, 0)\n        v_weights = jnp.take_along_axis(v_weights, v_sorter, 0)\n\n    u_cumweights = jnp.cumsum(u_weights, 0)\n    v_cumweights = jnp.cumsum(v_weights, 0)\n\n    qs = jnp.sort(jnp.concatenate((u_cumweights, v_cumweights), 0), 0)\n    u_quantiles = quantile_function(qs, u_cumweights, u_values)\n    v_quantiles = quantile_function(qs, v_cumweights, v_values)\n    qs = jnp.pad(qs, pad_width=[(1, 0)] + (qs.ndim - 1) * [(0, 0)])\n    delta = qs[1:, ...] - qs[:-1, ...]\n    diff_quantiles = jnp.abs(u_quantiles - v_quantiles)\n\n    if p == 1:\n        return jnp.sum(delta * diff_quantiles, axis=0)\n    return jnp.sum(delta * jnp.power(diff_quantiles, p), axis=0)\n:::\n::: {#cell-6 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef compute_mag(\n    x: jnp.ndarray,  # (b, t)\n) -&gt; jnp.ndarray:\n    # Compute the magnitude rfft\n    return jnp.abs(jnp.fft.rfft(x, axis=-1, norm=\"forward\"))\n:::\n::: {#cell-7 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef spectral_wasserstein(\n    x,\n    y,\n    squared=True,\n    is_mag=False,\n):\n    if is_mag:\n        x_mag = x\n        y_mag = y\n    else:\n        x_mag = compute_mag(x) if not squared else compute_mag(x) ** 2\n        y_mag = compute_mag(y) if not squared else compute_mag(y) ** 2\n\n    # we need to normalise the mag_ffts so that they represent distributions\n    x_mag = x_mag / jnp.sum(x_mag)\n    y_mag = y_mag / jnp.sum(y_mag)\n\n    x_pos = jnp.linspace(0, 1, x_mag.shape[-1])\n\n    return wasserstein_1d(\n        x_pos,\n        x_pos,\n        x_mag,\n        y_mag,\n    )\n\n\nbatched_spectral_wasserstein = jax.vmap(spectral_wasserstein)\n:::\n::: {#cell-8 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef log_mag(\n    x: jnp.ndarray,\n    eps: float = 1e-10,\n):\n    return jnp.log(jnp.abs(x) + eps)\n\n\ndef log_mag_loss(\n    pred: jnp.ndarray,  # complex valued fft of the signal\n    target: jnp.ndarray,  # complex valued fft of the signal\n    eps: float = 1e-10,\n    distance: str = \"l1\",\n):\n    \"\"\"\n    Spectral log magtinude loss but for a fft of a signal\n    See [Arik et al., 2018](https://arxiv.org/abs/1808.06719)\n    \"\"\"\n\n    pred_log_mag = log_mag(pred, eps)\n    target_log_mag = log_mag(target, eps)\n\n    # l1 spectral log magnitude loss\n    if distance == \"l1\":\n        return jnp.mean(jnp.abs(pred_log_mag - target_log_mag))\n    # l2 spectral log magnitude loss\n    elif distance == \"l2\":\n        return jnp.mean((pred_log_mag - target_log_mag) ** 2)\n    else:\n        raise ValueError(\"Invalid distance metric. Choose 'l1' or 'l2'.\")\n:::\n\nphase = 0.0\nomegas = jax.random.uniform(jax.random.PRNGKey(0), shape=(10,)) * 100\nmag = 1.0\n\n\ndef osc_bank(t, omegas):\n    return mag * jnp.sin(omegas[..., None] * jnp.pi * 2 * t[None] + phase)\n\n\nt = jnp.linspace(0, 1, 1000)\ngt_osc_values = osc_bank(t, omegas)\nprint(gt_osc_values.shape)\n\n(10, 1000)\n\n\n\na = jax.vmap(spectral_wasserstein)(gt_osc_values, gt_osc_values)\nprint(a)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\ndef loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n    x_fft = compute_mag(gt_osc_values)\n    y_fft = compute_mag(pred_osc_values)\n    l2_mag_loss = jnp.mean((x_fft - y_fft) ** 2)\n    return l2_mag_loss\n\n\ndef ot_loss_fn(omega):\n    pred_osc_values = osc_bank(t, omega)\n\n    ot_loss = jnp.mean(\n        jax.vmap(spectral_wasserstein)(gt_osc_values, pred_osc_values),\n    )\n    return ot_loss\n\n\nx_fft = compute_mag(gt_osc_values) ** 2\nplt.plot(x_fft[:5].T)\n\n\n\n\n\n\n\n\n\nranges = jnp.linspace(-50, 50, 100)\nomegas_scan = omegas + ranges[:, None]\n\n# print(omegas_scan.shape)\nloss, grad = jax.vmap(jax.value_and_grad(loss_fn))(omegas_scan)\nloss_ot, grad_ot = jax.vmap(jax.value_and_grad(ot_loss_fn))(omegas_scan)\n\nprint(loss.shape, loss.dtype)\nprint(loss_ot.shape, loss_ot.dtype)\n# loss_mean = jnp.mean(loss, axis=1)\n# loss_ot_mean = jnp.mean(loss_ot, axis=-1)\n# print(loss_mean.shape)\nplt.plot(ranges, loss)\nplt.plot(ranges, loss_ot)\n\n(100,) float32\n(100,) float32\n\n\n\n\n\n\n\n\n\n::: {#cell-15 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef spectral_convergence_loss(\n    pred: jnp.ndarray,  # complex valued fft of the signal\n    target: jnp.ndarray,  # complex valued fft of the signal\n):\n    \"\"\"\n    Spectral convergence loss but for a fft of a signal\n    See [Arik et al., 2018](https://arxiv.org/abs/1808.06719)\n    \"\"\"\n    # l2 spectral convergence loss\n    return jnp.linalg.norm(jnp.abs(target) - jnp.abs(pred)) / jnp.linalg.norm(\n        jnp.abs(target)\n    )\n:::",
    "crumbs": [
      "Losses"
    ]
  }
]