# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/sv.ipynb.

# %% auto 0
__all__ = [
    "A_inv_vector",
    "B_vector",
    "C_vector",
    "solve_sv_berger_jax_scan",
    "solve_sv_vk_jax_scan",
]

# %% ../nbs/sv.ipynb 4
import einops
import jax
import jax.numpy as jnp


# %% ../nbs/sv.ipynb 5
def A_inv_vector(
    h,  # temporal grid spacing (scalar)
    damping,  # damping term (vector)
):
    """
    Also this is already multiplied $h^2$
    """
    return 2.0 * h**2 / (2.0 + damping * h)
    # return 2.0 / (2.0 + damping * h)


def B_vector(
    h,  # temporal grid spacing (scalar)
    stiffness,  # stiffness term (vector)
):
    """
    Note this include the minus side caused by puting this term on the right hand side of the equation. Also this is already multiplied $h^2$
    """
    return 2.0 / h**2 - stiffness

    # return 2.0 - stiffness * h**2


def C_vector(
    h,  # temporal grid spacing (scalar)
    damping,  # damping term (vector)
):
    """
    Note this include the minus side caused by puting this term on the right hand side of the equation. Also this is already multiplied $h^2$
    """
    return -1.0 / h**2 + (damping / (2.0 * h))
    # return -1.0 + damping * h * 0.5


# %% ../nbs/sv.ipynb 8
@jax.jit
def solve_sv_berger_jax_scan(
    A_inv: jnp.ndarray,
    B: jnp.ndarray,
    C: jnp.ndarray,
    modal_excitation: jnp.ndarray,  # (T, n_modes)
    lambda_mu: jnp.ndarray,
    factors: jnp.ndarray,
    g: float,  # factor for the input
):
    n_modes = A_inv.shape[0]
    q = jnp.zeros((n_modes,))  # Modal displacement vector at n (n_modes, 1)
    q_prev = jnp.zeros((n_modes,))  # Modal displacement vector at n-1

    def advance_state(
        state: jnp.ndarray,  # inital state
        x: jnp.ndarray,  # input
    ) -> tuple[jnp.ndarray, jnp.ndarray]:  # carry, output
        # unpack state
        q_prev, q = state

        nl = lambda_mu * q * (factors @ q**2)

        # compute the next state
        # q_next = B * q + C * q_prev - g * nl + g * x
        q_next = B * q + C * q_prev - g * nl + x

        # return the next state and the output
        return (q, q_next), q_next

    state, final = jax.lax.scan(
        advance_state,
        (q_prev, q),
        modal_excitation,  # (T, n_modes)
        unroll=8,
    )
    return state, final


# %% ../nbs/sv.ipynb 10
@jax.jit
def solve_sv_vk_jax_scan(
    A_inv: jnp.ndarray,
    B: jnp.ndarray,
    C: jnp.ndarray,
    modal_excitation: jnp.ndarray,  # (T, n_modes)
    Hv: jnp.ndarray,
    g: float,  # factor for the input
):
    n_modes = A_inv.shape[0]
    q = jnp.zeros((n_modes,))  # Modal displacement vector at n (n_modes, 1)
    q_prev = jnp.zeros((n_modes,))  # Modal displacement vector at n-1

    def advance_state(
        state: jnp.ndarray,  # inital state
        x: jnp.ndarray,  # input
    ) -> tuple[jnp.ndarray, jnp.ndarray]:  # carry, output
        # unpack state
        q_prev, q = state

        nl = einops.einsum(
            Hv,
            Hv,
            q,
            q,
            q,
            "n p q, n r s, p, q, r -> s",
        )
        # compute the next state
        q_next = B * q + C * q_prev - g * nl + x

        # return the next state and the output
        return (q, q_next), q_next

    state, final = jax.lax.scan(
        advance_state,
        (q_prev, q),
        modal_excitation,  # (T, n_modes)
        unroll=8,
    )
    return state, final
