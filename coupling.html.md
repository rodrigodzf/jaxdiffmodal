# Coupling functions


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Integrals for building the mass and stifness matrices

------------------------------------------------------------------------

### assemble_K_and_M

>      assemble_K_and_M (Npsi, Lx, Ly)

------------------------------------------------------------------------

### build_I4

>      build_I4 (N, L)

*Returns the N x N matrix whose (m,p) entry = int4(m,p,L).*

------------------------------------------------------------------------

### build_I2

>      build_I2 (N, L)

*Returns the N x N matrix whose (m,p) entry = int2(m,p,L).*

------------------------------------------------------------------------

### build_I1

>      build_I1 (N, L)

*Returns the N x N matrix whose (m,p) entry = int1(m,p,L).*

------------------------------------------------------------------------

### int2_mat

>      int2_mat (N, L)

*Builds the N x N matrix whose (m,p) entry is int2(m,p,L). Mirrors the
logic of the original Matlab int2_mat function exactly, but we can do it
more simply by calling int2 in a loop.*

------------------------------------------------------------------------

### int2

>      int2 (m, p, L)

*Function int2(m,p,L). Piecewise definition from the Matlab code.*

------------------------------------------------------------------------

### int1

>      int1 (m, p, L)

*Function int1(m,p,L). Piecewise definition from the Matlab code.*

------------------------------------------------------------------------

### int4

>      int4 (m, p, L)

*Integral of Xd(m,x)*Xd(p,x) from 0 to L, where X is the clamped-plate
function and d denotes derivative in x. Piecewise definition follows the
original Matlab code exactly.\*

------------------------------------------------------------------------

### airy_stress_coefficients

>      airy_stress_coefficients (n_psi, vals, vecs)

*Compute the Airy stress function coefficients from the eigenvalues and
eigenvectors*

## Basis used to build the mass and stiffness matrices

------------------------------------------------------------------------

### basis

>      basis (m, n, x, y, Lx, Ly)

*Evaluate the full 2D basis function for indices (m, n) at point (x, y).
This is simply X_m(x)*Y_n(y).\*

## Partial integrals to calculate the coupling matrix

------------------------------------------------------------------------

### i13_mat

>      i13_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i12_mat

>      i12_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i11_mat

>      i11_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i10_mat

>      i10_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i9_mat

>      i9_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i5_mat

>      i5_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i4_mat

>      i4_mat (Npsi, Nphi, L)

*Auxiliary integral for the computation of the coupling coefficient H.*

------------------------------------------------------------------------

### i3_mat

>      i3_mat (Npsi, Nphi, L)

*Auxiliary integral for the computation of the coupling coefficient H.*

------------------------------------------------------------------------

### i2_mat

>      i2_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i1_mat

>      i1_mat (Npsi, Nphi, L)

## functions to put together the coupling matrix

------------------------------------------------------------------------

### g6

>      g6 (Npsi, Nphi, S, ky, cache)

------------------------------------------------------------------------

### g5

>      g5 (Npsi, Nphi, S, kx, cache)

------------------------------------------------------------------------

### g4

>      g4 (Npsi, Nphi, S, ky, cache)

------------------------------------------------------------------------

### g3

>      g3 (Npsi, Nphi, S, ky, cache)

------------------------------------------------------------------------

### g2

>      g2 (Npsi, Nphi, S, kx, cache)

------------------------------------------------------------------------

### g1

>      g1 (Npsi, Nphi, S, kx, cache)

------------------------------------------------------------------------

### build_s_matrix

>      build_s_matrix (Npsi, Nphi, partials, idx_array, factor_mode)

*Summation of partial integrals in a 3D array with a factor.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Npsi</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Nphi</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>partials</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>idx_array</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>factor_mode</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.ndarray of shape (Npsi, Nphi, Nphi)</strong></td>
<td><strong>The 3D tensor after summation and factor
application.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### compute_partial_integrals

>      compute_partial_integrals (Npsi, Nphi, Lx, Ly)

*Precompute and store all partial-integral matrices needed. Returns them
in a dictionary or a custom object.*

------------------------------------------------------------------------

### H_tensor_rectangular

>      H_tensor_rectangular (coeff0, coeff1, coeff2, Nphi, Npsi, Lx, Ly, kx, ky)

*Compute the H tensor for rectangular plates.*

------------------------------------------------------------------------

### compute_coupling_matrix

>      compute_coupling_matrix (n_psi, n_phi, lx, ly, kx_indices, ky_indices)
