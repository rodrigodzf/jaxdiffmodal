# Funtional Transformation Method Utilities


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

This notebook contains a set of utility functions for the functional
transformation method.

------------------------------------------------------------------------

### CircularDrumHeadParameters

>      CircularDrumHeadParameters (h:float=0.00019, r0:float=0.328,
>                                  I:float=5.7e-13, rho:float=1380.0,
>                                  E:int=3500000000.0, nu:float=0.35,
>                                  d1:float=0.14, d3:float=0.32, Ts0:float=3990,
>                                  f0:float=143.95)

*Kettle drum head, from Digital sound synthesis of string instruments
with the functional transformation method Table 5.2.*

------------------------------------------------------------------------

### PlateParameters

>      PlateParameters (h:float=0.0012, l1:float=1.08, l2:float=1.08,
>                       I:float=1.44e-10, rho:float=7800.0,
>                       E:int=220000000000.0, nu:float=0.29, d1:float=0.032,
>                       d3:float=0.0013, Ts0:float=2010, f_1:float=10.27)

*From Digital sound synthesis of string instruments with the functional
transformation method Table 5.2.*

------------------------------------------------------------------------

### StringParameters

>      StringParameters (A:float=5.188e-07, I:float=1.41e-13, rho:float=1140,
>                        E:int=5400000000.0, d1:float=8e-05, d3:float=1.4e-05,
>                        Ts0:float=60.97, length:float=0.65)

*Dataclass to store the parameters of the string. Based on a nylon B
string of the guitar. From Table 4.1 of Digital Sound Synthesis using
the FTM. Moment of intertia and damping are changed however.*

------------------------------------------------------------------------

### PhysicalParameters

>      PhysicalParameters ()

------------------------------------------------------------------------

### othonormal_eigenfunctions

>      othonormal_eigenfunctions (eigenfunctions:numpy.ndarray)

\*Normalize the eigenfunctions of the string. The orthonormal
eigenfunctions of the string are given by:

$$
\sqrt{rac{2}{N}} \sin(\pi x k)
$$

where *k* is the wavenumber and *x* is the grid positions.\*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>eigenfunctions</td>
<td>ndarray</td>
<td>The eigenfunctions of the string.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>The orthonormal eigenfunctions of the string.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### string_eigenfunctions

>      string_eigenfunctions (wavenumbers:numpy.ndarray, grid:numpy.ndarray)

\*Compute the modes of the string. The modes of the string are given by:

*K* = sin (*π**x**k*)

where *k* is the wavenumber and *x* is the grid positions.\*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wavenumbers</td>
<td>ndarray</td>
<td>The wavenumbers of the string.</td>
</tr>
<tr class="even">
<td>grid</td>
<td>ndarray</td>
<td>The grid positions of the string where to compute the modes.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>The modes of the string at the given grid
positions.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### string_eigenvalues_sqrt

>      string_eigenvalues_sqrt (n_max_modes:int, length:float)

\*Compute the eigenvalues of the string. The eigenvalues of the string
are given by:

*λ*<sub>*μ*</sub> = (*r**a**c**μ**π**L**i**g**h**t*)

where *μ* is the mode number and *L* is the length of the string.\*

------------------------------------------------------------------------

### string_eigenvalues

>      string_eigenvalues (n_modes:int, length:float)

------------------------------------------------------------------------

### plate_eigenfunctions

>      plate_eigenfunctions (wavenumbers_x:numpy.ndarray,
>                            wavenumbers_y:numpy.ndarray, x:numpy.ndarray,
>                            y:numpy.ndarray)

\*Compute the modes of the plate. The modes of the plate are given by:

*K* = sin (*π**x**k*)sin (*π**y**k*)

where *k* is the wavenumber and *x* and *y* are the grid positions.\*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wavenumbers_x</td>
<td>ndarray</td>
<td>(n_max_modes_x,)</td>
</tr>
<tr class="even">
<td>wavenumbers_y</td>
<td>ndarray</td>
<td>(n_max_modes_y,)</td>
</tr>
<tr class="odd">
<td>x</td>
<td>ndarray</td>
<td>(n_gridpoints_x,)</td>
</tr>
<tr class="even">
<td>y</td>
<td>ndarray</td>
<td>(n_gridpoints_y,)</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### plate_eigenvalues

>      plate_eigenvalues (wavenumbers_x:numpy.ndarray,
>                         wavenumbers_y:numpy.ndarray, squared:bool=False)

\*Compute the eigenvalues of the plate. The eigenvalues of the plate are
given by:

    $$
    \lambda_{\mu, 

u} = $$

    where $\mu$ and $

u$ are the mode numbers and *L*<sub>1</sub> and *L*<sub>2</sub> are the
width and height of the plate.\*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wavenumbers_x</td>
<td>ndarray</td>
<td></td>
<td>(n_max_modes_x,)</td>
</tr>
<tr class="even">
<td>wavenumbers_y</td>
<td>ndarray</td>
<td></td>
<td>(n_max_modes_y,)</td>
</tr>
<tr class="odd">
<td>squared</td>
<td>bool</td>
<td>False</td>
<td></td>
</tr>
</tbody>
</table>

    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Parameters: 
    ---------- in 
    Compute the wavenumbers of the plate.
    ...
      else: warn(msg)
    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Returns: 
    ------- in 
    Compute the wavenumbers of the plate.
    ...
      else: warn(msg)

------------------------------------------------------------------------

### plate_wavenumbers

>      plate_wavenumbers (n_max_modes_x:int, n_max_modes_y:int, l1:float,
>                         l2:float)

\*Compute the wavenumbers of the plate.

## Parameters:

n_max_modes_x: int The number of modes in the x direction.
n_max_modes_y: int The number of modes in the y direction. l1: float The
width of the plate. l2: float The height of the plate.

## Returns:

wn_x: np.ndarray The wavenumbers in the x direction. wn_y: np.ndarray
The wavenumbers in the y direction\*

``` python
import matplotlib.pyplot as plt
```

    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Parameters: 
    ---------- in 
    Compute the modes of the drumhead.
    The modes of the drumhead are given by the Bessel function times the sine/cosine of the angle....
      else: warn(msg)
    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Returns: 
    ------- in 
    Compute the modes of the drumhead.
    The modes of the drumhead are given by the Bessel function times the sine/cosine of the angle....
      else: warn(msg)

------------------------------------------------------------------------

### drumhead_eigenfunctions

>      drumhead_eigenfunctions (wavenumbers:numpy.ndarray, r:numpy.ndarray,
>                               theta:numpy.ndarray)

\*Compute the modes of the drumhead. The modes of the drumhead are given
by the Bessel function times the sine/cosine of the angle.

## Parameters:

wavenumbers: np.ndarray The wavenumbers for the drumhead. r: np.ndarray
Radial grid points. theta: np.ndarray Angular grid points.

## Returns:

modes: np.ndarray The eigenfunctions for the drumhead.\*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wavenumbers</td>
<td>ndarray</td>
<td>(n_max_modes, m_max_modes)</td>
</tr>
<tr class="even">
<td>r</td>
<td>ndarray</td>
<td>(n_gridpoints_r)</td>
</tr>
<tr class="odd">
<td>theta</td>
<td>ndarray</td>
<td>(n_gridpoints_theta)</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
</tr>
</tbody>
</table>

    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Parameters: 
    ---------- in 
    Compute the eigenvalues of the drumhead.
    The eigenvalues of the drumhead are given by the square of the wavenumbers....
      else: warn(msg)
    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Returns: 
    ------- in 
    Compute the eigenvalues of the drumhead.
    The eigenvalues of the drumhead are given by the square of the wavenumbers....
      else: warn(msg)

------------------------------------------------------------------------

### drumhead_eigenvalues

>      drumhead_eigenvalues (wavenumbers:numpy.ndarray)

\*Compute the eigenvalues of the drumhead. The eigenvalues of the
drumhead are given by the square of the wavenumbers.

## Parameters:

wavenumbers: np.ndarray The wavenumbers for the drumhead. squared: bool
If True, return the squared eigenvalues.

## Returns:

eigenvalues: np.ndarray The eigenvalues of the drumhead.\*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wavenumbers</td>
<td>ndarray</td>
<td>(n_max_modes, m_max_modes)</td>
</tr>
</tbody>
</table>

    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Parameters: 
    ---------- in 
    Compute the wavenumbers of the drumhead.
    ...
      else: warn(msg)
    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Returns: 
    ------- in 
    Compute the wavenumbers of the drumhead.
    ...
      else: warn(msg)

------------------------------------------------------------------------

### drumhead_wavenumbers

>      drumhead_wavenumbers (n_max_modes:int, m_max_modes:int, radius:float)

\*Compute the wavenumbers of the drumhead.

## Parameters:

n_max_modes: int The number of angular modes. m_max_modes: int The
number of radial modes. radius: float The radius of the drumhead.

## Returns:

wavenumbers: np.ndarray The wavenumbers for the drumhead.\*

------------------------------------------------------------------------

### dblintegral

>      dblintegral (integrand, x, y, method='simpson')

*Compute the double integral of a function K over the domain x and y.*

``` python
# Example usage
n_max_modes = 25
m_max_modes = 25
radius = 1.0
n_gridpoints_r = 100
n_gridpoints_theta = 100

wavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)
eigenvalues = drumhead_eigenvalues(wavenumbers)
r = np.linspace(0, radius, n_gridpoints_r)
theta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)
K_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)

assert K_inv.shape == (
    n_max_modes,
    m_max_modes,
    n_gridpoints_r,
    n_gridpoints_theta,
)

assert K_fwd.shape == (
    n_max_modes,
    m_max_modes,
    n_gridpoints_r,
    n_gridpoints_theta,
)
```

$$
K\_{n,m}(r, \varphi) = \cos (n \varphi) J_n\left(\mu\_{n, m} \frac{r}{R}\right)
$$

where *J*<sub>*n*</sub> is the Bessel function of the first kind of
order *n*, and *μ*<sub>*n*, *m*</sub> is the *m*-th root of the *n*-th
order Bessel function of the first kind.

``` python
n_max_modes_x = 6
n_max_modes_y = 6
n_gridpoints_x = 20
n_gridpoints_y = 20
length_x = 1.08
length_y = 1.08
grid_x = np.linspace(0, length_x, n_gridpoints_x)
grid_y = np.linspace(0, length_y, n_gridpoints_y)

# slow version
# Define the range for n and m
n_values = np.arange(1, n_max_modes_x + 1)
m_values = np.arange(1, n_max_modes_y + 1)

# Define the range for x and y
x_values = np.linspace(0, length_x, n_gridpoints_x)
y_values = np.linspace(0, length_y, n_gridpoints_y)

# Initialize the 4D array to store the results
K = np.zeros((len(n_values), len(m_values), len(x_values), len(y_values)))
Lambda = np.zeros((len(n_values), len(m_values)))
# Compute the values
for i, n in enumerate(n_values):
    for j, m in enumerate(m_values):
        Lambda[i, j] = np.pi**2 * ((n / length_x) ** 2 + (m / length_y) ** 2)
        for k, x in enumerate(x_values):
            for l, y in enumerate(y_values):
                K[i, j, k, l] = np.sin(n * np.pi * x / length_x) * np.sin(
                    m * np.pi * y / length_y
                )
```

``` python
wnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, length_x, length_y)
assert np.allclose(plate_eigenfunctions(wnx, wny, grid_x, grid_y), K)
assert np.allclose(plate_eigenvalues(wnx, wny), Lambda)
```

    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:
      else: warn(msg)
    /home/diaz/projects/vkplatejax/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:
      else: warn(msg)

------------------------------------------------------------------------

### inverse_STL

>      inverse_STL (K:numpy.ndarray, u_bar:numpy.ndarray, length:float)

*Compute the inverse STL transform using the formula of Rabenstein et
al. (2000).*

<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K</td>
<td>ndarray</td>
<td>(n_modes, n_gridpoints)</td>
</tr>
<tr class="even">
<td>u_bar</td>
<td>ndarray</td>
<td>(n_modes, n_samples) or (n_modes,)</td>
</tr>
<tr class="odd">
<td>length</td>
<td>float</td>
<td>length of the string</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### forward_STL

>      forward_STL (K:numpy.ndarray, u:numpy.ndarray, dx:float)

*Compute the forward STL transform. The integration is done using the
trapezoidal rule.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K</td>
<td>ndarray</td>
<td>(n_modes, n_gridpoints)</td>
</tr>
<tr class="even">
<td>u</td>
<td>ndarray</td>
<td>(n_gridpoints, n_samples) or (n_gridpoints,)</td>
</tr>
<tr class="odd">
<td>dx</td>
<td>float</td>
<td>grid spacing</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>The transformed signal. Shape (n_modes, n_samples) or
(n_modes,)</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### inverse_STL_2d

>      inverse_STL_2d (K:numpy.ndarray, u_bar:numpy.ndarray, l1:float, l2:float)

*Compute the inverse STL transform using the formula of Rabenstein et
al. (2000).*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K</td>
<td>ndarray</td>
<td>(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)</td>
</tr>
<tr class="even">
<td>u_bar</td>
<td>ndarray</td>
<td>(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)</td>
</tr>
<tr class="odd">
<td>l1</td>
<td>float</td>
<td>length in x</td>
</tr>
<tr class="even">
<td>l2</td>
<td>float</td>
<td>length in y</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>The reconstructed signal. Shape (n_gridpoints, n_samples) or
(n_gridpoints,)</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### forward_STL_2d

>      forward_STL_2d (K:numpy.ndarray, u:numpy.ndarray, x:float, y:float,
>                      use_simpson:bool=False)

*Compute the forward STL transform. The integration is done using the
trapezoidal rule.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K</td>
<td>ndarray</td>
<td></td>
<td>(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)</td>
</tr>
<tr class="even">
<td>u</td>
<td>ndarray</td>
<td></td>
<td>(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x,
n_gridpoints_y)</td>
</tr>
<tr class="odd">
<td>x</td>
<td>float</td>
<td></td>
<td>grid spacing</td>
</tr>
<tr class="even">
<td>y</td>
<td>float</td>
<td></td>
<td>grid spacing</td>
</tr>
<tr class="odd">
<td>use_simpson</td>
<td>bool</td>
<td>False</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
<td><strong>The transformed signal. Shape (n_modes, n_samples) or
(n_modes,)</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### evaluate_rectangular_eigenfunctions

>      evaluate_rectangular_eigenfunctions (mn_indices:numpy.ndarray,
>                                           position:numpy.ndarray,
>                                           params:__main__.PlateParameters)

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mn_indices</td>
<td>ndarray</td>
<td>(n_modes, 2) selected mode indices</td>
</tr>
<tr class="even">
<td>position</td>
<td>ndarray</td>
<td>(2,) position to evaluate the eigenfunctions</td>
</tr>
<tr class="odd">
<td>params</td>
<td>PlateParameters</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>(n_modes,) mode gains of selected modes at the given
position</strong></td>
</tr>
</tbody>
</table>

``` python
length_x = 1.08
length_y = 0.8
n_max_modes_x = 25
n_max_modes_y = 25
n_gridpoints_x = 100
n_gridpoints_y = 100

x = np.linspace(0, length_x, n_gridpoints_x)
y = np.linspace(0, length_y, n_gridpoints_y)

wnx, wny = plate_wavenumbers(
    n_max_modes_x,
    n_max_modes_y,
    length_x,
    length_y,
)
K = plate_eigenfunctions(wnx, wny, x, y)

g = 0.5 * K[2, 2] + 0.5 * K[3, 3]

bar_g = forward_STL_2d(K, g, x, y, use_simpson=True)
g_reconstructed = inverse_STL_2d(K, bar_g, length_x, length_y)

assert np.allclose(g, g_reconstructed, atol=1e-2)

fig, ax = plt.subplots(1, 2, figsize=(10, 5))

ax[0].imshow(g, origin="lower", aspect="auto")
ax[0].set_title("Original excitation")
ax[1].imshow(g_reconstructed, origin="lower", aspect="auto")
ax[1].set_title("Reconstructed excitation")
```

------------------------------------------------------------------------

### inverse_STL_drumhead

>      inverse_STL_drumhead (K_inv:numpy.ndarray, u_bar:numpy.ndarray)

*Compute the inverse STL transform using the formula of Rabenstein et
al. (2000).*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K_inv</td>
<td>ndarray</td>
<td>(n_modes_x, n_modes_y, n_gridpoints_x, n_gridpoints_y)</td>
</tr>
<tr class="even">
<td>u_bar</td>
<td>ndarray</td>
<td>(n_modes_x, n_modes_y, n_samples) or (n_modes_x, n_modes_y)</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### forward_STL_drumhead

>      forward_STL_drumhead (K:numpy.ndarray, u:numpy.ndarray, r:numpy.ndarray,
>                            theta:numpy.ndarray, use_simpson:bool=False)

*Compute the forward STL transform. The integration is done using the
trapezoidal rule or Simpson’s rule.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K</td>
<td>ndarray</td>
<td></td>
<td>(n_modes_r, n_modes_theta, n_gridpoints_r, n_gridpoints_theta)</td>
</tr>
<tr class="even">
<td>u</td>
<td>ndarray</td>
<td></td>
<td>(n_gridpoints_x, n_gridpoints_y, n_samples) or (n_gridpoints_x,
n_gridpoints_y)</td>
</tr>
<tr class="odd">
<td>r</td>
<td>ndarray</td>
<td></td>
<td>radial grid</td>
</tr>
<tr class="even">
<td>theta</td>
<td>ndarray</td>
<td></td>
<td>angular grid</td>
</tr>
<tr class="odd">
<td>use_simpson</td>
<td>bool</td>
<td>False</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

``` python
# Example usage
n_max_modes = 10
m_max_modes = 10
radius = 1.0
n_gridpoints_r = 100
n_gridpoints_theta = 100

wavenumbers = drumhead_wavenumbers(n_max_modes, m_max_modes, radius)
eigenvalues = drumhead_eigenvalues(wavenumbers)
r = np.linspace(0, radius, n_gridpoints_r)
theta = np.linspace(0, 2 * np.pi, n_gridpoints_theta)
K_fwd, K_inv, K_N = drumhead_eigenfunctions(wavenumbers, r, theta)

assert np.allclose(
    K_fwd.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)
)  # Should be (10, 10, 100, 100)
assert np.allclose(
    K_inv.shape, (n_max_modes, m_max_modes, n_gridpoints_r, n_gridpoints_theta)
)  # Should be (10, 10, 100, 100)

# Create an example g array to test the transforms
g = K_fwd[3, 3]

bar_g = forward_STL_drumhead(K_fwd, g, r, theta, use_simpson=False)
g_reconstructed = inverse_STL_drumhead(K_inv, bar_g)

# Verify if g can be reconstructed
assert np.allclose(g, g_reconstructed, atol=1e-2)
print(g.min(), g.max())
print(g_reconstructed.min(), g_reconstructed.max())

# Plot using pcolormesh
fig, ax = plt.subplots(
    1,
    2,
    subplot_kw={"projection": "polar"},
    figsize=(10, 5),
)
c = ax[0].pcolormesh(theta, r, g, shading="auto", cmap="viridis")
c = ax[1].pcolormesh(theta, r, g_reconstructed, shading="auto", cmap="viridis")
```

------------------------------------------------------------------------

### stiffness_term

>      stiffness_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)

------------------------------------------------------------------------

### damping_term_simple

>      damping_term_simple (lambda_mu:jax.Array, factor:float=0.001)

------------------------------------------------------------------------

### damping_term

>      damping_term (params:__main__.PhysicalParameters, lambda_mu:jax.Array)

------------------------------------------------------------------------

### eigenvalues_from_pde

>      eigenvalues_from_pde (pars:__main__.PhysicalParameters,
>                            lambda_mu:jax.Array)

*Compute the positive imaginary side of the eigenvalues of the
continuous-time system from the PDE parameters.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pars</td>
<td>PhysicalParameters</td>
<td>The physical parameters of the system.</td>
</tr>
<tr class="even">
<td>lambda_mu</td>
<td>Array</td>
<td>The eigenvalues of the decompostion of the Laplacian operator.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>Array</strong></td>
<td><strong>The eigenvalues of the continuous-time system.</strong></td>
</tr>
</tbody>
</table>

``` python
from IPython.display import Audio
```

``` python
n_max_modes = 50
sr = 44100
dt = 1 / sr
final_time = 1.0
n_samples = int(final_time / dt)
p_params = StringParameters()
wn = string_eigenvalues_sqrt(n_max_modes, p_params.length)
eigvals = eigenvalues_from_pde(p_params, wn)

print(eigvals.imag.min() / (2 * np.pi))

eigvals_d = np.exp(eigvals * dt)

states = np.vander(eigvals_d, n_samples, increasing=True).real
display(Audio(states.sum(0), rate=sr))
```

------------------------------------------------------------------------

### eigenvalues_from_plate_pde

>      eigenvalues_from_plate_pde (platepars:__main__.PlateParameters,
>                                  wnx:numpy.ndarray, wny:numpy.ndarray)

*Compute the positive imaginary side of the eigenvalues of the
continuous-time system from the PDE parameters of the rectangular plate.
From 5.96 of Digital Sound Synthesis using the FTM, and Eq. 8 of TENSION
MODULATED NONLINEAR 2D MODELS FOR DIGITAL SOUND SYNTHESIS WITH THE
FUNCTIONAL TRANSFORMATION METHOD.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>platepars</td>
<td>PlateParameters</td>
<td></td>
</tr>
<tr class="even">
<td>wnx</td>
<td>ndarray</td>
<td>wavenumbers x (n_max_modes_x,)</td>
</tr>
<tr class="odd">
<td>wny</td>
<td>ndarray</td>
<td>wavenumbers y (n_max_modes_y,)</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>The eigenvalues of the continuous-time system.</strong></td>
</tr>
</tbody>
</table>

``` python
n_max_modes_x = 20
n_max_modes_y = 20
sr = 44100
dt = 1 / sr
final_time = 6.0
n_samples = int(final_time / dt)

p_params = PlateParameters()
wnx, wny = plate_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.l1, p_params.l2)
eigvals = eigenvalues_from_plate_pde(p_params, wnx, wny).reshape(-1)

print(eigvals.imag.min() / (2 * np.pi))
eigvals_d = np.exp(eigvals * dt)

states = np.vander(eigvals_d, n_samples, increasing=True).real

display(Audio(states.sum(0), rate=sr))
```

------------------------------------------------------------------------

### eigenvalues_from_drumhead_pde

>      eigenvalues_from_drumhead_pde
>                                     (drumhead_pars:__main__.CircularDrumHeadPa
>                                     rameters, Lambda_nm:numpy.ndarray)

*Compute the positive imaginary side of the eigenvalues of the
continuous-time system from the PDE parameters of the rectangular plate.
From 5.96 of Digital Sound Synthesis using the FTM, and Eq. 8 of TENSION
MODULATED NONLINEAR 2D MODELS FOR DIGITAL SOUND SYNTHESIS WITH THE
FUNCTIONAL TRANSFORMATION METHOD.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>drumhead_pars</td>
<td>CircularDrumHeadParameters</td>
<td></td>
</tr>
<tr class="even">
<td>Lambda_nm</td>
<td>ndarray</td>
<td>(n_max_modes_r, m_max_modes_theta)</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>The eigenvalues of the continuous-time system.</strong></td>
</tr>
</tbody>
</table>

``` python
n_max_modes_x = 20
n_max_modes_y = 20
sr = 44100
dt = 1 / sr
final_time = 2.0
n_samples = int(final_time / dt)
p_params = CircularDrumHeadParameters.avanzini()

v = drumhead_eigenvalues(
    drumhead_wavenumbers(n_max_modes_x, n_max_modes_y, p_params.r0)
)
eigvals = eigenvalues_from_drumhead_pde(p_params, v).reshape(-1)

# import matplotlib.pyplot as plt
print(eigvals.imag.min() / (2 * np.pi))
print(eigvals.imag.max() / (2 * np.pi))
# plt.plot(eigvals)

eigvals_d = np.exp(eigvals * dt)
states = np.vander(eigvals_d, n_samples, increasing=True).real

# fig, ax = plt.subplots(1, 1, figsize=(10, 5))
# ax.plot(states[0])
display(Audio(states[0], rate=sr))
```

------------------------------------------------------------------------

### sample_parallel_tf

>      sample_parallel_tf (num:numpy.ndarray, den:numpy.ndarray, dt:float,
>                          method:str='impulse')

*Sample a parallel transfer function using the impulse invariant
method.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>num</td>
<td>ndarray</td>
<td></td>
<td>(n_modes,)</td>
</tr>
<tr class="even">
<td>den</td>
<td>ndarray</td>
<td></td>
<td>(n_modes,)</td>
</tr>
<tr class="odd">
<td>dt</td>
<td>float</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>method</td>
<td>str</td>
<td>impulse</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>np.ndarray</strong></td>
<td></td>
<td><strong>The numerator of the discrete-time transfer
function.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### tf_initial_conditions_continuous_2

>      tf_initial_conditions_continuous_2 (D:float, density:float, d1:float,
>                                          d3:float, Ts0:float,
>                                          lambda_mu:<function array>)

*Conpute the continuous-time initial condition transfer function. This
is an alternative to the function `tf_initial_conditions_continuous`
that eigenvalues of the PDE as input.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D</td>
<td>float</td>
<td>The bending stiffness of the string or plate.</td>
</tr>
<tr class="even">
<td>density</td>
<td>float</td>
<td>The area or surface density of the string or plate.</td>
</tr>
<tr class="odd">
<td>d1</td>
<td>float</td>
<td>The linear damping coefficient, or frequency-independent
damping.</td>
</tr>
<tr class="even">
<td>d3</td>
<td>float</td>
<td>The cubic damping coefficient, or frequency-dependent damping.</td>
</tr>
<tr class="odd">
<td>Ts0</td>
<td>float</td>
<td>The initial tension of the string or plate.</td>
</tr>
<tr class="even">
<td>lambda_mu</td>
<td>array</td>
<td>The eigenvalues from the decomposition of the Laplacian
operator.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>tuple</strong></td>
<td><strong>The numerator and denominator of the transfer
function.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### tf_excitation_discrete

>      tf_excitation_discrete (eigenvalues:numpy.ndarray, density:float,
>                              dt:float)

*Compute the discrete-time excitation transfer function of a system.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>eigenvalues</td>
<td>ndarray</td>
<td>The eigenvalues of the system.</td>
</tr>
<tr class="even">
<td>density</td>
<td>float</td>
<td>surface or area density</td>
</tr>
<tr class="odd">
<td>dt</td>
<td>float</td>
<td>time step</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>tuple</strong></td>
<td><strong>The numerator of the discrete-time transfer
function.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### tf_excitation_continuous

>      tf_excitation_continuous (eigenvalues:numpy.ndarray, density:float)

*Compute the continuous excitation transfer function.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>eigenvalues</td>
<td>ndarray</td>
<td>The eigenvalues of the system.</td>
</tr>
<tr class="even">
<td>density</td>
<td>float</td>
<td>surface or area density</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>tuple</strong></td>
<td><strong>The numerator of the discrete-time transfer
function.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### tf_initial_conditions_discrete

>      tf_initial_conditions_discrete (eigenvalues:numpy.ndarray, dt:float)

*Compute the discrete-time initial conditions transfer function of a
system.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>eigenvalues</td>
<td>ndarray</td>
<td>The eigenvalues of the system.</td>
</tr>
<tr class="even">
<td>dt</td>
<td>float</td>
<td>time step</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>tuple</strong></td>
<td><strong>The numerator of the discrete-time transfer
function.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### tf_initial_conditions_continuous

>      tf_initial_conditions_continuous (eigenvalues:numpy.ndarray)

*Compute the continuos “initial-conditions” transfer function from the
eigenvalues of the system.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>eigenvalues</td>
<td>ndarray</td>
<td>The eigenvalues of the system.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>tuple</strong></td>
<td><strong>The numerator of the discrete-time transfer
function.</strong></td>
</tr>
</tbody>
</table>

``` python
b, a = tf_excitation_discrete(eigvals, p_params.surface_density, dt)
b_ic, a_ic = tf_initial_conditions_discrete(eigvals, dt)

# manual discretization
eigenvalues_d = np.exp(eigvals * dt)

# for the excitation tf
b1 = (
    np.exp(eigvals.real * dt)
    * np.sin(eigvals.imag * dt)
    / eigvals.imag
    / p_params.surface_density
)

# for the initial conditions tf
# here we ignore initial velocity
r = np.exp(eigvals.real * dt)
b1_ic = r * np.sin(eigvals.imag * dt) / eigvals.imag * -eigvals.real - r * np.cos(
    eigvals.imag * dt
)

a1 = -2 * np.exp(eigvals.real * dt) * np.cos(eigvals.imag * dt)
a2 = np.exp(2 * eigvals.real * dt)
b_manual = np.stack([np.zeros_like(b1), b1, np.zeros_like(b1)], axis=-1) * dt
a_manual = np.stack([np.ones_like(a1), a1, a2], axis=-1)

b_ic_manual = np.stack([np.ones_like(b1_ic), b1_ic], axis=-1) * dt

print(b[0])
print(b_manual[0])
print(b_ic[0] * sr)
print(b_ic_manual[0] * sr)
assert np.allclose(b[:, 1], b_manual[:, 1])
assert np.allclose(a, a_manual)
assert np.allclose(b_ic[:, :2], b_ic_manual[:, :2])
```

------------------------------------------------------------------------

### tf_freqs

>      tf_freqs (b:jax.Array, a:jax.Array, s:jax.Array)

*Compute the frequency response of a transfer function.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>Array</td>
<td>numerator (n_modes, 2)</td>
</tr>
<tr class="even">
<td>a</td>
<td>Array</td>
<td>denominator (n_modes, 3)</td>
</tr>
<tr class="odd">
<td>s</td>
<td>Array</td>
<td>frequency (n_freqs,)</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>Array</strong></td>
<td><strong>The frequency response of the transfer
function.</strong></td>
</tr>
</tbody>
</table>
