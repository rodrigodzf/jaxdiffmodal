# Numerical utilities


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

------------------------------------------------------------------------

### second_derivative_mixed

>      second_derivative_mixed (Nx, Ny, h)

------------------------------------------------------------------------

### second_derivative

>      second_derivative (Nx, Ny, h, direction='x')

\*Construct a higher-order second derivative operator matching the
MATLAB implementation of vkplate.

Parameters: Nx (int): Number of intervals in the x-direction. Ny (int):
Number of intervals in the y-direction. h (float): Grid spacing.

Returns: scipy.sparse.spmatrix: The (Nx+1)*(Ny+1) x (Nx+1)*(Ny+1) second
derivative operator.\*

------------------------------------------------------------------------

### pad_lower

>      pad_lower (vec, pad)

------------------------------------------------------------------------

### pad_upper

>      pad_upper (vec, pad)

The bilinear von Kármán operator is defined as

*L*(*f*,*g*) = *f*<sub>, *x**x*</sub>*g*<sub>, *y**y*</sub> + *f*<sub>, *y**y*</sub>*g*<sub>, *x**x*</sub> − 2*f*<sub>, *x**y*</sub>*g*<sub>, *x**y*</sub>

------------------------------------------------------------------------

### vkoperator

>      vkoperator (phi1, phi2, Dxx, Dyy, Dxy)

*Compute the numerical approximation of the von Kármán operator for two
functions phi1 and phi2.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>phi1</td>
<td>numpy.ndarray</td>
<td>The first discretized function.</td>
</tr>
<tr class="even">
<td>phi2</td>
<td>numpy.ndarray</td>
<td>The second discretized function.</td>
</tr>
<tr class="odd">
<td>Dxx</td>
<td>scipy.sparse.spmatrix</td>
<td>The second derivative operator in the x-direction.</td>
</tr>
<tr class="even">
<td>Dyy</td>
<td>scipy.sparse.spmatrix</td>
<td>The second derivative operator in the y-direction.</td>
</tr>
<tr class="odd">
<td>Dxy</td>
<td>scipy.sparse.spmatrix</td>
<td>The mixed derivative operator.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>numpy.ndarray</strong></td>
<td><strong>The numerical approximation of the von Kármán
operator<br>applied to phi1 and phi2.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### double_trapezoid_flat

>      double_trapezoid_flat (f, dx, dy, Ny, Nx)

------------------------------------------------------------------------

### double_trapezoid

>      double_trapezoid (f, dx, dy=None)

The modal coupling matrix is computed as

$$
H\_{p, q}^k=\frac{\int_S \Psi_k L\left(\Phi_p, \Phi_q\right) \mathrm{d} S}{\left\\\Psi_k\right\\\left\\\Phi_p\right\\\left\\\Phi_q\right\\}
$$

Here however we compute

*H*<sub>*p*, *q*</sub><sup>*k*</sup> = ∫<sub>*S*</sub>*Ψ*<sub>*k*</sub>*L*(*Φ*<sub>*p*</sub>,*Φ*<sub>*q*</sub>)d*S*

since the *Ψ* and *Φ* functions are normalised elsewhere.

------------------------------------------------------------------------

### compute_coupling_matrix_numerical

>      compute_coupling_matrix_numerical (psi, phi, h, nx, ny)

*Compute the coupling matrix for the given in-plane and out-of-plane
modes.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>psi</td>
<td>np.ndarray</td>
<td>The <strong>normalised</strong> in-plane modes with shape (ny+1 *
nx+1, n_modes.<br>These are stored in a flattened array
column-wise.</td>
</tr>
<tr class="even">
<td>phi</td>
<td>np.ndarray</td>
<td>The <strong>normalised</strong> out-of-plane modes with shape (ny+1
* nx+1, n_modes).<br>These are stored in a flattened array
column-wise.</td>
</tr>
<tr class="odd">
<td>h</td>
<td>float</td>
<td>The grid spacing.</td>
</tr>
<tr class="even">
<td>nx</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>ny</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

## Modal pruning

------------------------------------------------------------------------

### polarisation

>      polarisation (interpolated_eigenvectors, eigenvectors, h)

The Modal Assurance Criterion (MAC) between two eigenvectors (mode
shapes) *Φ*<sub>*i*</sub> and *Φ*<sub>*j*</sub> is:

$$
\mathrm{MAC}(\Phi_i,\Phi_j) =
\frac{|\Phi_i^{T}\\\Phi_j|^{2}}
    {\left(\Phi_i^{T}\\\Phi_i\right)\\\left(\Phi_j^{T}\\\Phi_j\right)}.
$$

MAC measures the degree of similarity (or consistency) between the two
mode shapes. A value of 1 indicates identical shapes (up to a scalar),
while a value near 0 indicates they are nearly orthogonal.

------------------------------------------------------------------------

### eigenMAC

>      eigenMAC (ref_eigenvectors, ref_nx, ref_ny, eigenvectors, eigenvalues,
>                nx, ny, n_modes, Lx, Ly, h)

*Computes the Modal Assurance Criterion (MAC) between reference
eigenvectors and given eigenvectors.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ref_eigenvectors</td>
<td>ndarray</td>
<td>Reference eigenvectors (reshaped for interpolation).</td>
</tr>
<tr class="even">
<td>ref_nx</td>
<td>int</td>
<td>Number of reference grid points along the x-axis.</td>
</tr>
<tr class="odd">
<td>ref_ny</td>
<td>int</td>
<td>Number of reference grid points along the y-axis.</td>
</tr>
<tr class="even">
<td>eigenvectors</td>
<td>ndarray</td>
<td>Eigenvectors to compare against the reference.</td>
</tr>
<tr class="odd">
<td>eigenvalues</td>
<td>ndarray</td>
<td>Corresponding eigenvalues of the eigenvectors.</td>
</tr>
<tr class="even">
<td>nx</td>
<td>int</td>
<td>Number of grid points along the x-axis for interpolation.</td>
</tr>
<tr class="odd">
<td>ny</td>
<td>int</td>
<td>Number of grid points along the y-axis for interpolation.</td>
</tr>
<tr class="even">
<td>n_modes</td>
<td>int</td>
<td>Number of modes to compare.</td>
</tr>
<tr class="odd">
<td>Lx</td>
<td>float</td>
<td>Length of the domain along the x-axis.</td>
</tr>
<tr class="even">
<td>Ly</td>
<td>float</td>
<td>Length of the domain along the y-axis.</td>
</tr>
<tr class="odd">
<td>h</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>Reordered eigenvectors after MAC computation.</strong></td>
</tr>
</tbody>
</table>

## Biharmonic decomposition

Computes the eigenvalue decomposition of the biharmonic operator for the
plate:

$$
\Delta \Delta \Phi_p(x, y)=\frac{\rho h}{D} \lambda_p^2 \Phi_p(x, y) . 
$$

*ρ*, *h* and *D* are density, tickness and bending stiffness of the
plate, respectively.

------------------------------------------------------------------------

### biharmonic_eigendecomposition

>      biharmonic_eigendecomposition (params:vkplatejax.ftm.PlateParameters,
>                                     n_modes:int, bcs:numpy.ndarray, nx:int,
>                                     ny:int, h:float,
>                                     normalise_eigenvectors=True)

\*Computes the eigenvalue decomposition of the biharmonic operator for a
plate with the given parameters and boundary conditions.

Additionally it sorts the eigenvalues and eigenvectors in ascending
order, and normalises the eigenvectors if requested.\*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>params</td>
<td>PlateParameters</td>
<td></td>
<td>The parameters of the plate.</td>
</tr>
<tr class="even">
<td>n_modes</td>
<td>int</td>
<td></td>
<td>The number of modes to compute.</td>
</tr>
<tr class="odd">
<td>bcs</td>
<td>ndarray</td>
<td></td>
<td>The boundary conditions of the plate.</td>
</tr>
<tr class="even">
<td>nx</td>
<td>int</td>
<td></td>
<td>The number of points in the x direction.</td>
</tr>
<tr class="odd">
<td>ny</td>
<td>int</td>
<td></td>
<td>The number of points in the y direction.</td>
</tr>
<tr class="even">
<td>h</td>
<td>float</td>
<td></td>
<td>The spacing between points.</td>
</tr>
<tr class="odd">
<td>normalise_eigenvectors</td>
<td>bool</td>
<td>True</td>
<td>Whether to normalise the eigenvectors.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>Tuple[np.ndarray, np.ndarray, np.ndarray]</strong></td>
<td></td>
<td><strong>The eigenvalues, eigenvectors and norms of the
eigenvectors.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### multiresolution_eigendecomposition

>      multiresolution_eigendecomposition (params, n_modes, bcs, h, nx:int,
>                                          ny:int, levels:int=2)

\*Runs the biharmonic eigendecomposition and eigenvector alignment on
multiple grid resolutions.

Parameters params: Parameters object containing domain lengths
(e.g. params.lx and params.ly). n_modes: Number of eigenmodes to
compute. bcs: Boundary conditions. h: Initial grid spacing. nx, ny:
Initial grid dimensions. levels: Total number of resolutions to run
(default 2). The first level is the coarse grid, and each subsequent
level uses h/2 and double the grid points to cover the same domain.

Returns swapped_eigenvectors, swapped_eigenvalues from the last
refinement.\*
