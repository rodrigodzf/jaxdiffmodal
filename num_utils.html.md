# Numerical utilities


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

------------------------------------------------------------------------

### second_derivative_mixed

>      second_derivative_mixed (Nx, Ny, h)

------------------------------------------------------------------------

### second_derivative

>      second_derivative (Nx, Ny, h, direction='x')

*Construct a higher-order second derivative operator matching the MATLAB
implementation of vkplate.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nx</td>
<td>int</td>
<td></td>
<td>Number of intervals in the x-direction.</td>
</tr>
<tr class="even">
<td>Ny</td>
<td>int</td>
<td></td>
<td>Number of intervals in the y-direction.</td>
</tr>
<tr class="odd">
<td>h</td>
<td>float</td>
<td></td>
<td>Grid spacing.</td>
</tr>
<tr class="even">
<td>direction</td>
<td>str</td>
<td>x</td>
<td>Direction of the second derivative operator. Can be ‘x’ or ‘y’.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>scipy.sparse.spmatrix</strong></td>
<td></td>
<td><strong>The <span
class="math inline">(<em>N</em><em>x</em>+1)(<em>N</em><em>y</em>+1) × (<em>N</em><em>x</em>+1)(<em>N</em><em>y</em>+1)</span>
second derivative operator.</strong></td>
</tr>
</tbody>
</table>

The bilinear von Kármán operator is defined as

*L*(*f*,*g*) = *f*<sub>, *x**x*</sub>*g*<sub>, *y**y*</sub> + *f*<sub>, *y**y*</sub>*g*<sub>, *x**x*</sub> − 2*f*<sub>, *x**y*</sub>*g*<sub>, *x**y*</sub>

------------------------------------------------------------------------

### vkoperator

>      vkoperator (phi1, phi2, Dxx, Dyy, Dxy)

*Compute the numerical approximation of the von Kármán operator for two
functions phi1 and phi2.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>phi1</td>
<td>numpy.ndarray</td>
<td>The first discretized function.</td>
</tr>
<tr class="even">
<td>phi2</td>
<td>numpy.ndarray</td>
<td>The second discretized function.</td>
</tr>
<tr class="odd">
<td>Dxx</td>
<td>scipy.sparse.spmatrix</td>
<td>The second derivative operator in the x-direction.</td>
</tr>
<tr class="even">
<td>Dyy</td>
<td>scipy.sparse.spmatrix</td>
<td>The second derivative operator in the y-direction.</td>
</tr>
<tr class="odd">
<td>Dxy</td>
<td>scipy.sparse.spmatrix</td>
<td>The mixed derivative operator.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>numpy.ndarray</strong></td>
<td><strong>The numerical approximation of the von Kármán
operator<br>applied to phi1 and phi2.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### double_trapezoid_flat

>      double_trapezoid_flat (f, dx, dy, Ny, Nx)

------------------------------------------------------------------------

### double_trapezoid

>      double_trapezoid (f, dx, dy=None)

------------------------------------------------------------------------

### compute_coupling_matrix_numerical

>      compute_coupling_matrix_numerical (psi:numpy.ndarray, phi:numpy.ndarray,
>                                         h:float, nx:int, ny:int)

\*Compute the coupling matrix for the given in-plane and out-of-plane
modes.

The modal coupling matrix is computed as

$$
H\_{p, q}^k =
\frac{\int_S \Psi_k L\left(\Phi_p, \Phi_q\right) \mathrm{d} S}{\left\\\Psi_k\right\\\left\\\Phi_p\right\\\left\\\Phi_q\right\\}
$$

Here however we compute

*H*<sub>*p*, *q*</sub><sup>*k*</sup> = ∫<sub>*S*</sub>*Ψ*<sub>*k*</sub>*L*(*Φ*<sub>*p*</sub>,*Φ*<sub>*q*</sub>)d*S*

since the *Ψ* and *Φ* functions are normalised elsewhere.\*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>psi</td>
<td>ndarray</td>
<td>The <strong>normalised</strong> in-plane modes with shape (ny+1 *
nx+1, n_modes.<br>These are stored in a flattened array
column-wise.</td>
</tr>
<tr class="even">
<td>phi</td>
<td>ndarray</td>
<td>The <strong>normalised</strong> out-of-plane modes with shape (ny+1
* nx+1, n_modes).<br>These are stored in a flattened array
column-wise.</td>
</tr>
<tr class="odd">
<td>h</td>
<td>float</td>
<td>The grid spacing.</td>
</tr>
<tr class="even">
<td>nx</td>
<td>int</td>
<td>The number of intervals in the x-direction.</td>
</tr>
<tr class="odd">
<td>ny</td>
<td>int</td>
<td>The number of intervals in the y-direction.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>np.ndarray</strong></td>
<td><strong>The coupling matrix with shape (n_modes, n_modes,
n_modes).</strong></td>
</tr>
</tbody>
</table>

## Modal pruning

------------------------------------------------------------------------

### polarisation

>      polarisation (interpolated_eigenvectors, eigenvectors, h)

------------------------------------------------------------------------

### eigenMAC

>      eigenMAC (ref_eigenvectors, ref_nx, ref_ny, eigenvectors, eigenvalues,
>                nx, ny, n_modes, Lx, Ly, h)

\*Computes the Modal Assurance Criterion (MAC) between reference
eigenvectors and given eigenvectors.

The Modal Assurance Criterion (MAC) between two eigenvectors (mode
shapes) *Φ*<sub>*i*</sub> and *Φ*<sub>*j*</sub> is:

$$
\mathrm{MAC}(\Phi_i,\Phi_j) =
\frac{|\Phi_i^{T}\\\Phi_j|^{2}}
    {\left(\Phi_i^{T}\\\Phi_i\right)\\\left(\Phi_j^{T}\\\Phi_j\right)}.
$$

MAC measures the degree of similarity (or consistency) between the two
mode shapes. A value of 1 indicates identical shapes (up to a scalar),
while a value near 0 indicates they are nearly orthogonal.\*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ref_eigenvectors</td>
<td>ndarray</td>
<td>Reference eigenvectors (reshaped for interpolation).</td>
</tr>
<tr class="even">
<td>ref_nx</td>
<td>int</td>
<td>Number of reference grid points along the x-axis.</td>
</tr>
<tr class="odd">
<td>ref_ny</td>
<td>int</td>
<td>Number of reference grid points along the y-axis.</td>
</tr>
<tr class="even">
<td>eigenvectors</td>
<td>ndarray</td>
<td>Eigenvectors to compare against the reference.</td>
</tr>
<tr class="odd">
<td>eigenvalues</td>
<td>ndarray</td>
<td>Corresponding eigenvalues of the eigenvectors.</td>
</tr>
<tr class="even">
<td>nx</td>
<td>int</td>
<td>Number of grid points along the x-axis for interpolation.</td>
</tr>
<tr class="odd">
<td>ny</td>
<td>int</td>
<td>Number of grid points along the y-axis for interpolation.</td>
</tr>
<tr class="even">
<td>n_modes</td>
<td>int</td>
<td>Number of modes to compare.</td>
</tr>
<tr class="odd">
<td>Lx</td>
<td>float</td>
<td>Length of the domain along the x-axis.</td>
</tr>
<tr class="even">
<td>Ly</td>
<td>float</td>
<td>Length of the domain along the y-axis.</td>
</tr>
<tr class="odd">
<td>h</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td><strong>Reordered eigenvectors after MAC computation.</strong></td>
</tr>
</tbody>
</table>

## Biharmonic decomposition

Computes the eigenvalue decomposition of the biharmonic operator for the
plate:

$$
\Delta \Delta \Phi_p(x, y)=\frac{\rho h}{D} \lambda_p^2 \Phi_p(x, y) . 
$$

*ρ*, *h* and *D* are density, tickness and bending stiffness of the
plate, respectively.

------------------------------------------------------------------------

### biharmonic_eigendecomposition

>      biharmonic_eigendecomposition (params:vkplatejax.ftm.PlateParameters,
>                                     n_modes:int, bcs:numpy.ndarray, nx:int,
>                                     ny:int, h:float,
>                                     normalise_eigenvectors=True)

\*Computes the eigenvalue decomposition of the biharmonic operator for a
plate with the given parameters and boundary conditions.

Additionally it sorts the eigenvalues and eigenvectors in ascending
order, and normalises the eigenvectors if requested.\*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>params</td>
<td>PlateParameters</td>
<td></td>
<td>The parameters of the plate.</td>
</tr>
<tr class="even">
<td>n_modes</td>
<td>int</td>
<td></td>
<td>The number of modes to compute.</td>
</tr>
<tr class="odd">
<td>bcs</td>
<td>ndarray</td>
<td></td>
<td>The boundary conditions of the plate.</td>
</tr>
<tr class="even">
<td>nx</td>
<td>int</td>
<td></td>
<td>The number of points in the x direction.</td>
</tr>
<tr class="odd">
<td>ny</td>
<td>int</td>
<td></td>
<td>The number of points in the y direction.</td>
</tr>
<tr class="even">
<td>h</td>
<td>float</td>
<td></td>
<td>The spacing between points.</td>
</tr>
<tr class="odd">
<td>normalise_eigenvectors</td>
<td>bool</td>
<td>True</td>
<td>Whether to normalise the eigenvectors.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>Tuple[np.ndarray, np.ndarray, np.ndarray]</strong></td>
<td></td>
<td><strong>The eigenvalues, eigenvectors and norms of the
eigenvectors.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### multiresolution_eigendecomposition

>      multiresolution_eigendecomposition
>                                          (params:vkplatejax.ftm.PlateParameter
>                                          s, n_modes:int, bcs:numpy.ndarray,
>                                          h:float, nx:int, ny:int,
>                                          levels:int=2)

*Runs the biharmonic eigendecomposition and eigenvector alignment on
multiple grid resolutions.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>params</td>
<td>PlateParameters</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>n_modes</td>
<td>int</td>
<td></td>
<td>Number of eigenmodes to compute.</td>
</tr>
<tr class="odd">
<td>bcs</td>
<td>ndarray</td>
<td></td>
<td>Boundary conditions.</td>
</tr>
<tr class="even">
<td>h</td>
<td>float</td>
<td></td>
<td>Initial grid spacing.</td>
</tr>
<tr class="odd">
<td>nx</td>
<td>int</td>
<td></td>
<td>Number of grid points in the x-direction.</td>
</tr>
<tr class="even">
<td>ny</td>
<td>int</td>
<td></td>
<td>Number of grid points in the y-direction.</td>
</tr>
<tr class="odd">
<td>levels</td>
<td>int</td>
<td>2</td>
<td>Total number of resolutions to run (default 2).<br>The first level
is the coarse grid, and each subsequent level<br>uses h/2 and double the
grid points to cover the same domain.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>swapped_eigenvectors, swapped_eigenvalues from the last
refinement.</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
