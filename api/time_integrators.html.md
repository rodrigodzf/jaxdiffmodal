# Time integrators


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

A collection of efficient time integration methods for the damped
oscillator with optional nonlinearities and initial conditions or
excitation inputs.

## Stormer-verlet

The stormer-verlet is a centered difference scheme used to approximate
derivatives. In the present case we use it for approximating the second
and first derivatives of an oscillator defined by the following
differential equation:

$$
\ddot{q} + c \dot{q} + k q = f(t)
$$

The finite difference operators are defined as:

$$
\begin{align}
\delta_t q &= \frac{q^{n+1} - q^{n-1}}{2 h} \\
\delta\_{tt} q &= \frac{q^{n+1} - 2 q^n + q^{n-1}}{h^2}
\end{align}
$$

for the first derivative and the second derivative respectively. The
difference equation for the oscillator is then:

*δ*<sub>*t**t*</sub>*q* + *c**δ*<sub>*t*</sub>*q* + *k**q* = *f*(*t*)

after expanding and some algebraic manipulation to isolate
*q*<sup>*n* + 1</sup> we get:

$$
\bigl(\tfrac{1}{h^2} + \tfrac{c}{2h}\bigr)\\q^{n+1} +
\bigl(-\tfrac{2}{h^2} + k\bigr) q^n +
\bigl(\tfrac{1}{h^2} - \tfrac{c}{2h}\bigr)\\q^{n-1} =
f(t^n).
$$

$$
\boxed{
q^{n+1} = \frac{2 h^2}{2 + c h}
\Bigl\[
f(t^n) + \Bigl(\tfrac{2}{h^2} - k\Bigr) q^n +
\Bigl(-\tfrac{1}{h^2} + \tfrac{c}{2h}\Bigr) q^{n-1}
\Bigr\].
}
$$

To make it more readable we can define the following constants:

$$
\begin{align}
a &= \frac{2 h^2}{2 + c h} \\
b &= \frac{2}{h^2} - k \\
c &= -\frac{1}{h^2} + \frac{c}{2h}
\end{align}
$$

------------------------------------------------------------------------

### make_tm_nl_fn

>  make_tm_nl_fn (lambda_mu, factors)

*Returns a function that computes nl given q.*

------------------------------------------------------------------------

### make_vk_nl_fn

>  make_vk_nl_fn (H)

*Returns a function that computes nl given q.*

------------------------------------------------------------------------

### make_identity_nl_fn

>  make_identity_nl_fn ()

------------------------------------------------------------------------

### string_tau_with_density

>  string_tau_with_density (string_params)

------------------------------------------------------------------------

### second_order_step

>  second_order_step (u0:jax.Array, v0:jax.Array, dt:float,
>                         gamma2_mu:jax.Array, omega_mu_squared:jax.Array)

*One step of 2nd-order Taylor expansion for damped oscillator. Returns:
(u1, v1)*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>u0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>v0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td>time step</td>
</tr>
<tr>
<td>gamma2_mu</td>
<td>Array</td>
<td>damping (n_modes,)</td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td>Array</td>
<td>frequency (n_modes,)</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### rk4_step

>  rk4_step (u0:jax.Array, v0:jax.Array, dt:float, gamma2_mu:jax.Array,
>                omega_mu_squared:jax.Array)

*One step of RK4 for the second-order damped oscillator. Returns: (u1,
v1)*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>u0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>v0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td>time step</td>
</tr>
<tr>
<td>gamma2_mu</td>
<td>Array</td>
<td>damping (n_modes,)</td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td>Array</td>
<td>frequency (n_modes,)</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### solve_sv_initial_conditions

>  solve_sv_initial_conditions (gamma2_mu, omega_mu_squared, u0:jax.Array,
>                                   v0:jax.Array, dt:float, n_steps:int,
>                                   nl_fn:collections.abc.Callable)

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>gamma2_mu</td>
<td></td>
<td>(n_modes,)</td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td></td>
<td>(n_modes,)</td>
</tr>
<tr>
<td>u0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>v0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>n_steps</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>nl_fn</td>
<td>Callable</td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### solve_sv_excitation

>  solve_sv_excitation (gamma2_mu, omega_mu_squared,
>                           modal_excitation:jax.Array, dt:float,
>                           nl_fn:collections.abc.Callable)

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>gamma2_mu</td>
<td></td>
<td>(n_modes,)</td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td></td>
<td>(n_modes,)</td>
</tr>
<tr>
<td>modal_excitation</td>
<td>Array</td>
<td>(T, n_modes)</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>nl_fn</td>
<td>Callable</td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### solve_sv_vk_jax_scan

>  solve_sv_vk_jax_scan (A_inv:jax.Array, B:jax.Array, C:jax.Array,
>                            modal_excitation:jax.Array,
>                            nl_fn:collections.abc.Callable)

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>A_inv</td>
<td>Array</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>Array</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>Array</td>
<td></td>
</tr>
<tr>
<td>modal_excitation</td>
<td>Array</td>
<td>(T, n_modes)</td>
</tr>
<tr>
<td>nl_fn</td>
<td>Callable</td>
<td></td>
</tr>
</tbody>
</table>

## Discretised transfer function method

------------------------------------------------------------------------

### solve_tf_initial_conditions

>  solve_tf_initial_conditions (gamma2_mu, omega_mu_squared, u0:jax.Array,
>                                   v0:jax.Array, dt:float, n_steps:int,
>                                   nl_fn:collections.abc.Callable)

*Solve using transfer-function (TF) based recurrence.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>gamma2_mu</td>
<td></td>
<td></td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td></td>
<td></td>
</tr>
<tr>
<td>u0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>v0</td>
<td>Array</td>
<td>initial conditions (n_modes,)</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>n_steps</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>nl_fn</td>
<td>Callable</td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### solve_tf_excitation

>  solve_tf_excitation (gamma2_mu, omega_mu_squared,
>                           modal_excitation:jax.Array, dt:float,
>                           nl_fn:collections.abc.Callable)

*Solve using transfer-function (TF) based recurrence.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>gamma2_mu</td>
<td></td>
<td></td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td></td>
<td></td>
</tr>
<tr>
<td>modal_excitation</td>
<td>Array</td>
<td>(T, n_modes)</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>nl_fn</td>
<td>Callable</td>
<td></td>
</tr>
</tbody>
</table>

## Sinusoidal solve

Solve the system of ODEs using complex exponentials

The system of ODEs is given by:

$$
\ddot{q} + 2 \gamma \dot{q} + \omega^2 q = 0
$$

where *γ* is the damping coefficient and *ω* is the frequency. The
damped frequencies are given by:

$$
\tilde{\omega} = \omega \sqrt{1 - \gamma^2} = \sqrt{\omega^2 - \gamma^2}
$$
The eigenvalues after the dispersion relation are then
*s*<sub>±</sub> = −*γ* ± *i**ω̃*

and discrete time eigenvalues (poles) are
*z*<sub>±</sub> = *e*<sup>*s*<sub>±</sub>*Δ**t*</sup> = *e*<sup>−*γ**Δ**t*</sup>*e*<sup>±*i**ω̃**Δ**t*</sup>

------------------------------------------------------------------------

### solve_sinusoidal

>  solve_sinusoidal (gamma2_mu, omega_mu_squared, ic, n_steps, dt)

*Solve the system of ODEs using complex exponentials NB: this assumes
the ic is only for positions and that the initial velocities are 0*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>gamma2_mu</td>
<td>jnp.ndarray</td>
<td>Damping coefficients</td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td>jnp.ndarray</td>
<td>Squared frequencies</td>
</tr>
<tr>
<td>ic</td>
<td>jnp.ndarray</td>
<td>Initial conditions</td>
</tr>
<tr>
<td>n_steps</td>
<td>int</td>
<td>Number of steps</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td>Time step</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>jnp.ndarray</strong></td>
<td><strong>Modal solution</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### solve_sinusoidal_excitation

>  solve_sinusoidal_excitation (gamma2_mu, omega_mu_squared,
>                                   modal_excitation:jax.Array, dt:float)

*Solve the modal system with sinusoidal response for external excitation
using parallel scan.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>gamma2_mu</td>
<td>jnp.ndarray</td>
<td>Damping coefficients (n_modes,)</td>
</tr>
<tr>
<td>omega_mu_squared</td>
<td>jnp.ndarray</td>
<td>Squared frequencies (n_modes,)</td>
</tr>
<tr>
<td>modal_excitation</td>
<td>Array</td>
<td>(T, n_modes)</td>
</tr>
<tr>
<td>dt</td>
<td>float</td>
<td>Time step</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>jnp.ndarray</strong></td>
<td><strong>Modal solution (T, n_modes)</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### solve_tf_ic

>  solve_tf_ic (gamma2_mu, omega_mu_squared, ic, n_steps, dt, nl_fn)
