# LPC


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

### Utility functions

------------------------------------------------------------------------

### discrete_convolution

>  discrete_convolution (x:numpy.ndarray, a:numpy.ndarray, zi=None)

*Convolves a signal x with a time-varying filter defined by a.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>ndarray</td>
<td></td>
<td>(time,)</td>
</tr>
<tr>
<td>a</td>
<td>ndarray</td>
<td></td>
<td>(time, p)</td>
</tr>
<tr>
<td>zi</td>
<td>NoneType</td>
<td>None</td>
<td>(p,)</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### covariance_matrix_np

>  covariance_matrix_np (x:numpy.ndarray, p:int, L:int=None)

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>ndarray</td>
<td></td>
<td>(time,)</td>
</tr>
<tr>
<td>p</td>
<td>int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>L</td>
<td>int</td>
<td>None</td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### covariance_matrix

>  covariance_matrix (x:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.numbe
>                         r,bool,int,float,complex], p:int, L:int=None)

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>Union</td>
<td></td>
<td>(batch, time)</td>
</tr>
<tr>
<td>p</td>
<td>int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>L</td>
<td>int</td>
<td>None</td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### unfold_np

>  unfold_np (x, kernel_size, stride=1)

*Unfolds a signal x (batch, time, channels) into a matrix of patches of
size kernel_size and stride, similar to the pytorch unfold function,
using numpy’s as_strided function.*

------------------------------------------------------------------------

### unfold

>  unfold (x:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.number,bool,int,
>              float,complex], kernel_size:int, stride:int=1)

*Unfolds a signal x into a matrix of patches of size kernel_size and
stride similar to the pytorch unfold function.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>Union</td>
<td></td>
<td>(batch, time, channels)</td>
</tr>
<tr>
<td>kernel_size</td>
<td>int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>stride</td>
<td>int</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>

    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:
      else: warn(msg)

------------------------------------------------------------------------

### autocorr

>  autocorr (x:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.number,bool,in
>                t,float,complex], p:int, biased:bool=True)

*Computes the autocorrelation of a signal x up to lag p.*

------------------------------------------------------------------------

### next_power_of_2

>  next_power_of_2 (x)

``` python
x = np.arange(10).astype(np.float64)
unfolded_jax = unfold(x[None, :, None], 3)
unfolded_np = unfold_np(x, 3)

X_np = covariance_matrix_np(x, 3, len(x))
X_jax = covariance_matrix(x[None, :], 3, len(x))

assert np.allclose(X_np, X_jax[0])
assert np.allclose(unfolded_np, unfolded_jax[0])
```

    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Parameters: 
    ---------- in 
    Compute the Linear Prediction Coefficients (LPC) of a signal x.
    Based on "Introduction to Digital Speech Processing" by Rabiner and Schafer....
      else: warn(msg)
    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Returns: 
    ------- in 
    Compute the Linear Prediction Coefficients (LPC) of a signal x.
    Based on "Introduction to Digital Speech Processing" by Rabiner and Schafer....
      else: warn(msg)

------------------------------------------------------------------------

### lpc_cpu_solve

>  lpc_cpu_solve (x:numpy.ndarray, p:int, method='autocorrelation',
>                     **kwargs)

\*Compute the Linear Prediction Coefficients (LPC) of a signal x. Based
on “Introduction to Digital Speech Processing” by Rabiner and Schafer.

## Parameters:

x: np.ndarray The input signal. p: int The order of the LPC. method: str
The method to compute the LPC. Either “autocorrelation” or “covariance”.

## Returns:

np.ndarray The LPC coefficients. int The gain (or the square root of the
energy) of the residual signal.\*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>ndarray</td>
<td></td>
<td>(time,)</td>
</tr>
<tr>
<td>p</td>
<td>int</td>
<td></td>
<td>order</td>
</tr>
<tr>
<td>method</td>
<td>str</td>
<td>autocorrelation</td>
<td>method for the lpc computation</td>
</tr>
<tr>
<td>kwargs</td>
<td>VAR_KEYWORD</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Tuple</strong></td>
<td></td>
<td><strong>additional arguments for the method</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### jitted_linear_solve

>  jitted_linear_solve (x, p)

------------------------------------------------------------------------

### jitted_lstsq

>  jitted_lstsq (x, p)

``` python
x = np.random.randn(100)

p = 4
a_autocorr, g_autocorr = lpc_cpu_solve(x, p, method="autocorrelation", biased=False)
a_covar, g_covar = lpc_cpu_solve(x, p, method="covariance")

print(a_autocorr, g_autocorr)
print(a_covar, g_covar)
```

    [-0.03891267  0.05897309 -0.11110881 -0.10518435] 8.848879174571616
    [-0.05351606  0.04524858 -0.09969181 -0.10755192] 8.666443074154966

    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Parameters: 
    ---------- in 
    Computes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.
    ...
      else: warn(msg)
    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Returns: 
    ---------- in 
    Computes the linear prediction of a 1D signal. The signal will be padded on the left with zeros.
    ...
      else: warn(msg)
    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:
      else: warn(msg)

------------------------------------------------------------------------

### linear_prediction

>  linear_prediction (x:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.numbe
>                         r,bool,int,float,complex], a:Union[jax.Array,numpy.nda
>                         rray,numpy.bool,numpy.number,bool,int,float,complex])

\*Computes the linear prediction of a 1D signal. The signal will be
padded on the left with zeros.

## Parameters:

x: ArrayLike The signal used to compute the linear prediction a:
ArrayLike The coefficients of the linear prediction\*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>Union</td>
<td>(T)</td>
</tr>
<tr>
<td>a</td>
<td>Union</td>
<td>(p)</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Union</strong></td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### linear_prediction_np

>  linear_prediction_np (x:numpy.ndarray, a:numpy.ndarray)

\*Computes the linear prediction of a 1D signal. The signal will be
padded on the left with zeros.

## Parameters:

x: ArrayLike The signal used to compute the linear prediction a:
ArrayLike The coefficients of the linear prediction\*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>ndarray</td>
<td>(T,)</td>
</tr>
<tr>
<td>a</td>
<td>ndarray</td>
<td>(p,)</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
</tr>
</tbody>
</table>

``` python
rng = np.random.default_rng(42)
x = rng.normal(0, 1, 100)
a = rng.normal(0, 1, 4)

lp_np = linear_prediction_np(x, a)
lp_jax = linear_prediction(x, a)

assert np.allclose(lp_np, lp_jax)
```

    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Parameters: 
    ---------- in 
    Computes the inverse filter of a signal x using the coefficients a.
    ...
      else: warn(msg)
    /home/diaz/projects/jaxdiffmodal_clean/.venv/lib/python3.11/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... 
    Returns: 
    ---------- in 
    Computes the inverse filter of a signal x using the coefficients a.
    ...
      else: warn(msg)

------------------------------------------------------------------------

### inverse_filter_np

>  inverse_filter_np (x:numpy.ndarray, a:numpy.ndarray)

\*Computes the inverse filter of a signal x using the coefficients a.

## Parameters:

x: ArrayLike The signal used to compute the inverse filter a: ArrayLike
The coefficients of the linear prediction\*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>ndarray</td>
<td>(T,)</td>
</tr>
<tr>
<td>a</td>
<td>ndarray</td>
<td>(p,)</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>ndarray</strong></td>
<td></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### coeffs_and_residual

>  coeffs_and_residual (y:Union[jax.Array,numpy.ndarray,numpy.bool,numpy.num
>                           ber,bool,int,float,complex], p:int, **kwargs)

*Utility function to compute the LPC coefficients and the residual.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>y</td>
<td>Union</td>
<td>input signal (time,)</td>
</tr>
<tr>
<td>p</td>
<td>int</td>
<td>number of coefficients</td>
</tr>
<tr>
<td>kwargs</td>
<td>VAR_KEYWORD</td>
<td></td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Tuple</strong></td>
<td><strong>coefficients (p+1) and residual and gain</strong></td>
</tr>
</tbody>
</table>

``` python
rng = np.random.default_rng(42)
x = rng.normal(size=1000)
pole = np.array([0.999 * np.exp(1j * np.pi / 4)])
poles = np.concatenate([pole, np.conj(pole)])
b, a = scipy.signal.zpk2tf([], poles, 1)
y = scipy.signal.lfilter(b, a, x)

p = 10
a_autocorr, e_hat_autocorr, _ = coeffs_and_residual(x, p, method="autocorrelation")
a_covar, e_hat_covar, _ = coeffs_and_residual(x, p, method="covariance")
```
