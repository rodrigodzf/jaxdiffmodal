# Coupling functions


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Integrals for building the mass and stifness matrices

------------------------------------------------------------------------

### assemble_K_and_M

>  assemble_K_and_M (Npsi, Lx, Ly)

------------------------------------------------------------------------

### build_I4

>  build_I4 (N, L)

*Returns the N x N matrix whose (m,p) entry = int4(m,p,L).*

------------------------------------------------------------------------

### build_I2

>  build_I2 (N, L)

*Returns the N x N matrix whose (m,p) entry = int2(m,p,L).*

------------------------------------------------------------------------

### build_I1

>  build_I1 (N, L)

*Returns the N x N matrix whose (m,p) entry = int1(m,p,L).*

------------------------------------------------------------------------

### int2_mat

>  int2_mat (N, L)

*Builds the N x N matrix whose (m,p) entry is int2(m,p,L). Mirrors the
logic of the original Matlab int2_mat function exactly, but we can do it
more simply by calling int2 in a loop.*

------------------------------------------------------------------------

### int2

>  int2 (m, p, L)

*Function int2(m,p,L). Piecewise definition from the Matlab code.*

------------------------------------------------------------------------

### int1

>  int1 (m, p, L)

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>int</td>
<td>First mode number</td>
</tr>
<tr>
<td>p</td>
<td>int</td>
<td>Second mode number</td>
</tr>
<tr>
<td>L</td>
<td>float</td>
<td>Length of the domain</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>float</strong></td>
<td><strong>Value of the integral</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### int4

>  int4 (m:int, p:int, L:float)

*Compute the integral of Xd(m,x)*Xd(p,x) from 0 to L, where X is the
clamped-plate function and d denotes derivative in x.

The integral is computed for different cases based on the mode numbers m
and p.\*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>int</td>
<td>First mode number</td>
</tr>
<tr>
<td>p</td>
<td>int</td>
<td>Second mode number</td>
</tr>
<tr>
<td>L</td>
<td>float</td>
<td>Length of the domain</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>float</strong></td>
<td><strong>Value of the integral</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### airy_stress_coefficients

>  airy_stress_coefficients (n_psi, vals, vecs)

*Compute the Airy stress function coefficients from the eigenvalues and
eigenvectors*

## Basis used to build the mass and stiffness matrices

------------------------------------------------------------------------

### basis

>  basis (m:int, n:int, x:float|numpy.ndarray, y:float|numpy.ndarray,
>             Lx:float, Ly:float)

\*Evaluate the full 2D basis function for indices (m, n) at point (x,
y).

The basis function is defined as:

.. math:: \_{mn}(x,y) = X_m(x)Y_n(y)

where X_m and Y_n are the 1D basis functions in x and y directions.\*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>int</td>
<td>Mode number in x direction</td>
</tr>
<tr>
<td>n</td>
<td>int</td>
<td>Mode number in y direction</td>
</tr>
<tr>
<td>x</td>
<td>float | numpy.ndarray</td>
<td>x coordinate(s) where to evaluate</td>
</tr>
<tr>
<td>y</td>
<td>float | numpy.ndarray</td>
<td>y coordinate(s) where to evaluate</td>
</tr>
<tr>
<td>Lx</td>
<td>float</td>
<td>Length in x direction</td>
</tr>
<tr>
<td>Ly</td>
<td>float</td>
<td>Length in y direction</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>float | numpy.ndarray</strong></td>
<td><strong>Value of the basis function at (x,y)</strong></td>
</tr>
</tbody>
</table>

## Partial integrals to calculate the coupling matrix

------------------------------------------------------------------------

### i13_mat

>  i13_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i12_mat

>  i12_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i11_mat

>  i11_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i10_mat

>  i10_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i9_mat

>  i9_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i5_mat

>  i5_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i4_mat

>  i4_mat (Npsi, Nphi, L)

*Auxiliary integral for the computation of the coupling coefficient H.*

------------------------------------------------------------------------

### i3_mat

>  i3_mat (Npsi, Nphi, L)

*Auxiliary integral for the computation of the coupling coefficient H.*

------------------------------------------------------------------------

### i2_mat

>  i2_mat (Npsi, Nphi, L)

------------------------------------------------------------------------

### i1_mat

>  i1_mat (Npsi, Nphi, L)

## functions to put together the coupling matrix

------------------------------------------------------------------------

### g6

>  g6 (Npsi, Nphi, S, ky, cache)

------------------------------------------------------------------------

### g5

>  g5 (Npsi, Nphi, S, kx, cache)

------------------------------------------------------------------------

### g4

>  g4 (Npsi, Nphi, S, ky, cache)

------------------------------------------------------------------------

### g3

>  g3 (Npsi, Nphi, S, ky, cache)

------------------------------------------------------------------------

### g2

>  g2 (Npsi, Nphi, S, kx, cache)

------------------------------------------------------------------------

### g1

>  g1 (Npsi, Nphi, S, kx, cache)

------------------------------------------------------------------------

### build_s_matrix

>  build_s_matrix (Npsi, Nphi, partials, idx_array, factor_mode)

*Summation of partial integrals in a 3D array with a factor.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Npsi</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Nphi</td>
<td></td>
<td></td>
</tr>
<tr>
<td>partials</td>
<td></td>
<td></td>
</tr>
<tr>
<td>idx_array</td>
<td></td>
<td></td>
</tr>
<tr>
<td>factor_mode</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>np.ndarray of shape (Npsi, Nphi, Nphi)</strong></td>
<td><strong>The 3D tensor after summation and factor
application.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### compute_partial_integrals

>  compute_partial_integrals (Npsi, Nphi, Lx, Ly)

*Precompute and store all partial-integral matrices needed. Returns them
in a dictionary or a custom object.*

------------------------------------------------------------------------

### H_tensor_rectangular

>  H_tensor_rectangular (coeff0, coeff1, coeff2, Nphi, Npsi, Lx, Ly, kx, ky)

*Compute the H tensor for rectangular plates.*

------------------------------------------------------------------------

### compute_coupling_matrix

>  compute_coupling_matrix (n_psi, n_phi, lx, ly, kx_indices, ky_indices)
